<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Affinoid subdomains of the Berkovich line. &mdash; MCLF  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="MCLF  documentation" href="index.html" />
    <link rel="up" title="The Berkovich line" href="berkovich.html" />
    <link rel="next" title="Semistable reduction of curves" href="semistable_reduction.html" />
    <link rel="prev" title="Points of type V on the Berkovich line." href="type_V_points.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="semistable_reduction.html" title="Semistable reduction of curves"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="type_V_points.html" title="Points of type V on the Berkovich line."
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MCLF  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="berkovich.html" accesskey="U">The Berkovich line</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-mclf.berkovich.affinoid_domain"></span><div class="section" id="affinoid-subdomains-of-the-berkovich-line">
<h1>Affinoid subdomains of the Berkovich line.<a class="headerlink" href="#affinoid-subdomains-of-the-berkovich-line" title="Permalink to this headline">¶</a></h1>
<p>Let <span class="math">\(K\)</span> be a field and <span class="math">\(v_K\)</span> a discrete valuation on <span class="math">\(K\)</span>. Let <span class="math">\(X=\mathbb{P}^1_K\)</span>
be the projective line over <span class="math">\(K\)</span>. Let <span class="math">\(X^{an}\)</span> denote the
<span class="math">\((K,v_K)\)</span>-analytic space associated to <span class="math">\(X\)</span>. We call <span class="math">\(X^{an}\)</span> the <strong>Berkovich
line</strong> over <span class="math">\(K\)</span>.</p>
<p>In this file we realize a Sage class which allows us to create and work with
strictly affinoid subdomains of <span class="math">\(X^{an}\)</span>.</p>
<p>Let <span class="math">\(T\)</span> be a Berkovich tree in <span class="math">\(X^{an}\)</span> and let <span class="math">\(r:T--&gt;X^{an}\)</span> denote the
canonical retraction map. Let <span class="math">\(S\)</span> be a nonempty proper subset of <span class="math">\(V(T)\)</span>.
We define <span class="math">\(\bar{S}\)</span> as the union of <span class="math">\(S\)</span> and of all edges connecting two points
of <span class="math">\(S\)</span>. Then the inverse image <span class="math">\(U:=r^{-1}(\bar{S})\)</span> is an affinoid subdomain of
<span class="math">\(X^{an}\)</span>. We use the notation <span class="math">\(U=U(T,S)\)</span>.</p>
<p>We say that a Berkovich tree <span class="math">\(T\)</span> <em>supports</em> an affinoid domain <span class="math">\(U\)</span> if there
exists a nonempty proper subset <span class="math">\(S\)</span> of <span class="math">\(V(T)\)</span> with <span class="math">\(U=U(T,S)\)</span>. If this is the
case then <span class="math">\(S\)</span> consists exactly of the vertices of <span class="math">\(T\)</span> which lie in <span class="math">\(U\)</span>.</p>
<p>Given any affinoid domain <span class="math">\(U\)</span>, there exists a unique minimal tree <span class="math">\(T\)</span> which
supports <span class="math">\(U\)</span>. Moreover, every tree <span class="math">\(T'\)</span> which contracts to <span class="math">\(T'\)</span> supports <span class="math">\(U\)</span>
as well.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Stefan Wewers (2017-07-29): initial version</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Lots</span> <span class="ow">and</span> <span class="n">lots</span> <span class="n">of</span> <span class="n">examples</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>TO DO:</p>
<ul class="simple">
<li>more doctests</li>
<li>improve performance; many algorithms can be replaced by more efficient ones</li>
<li>add missing functions: intersection, ..</li>
</ul>
<dl class="class">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">AffinoidDomainOnBerkovichLine</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>The class realizing affinoid domains on a Berkovich line.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U1</span> <span class="o">=</span> <span class="n">RationalDomainOnBerkovichLine</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">U2</span> <span class="o">=</span> <span class="n">RationalDomainOnBerkovichLine</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">U1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">U2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span>
<span class="go">Affinoid with 1 components:</span>
<span class="go">Elementary affinoid defined by</span>
<span class="go">v(1/(x + 1)) &gt;= -1</span>
</pre></div>
</div>
<p>TO DO:</p>
<ul class="simple">
<li></li>
</ul>
<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.boundary">
<code class="descname">boundary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Shilov boundary of the affinoid.</p>
<p>The Shilov boundary is a finite set of type-II-points contained in the
affinoid with the property that the valuative function of every rational
function which is regular on the affinoid takes a minimum on this set.</p>
<p>The Shilov boundary is automatically computed when we construct the
connected components.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the affinoid which is the intersection of <code class="docutils literal"><span class="pre">self</span></code> with <code class="docutils literal"><span class="pre">V</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.is_contained_in">
<code class="descname">is_contained_in</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.is_contained_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal"><span class="pre">x</span></code> lies on the affinoid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi</span></code> &#8211; a point on the Berkovich line underlying the affinoid</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">xi</span></code> lies on the affinoid, <code class="docutils literal"><span class="pre">False</span></code> otherwise</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.point_close_to_boundary">
<code class="descname">point_close_to_boundary</code><span class="sig-paren">(</span><em>xi0</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.point_close_to_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a type-I-point inside the affinoid, close to <code class="docutils literal"><span class="pre">xi0</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi0</span></code> &#8211; a boundary point of the affinoid <code class="docutils literal"><span class="pre">self</span></code></li>
</ul>
<p>OUTPUT: a type-I-point <code class="docutils literal"><span class="pre">xi1</span></code> on the affinoid <span class="math">\(U:=\)</span> <code class="docutils literal"><span class="pre">self</span></code> which
is &#8220;close&#8221; to the boundary point <code class="docutils literal"><span class="pre">xi0</span></code>.</p>
<p>The latter means that <code class="docutils literal"><span class="pre">xi1</span></code> maps onto the irreducible components
of the canonical reduction of <span class="math">\(U\)</span> corresponding to <code class="docutils literal"><span class="pre">xi0</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">RationalDomainOnBerkovichLine</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">U</span>
<span class="go">Affinoid with 1 components:</span>
<span class="go">Elementary affinoid defined by</span>
<span class="go">v(1/x) &gt;= -1</span>
<span class="go">v(1/(x + 1)) &gt;= -1</span>
<span class="gp">sage: </span><span class="n">xi0</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">boundary</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">point_close_to_boundary</span><span class="p">(</span><span class="n">xi0</span><span class="p">)</span>
<span class="go">Point of type I on Berkovich line given by x + 2 = 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify this affinoid.</p>
<p>This only changes the internal representation by an &#8220;affinoid tree&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidDomainOnBerkovichLine.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the affinoid which is the union of <code class="docutils literal"><span class="pre">self</span></code> with <code class="docutils literal"><span class="pre">V</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree">
<em class="property">class </em><code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">AffinoidTree</code><span class="sig-paren">(</span><em>X</em>, <em>root=None</em>, <em>children=None</em>, <em>parent=None</em>, <em>is_in_affinoid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree" title="Permalink to this definition">¶</a></dt>
<dd><p>A marked Berkovich tree representing an affinoid subdomain.</p>
<p>An AffinoidTree is a Berkovich tree <span class="math">\(T\)</span> in which every vertex has an additional
flag &#8220;is_in_affinoid&#8221; with value <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>. It represents an
affinoid subdomain <span class="math">\(U\)</span> in the way explained above.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code> &#8211; a Berkovich line</li>
<li><code class="docutils literal"><span class="pre">root</span></code> &#8211; a point on <a href="#id1"><span class="problematic" id="id2">``</span></a>X``or None (default = None)</li>
<li><code class="docutils literal"><span class="pre">children</span></code> &#8211; a list of affinoid trees or None (default = None)</li>
<li><code class="docutils literal"><span class="pre">parent</span></code> &#8211; an affinoid tree or none (default = None)</li>
<li><code class="docutils literal"><span class="pre">is_in_affinoid</span></code> &#8211; a boolean or None (default = None)</li>
</ul>
<p>OUTPUT:</p>
<p>An affinoid tree on <code class="docutils literal"><span class="pre">X</span></code>. It is either empty (if only <code class="docutils literal"><span class="pre">X</span></code> is given) or
it has root, parent, children and the flag <code class="docutils literal"><span class="pre">is_in_affinoid</span></code> as given
by the extra parameters.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi0</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">gauss_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">xi1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi3</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi4</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">U1</span> <span class="o">=</span> <span class="n">AffinoidTree</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U1</span> <span class="o">=</span> <span class="n">U1</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">xi0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi1</span><span class="p">,</span> <span class="n">xi3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">U2</span> <span class="o">=</span> <span class="n">AffinoidTree</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U2</span> <span class="o">=</span> <span class="n">U2</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">xi2</span><span class="p">],</span> <span class="p">[</span><span class="n">xi4</span><span class="p">])</span>

<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">U1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">U2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span>
<span class="go">Affinoid tree with 6 vertices</span>
</pre></div>
</div>
<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.add_point">
<code class="descname">add_point</code><span class="sig-paren">(</span><em>xi</em>, <em>is_in_affinoid</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.add_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the affinoid tree spanned by self and the point xi.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi</span></code> &#8211; a point on the berkovich tree</li>
<li><code class="docutils literal"><span class="pre">is_in_affinoid</span></code> &#8211; a boolean</li>
</ul>
<p>OUTPUT:</p>
<p>(<span class="math">\(T_1\)</span>, <span class="math">\(T_2\)</span>), where</p>
<ul class="simple">
<li><span class="math">\(T_1\)</span> is the tree obtained from <span class="math">\(T_0=\)</span> <code class="docutils literal"><span class="pre">self</span></code> after inserting <code class="docutils literal"><span class="pre">xi</span></code>
as a vertex.</li>
<li><span class="math">\(T_2\)</span> is the subtree of <span class="math">\(T_1\)</span> with root <code class="docutils literal"><span class="pre">xi</span></code></li>
</ul>
<p>It is assumed that if <span class="math">\(T_0\)</span> has a parent, then the root of <span class="math">\(T_0\)</span> is less
than <span class="math">\(\xi\)</span>. As a result, the parent of <span class="math">\(T_1\)</span> will be the original parent
of <span class="math">\(T_0\)</span>.</p>
<p>Note that this command may change the tree <span class="math">\(T_0\)</span>!  For instance, <span class="math">\(\xi\)</span> may
become the root of <span class="math">\(T_1\)</span> and then <span class="math">\(T_0\)</span> has <span class="math">\(T_1\)</span> as new parent.</p>
<p>Also, the new vertex (the root of <span class="math">\(T_1\)</span>) is marked with the flag
<code class="docutils literal"><span class="pre">is_in_affinoid</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.compute_connected_components">
<code class="descname">compute_connected_components</code><span class="sig-paren">(</span><em>comp_list</em>, <em>new_comp</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.compute_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the connected components of the represented affinoid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">comp_list</span></code> &#8211; a list (of lists of lists)</li>
<li><code class="docutils literal"><span class="pre">new_comp</span></code> &#8211; a list (of lists)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>all connected components whose root is a vertex of T=``self`` are
added to the list <code class="docutils literal"><span class="pre">comp_list</span></code>.</li>
<li>all boundary_lists which belong to T and to the connected component
which contains the root of T  are added to <code class="docutils literal"><span class="pre">new_comp</span></code> (in particular,
if the root of T does not lie in the affinoid then the list is unchanged).</li>
</ul>
<p>Here a <em>boundary list</em> is a list of type-V-points which represent holes
of the affinoid with a common boundary point. A <em>connected component</em>
is a list of boundary lists.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi0</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">gauss_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">xi1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xi3</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">point_from_discoid</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in_unit_disk</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">AffinoidTree</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">xi0</span><span class="p">,</span> <span class="n">xi2</span><span class="p">],</span> <span class="p">[</span><span class="n">xi1</span><span class="p">,</span> <span class="n">xi3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">U</span>
<span class="go">Affinoid tree with 4 vertices</span>

<span class="gp">sage: </span><span class="n">component_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">compute_connected_components</span><span class="p">(</span><span class="n">component_list</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="n">component_list</span>
<span class="go">[[[Point of type V given by residue class v(1/(x + 1)) &gt; -2]],</span>
<span class="go">[[Point of type V given by residue class v(x + 1) &gt; 0,</span>
<span class="go">Point of type V given by residue class v(1/x) &gt; 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>parent=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self, force <code class="docutils literal"><span class="pre">parent</span></code> as parent.</p>
<p>WARNING! something is wrong with this function!!</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>T1</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the tree representing the intersection of two affinoids.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">T1</span></code> &#8211; an affinoid tree</li>
</ul>
<p>OUTPUT:</p>
<p>An affinoid tree which represents the intersection of the affinoids
represented by T0 = <code class="docutils literal"><span class="pre">self</span></code> and T1.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.is_in_affinoid">
<code class="descname">is_in_affinoid</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.is_in_affinoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if xi lies in the affinoid  U represented by self.</p>
<p>To test this, we compute the image of xi under the retraction map
onto the total space of T=self and check whether it lies on a vertex
in U or on an edge connecting two vertices in U.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a graphical representation of self.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simplified tree representing the same affinoid.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.AffinoidTree.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>T1</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.AffinoidTree.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the tree representing the union of two affinoids.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">T1</span></code> &#8211; an affinoid tree</li>
</ul>
<p>OUTPUT:</p>
<p>An affinoid tree which represents the union of the affinoids represented
by T0 = <code class="docutils literal"><span class="pre">self</span></code> and T1.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.affinoid_domain.ClosedUnitDisk">
<em class="property">class </em><code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">ClosedUnitDisk</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.ClosedUnitDisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closed unit disk.</p>
<p>The <strong>closed unit disk</strong> is the affinoid on the Berkovich line with
function field <span class="math">\(F=K(x)\)</span> defined by the inequality</p>
<div class="math">
\[v(x) &gt;= 0.\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code> &#8211; a Berkovich line</li>
</ul>
<p>OUTPUT: the closed unit disk inside <code class="docutils literal"><span class="pre">X</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ClosedUnitDisk</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">Affinoid with 1 components:</span>
<span class="go">Elementary affinoid defined by</span>
<span class="go">v(x) &gt;= 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.affinoid_domain.ElementaryAffinoidOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">ElementaryAffinoidOnBerkovichLine</code><span class="sig-paren">(</span><em>boundary_list</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.ElementaryAffinoidOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elementary affinoid corresponding to a boundary list.</p>
<p>An &#8220;elementary affinoid&#8221; is a a connected affinoid subdomain of a Berkovich
line <span class="math">\(X\)</span> which is the complement of a finite set of disjoint residue classes
in <span class="math">\(X\)</span>. It can be represented by a &#8220;boundary list&#8221; as follows.</p>
<p>A &#8220;boundary list&#8221; is a list of lists, whose entries at the lowest level are
type-V-points on <span class="math">\(X\)</span>. Each sublist contains the type-V-points with a common
boundary point. The elementary affinoid corresponding to a &#8220;boundary list&#8221; is
the complement of the residue classes corresponding to the type-V-points
contained in the sublists. The set of boundary points of the type-V-points is
exactly the Shilov boundary of the affinoid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">boundary_list</span></code> &#8211; a list of lists containing type-V-points.</li>
</ul>
<p>OUTPUT:</p>
<p>The elementare affinoid corresponding to <code class="docutils literal"><span class="pre">comp_list</span></code>.</p>
<p>TO DO:</p>
<ul class="simple">
<li>we need a function which produces an (algebraic) type-I-point inside the
affinoid.</li>
</ul>
<dl class="method">
<dt id="mclf.berkovich.affinoid_domain.ElementaryAffinoidOnBerkovichLine.inequalities">
<code class="descname">inequalities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.ElementaryAffinoidOnBerkovichLine.inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inequalities defining the elementary affinoid, as a string.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.affinoid_domain.RationalDomainOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">RationalDomainOnBerkovichLine</code><span class="sig-paren">(</span><em>X</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.RationalDomainOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rational domain on <code class="docutils literal"><span class="pre">X</span></code> defined by <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code> &#8211; a Berkovich line</li>
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a nonconstant rational function on <span class="math">\(X\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>the affinoid domain on <span class="math">\(X\)</span> defined by the inequality</p>
<div class="math">
\[\]</div>
<p>v(f) &gt;= 0.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span>
<span class="gp">sage: </span><span class="n">vK</span> <span class="o">=</span> <span class="n">pAdicValuation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">BerkovichLine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">vK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">RationalDomainOnBerkovichLine</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Affinoid with 2 components:</span>
<span class="go">Elementary affinoid defined by</span>
<span class="go">v(x^2 + 2) &gt;= 3/2</span>
<span class="go">Elementary affinoid defined by</span>
<span class="go">v(x + 1) &gt;= 1</span>
</pre></div>
</div>
<p>TO DO:</p>
<p>I think this can be drastically improved, by using the following ideas:</p>
<ul class="simple">
<li>it should not be necessary to first build a tree with all zeroes and poles
of <span class="math">\(f\)</span> as leaves. At any stage of bulding the tree one looks at a discoid
<span class="math">\(D\)</span>. If <span class="math">\(f\)</span> has nonnegative valuation on the boundary of <span class="math">\(D\)</span> and
no poles inside <span class="math">\(D\)</span> (or nonpositive valuation on the boundary and no
zero inside) then we can stop at <span class="math">\(D\)</span>.</li>
<li>Instead of working with a (possible huge) rational function <span class="math">\(f\)</span> we should
work with a &#8220;factorization&#8221;, i.e. a list of pairs <span class="math">\((f_i, e_i)\)</span> where
<span class="math">\(f_i\)</span> is an irreducible polynomial or a constant and <span class="math">\(e_i\)</span> an integer
(rationals are also fine).
At any stage of building the tree, we only retain the sublist
of pairs <span class="math">\((f_i,e_i)\)</span> which are &#8220;active&#8221;; for the &#8220;inactive&#8221; pairs we
only need to know their valuations - which is constant on the subtree!</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.affinoid_domain.all_polynomials">
<code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">all_polynomials</code><span class="sig-paren">(</span><em>F</em>, <em>x</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.all_polynomials" title="Permalink to this definition">¶</a></dt>
<dd><p>List all polynomials in x over F of degree d.</p>
<p>INPUT:</p>
<ul class="simple">
<li>F: a finite field F</li>
<li>x: generator of a polynomial ring over F</li>
</ul>
<p>OUTPUT:</p>
<p>an iterator which list all elements of F[x] of degree d.</p>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.affinoid_domain.irreducible_polynomial_prime_to">
<code class="descclassname">mclf.berkovich.affinoid_domain.</code><code class="descname">irreducible_polynomial_prime_to</code><span class="sig-paren">(</span><em>f</em>, <em>min_deg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.affinoid_domain.irreducible_polynomial_prime_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an irreducibel polynomial prime to f.</p>
<p>INPUT:</p>
<ul class="simple">
<li>f: an univariat polynomial over a finite field</li>
<li>min_deg: a positive integer (default = 1)</li>
</ul>
<p>OUTPUT:</p>
<p>an irreducible polynomial prime to f, of degree &gt;=min_deg</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="type_V_points.html"
                        title="previous chapter">Points of type V on the Berkovich line.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="semistable_reduction.html"
                        title="next chapter">Semistable reduction of curves</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/affinoid_domain.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="semistable_reduction.html" title="Semistable reduction of curves"
             >next</a> |</li>
        <li class="right" >
          <a href="type_V_points.html" title="Points of type V on the Berkovich line."
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MCLF  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="berkovich.html" >The Berkovich line</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, Stefan Wewers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>