<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Berkovich projective line over a discretely valued field. &mdash; MCLF  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="MCLF  documentation" href="index.html" />
    <link rel="up" title="The Berkovich line" href="berkovich.html" />
    <link rel="next" title="Finite subtrees of the Berkovich line" href="berkovich_trees.html" />
    <link rel="prev" title="The Berkovich line" href="berkovich.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="berkovich_trees.html" title="Finite subtrees of the Berkovich line"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="berkovich.html" title="The Berkovich line"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MCLF  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="berkovich.html" accesskey="U">The Berkovich line</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-mclf.berkovich.berkovich_line"></span><div class="section" id="the-berkovich-projective-line-over-a-discretely-valued-field">
<h1>The Berkovich projective line over a discretely valued field.<a class="headerlink" href="#the-berkovich-projective-line-over-a-discretely-valued-field" title="Permalink to this headline">¶</a></h1>
<p>Let <span class="math">\(K\)</span> be a field and <span class="math">\(v_K\)</span> a discrete valuation on <span class="math">\(K\)</span>. Let <span class="math">\(F=K(x)\)</span>
be a rational function field over <span class="math">\(K\)</span>. We consider <span class="math">\(F\)</span> as the function
field of the projective line <span class="math">\(X:=\mathbb{P}_K^1\)</span> over <span class="math">\(K\)</span>. Let <span class="math">\(X^{an}\)</span> denote the
<span class="math">\((K,v_K)\)</span>-analytic space associated to <span class="math">\(X\)</span>. Then a point <span class="math">\(\xi\)</span> on
<span class="math">\(X^{an}\)</span> may be identified with a (real valued) pseudo-valuation
<span class="math">\(v_\xi\)</span> on <span class="math">\(F\)</span> extending <span class="math">\(v_K\)</span>.</p>
<p>Note that we do not assume <span class="math">\(K\)</span> to be complete with respect to <span class="math">\(v_K\)</span>. Hence we
can work with &#8216;exact&#8217; fields, e.g. number fields.</p>
<p>There are only two kind of &#8216;points&#8217; which are relevant for us and can be handled
using the mac_lane infrastructure:</p>
<blockquote>
<div><ul class="simple">
<li>Type I, algebraic: these are the points that come from a closed point
on the (algebraic) projective line over the completed base field.</li>
<li>Type II: these are the points which correspond to discrete valuations
on the function field whose residue field is a function field over the
residue base field</li>
</ul>
</div></blockquote>
<p>For both these kind of points, the corresponding pseudovaluation on <span class="math">\(F\)</span> are
directly realizable inside the <code class="docutils literal"><span class="pre">mac_lane</span></code> infrastructure.</p>
<p>If <span class="math">\(v_\xi(x)\geq 0\)</span> we say that <span class="math">\(\xi\)</span> lies <em>in the unit disk</em>. Then the
restriction of <span class="math">\(v_\xi\)</span> to <span class="math">\(K[x]\)</span> is a discrete pseudo-valuation which can be
realized either as an inductive valuation, or as a limit valuation.</p>
<p>If <span class="math">\(\xi\)</span> does not lie in the unit disk, then we use instead the restriction
of <span class="math">\(v_\xi\)</span> to the polynomial ring <span class="math">\(K[x^{-1}]\)</span> (internally, we use the ring
<span class="math">\(K[x]\)</span>, though).</p>
<p>By a result of Berkovich, the topological space <span class="math">\(X^{an}\)</span> is a <em>simply connected
quasi-polyhedron</em>. Among other things this means that for any two points
<span class="math">\(\xi_1,\xi2\in X^{an}\)</span> there exists a unique closed subset</p>
<div class="math">
\[[\xi_1,\xi_2]\subset X^{an}\]</div>
<p>which is homeomorphic to the unit interval <span class="math">\([0,1]\subset\mathbb{R}\)</span> in such a way that
<span class="math">\(\xi_1,\xi_2\)</span> are mapped to the endpoints <span class="math">\(0,1\)</span>.</p>
<p>Let <span class="math">\(\xi^g\in X^{an}\)</span> denote the <em>Gauss point</em>, corresponding to the Gauss
valuation on <span class="math">\(F=K(x)\)</span> with respect to the parameter <span class="math">\(x\)</span>. Then <span class="math">\(X^{an}\)</span> has a
unique partial ordering determined by the following two conditions:</p>
<ul class="simple">
<li><span class="math">\(\xi^g\)</span> is the smallest element</li>
<li>we have <span class="math">\(\xi_1&lt;\xi_2\)</span> if and only if <span class="math">\(\xi_2\)</span> lies in a connected component
of <span class="math">\(X^{an}-\{\xi_1\}\)</span> which does not contain <span class="math">\(\xi^g\)</span>.</li>
</ul>
<p>A point <span class="math">\(\xi\)</span> of type II has a <em>discoid representation</em> as follows. If
<span class="math">\(\xi=\xi^g\)</span> then <span class="math">\(D_\xi\)</span> is defined as the closed unit disk. Otherwise,
<span class="math">\(D_\xi\)</span> is defined of the set of all points <span class="math">\(\xi_1\in X^{an}\)</span> such that
<span class="math">\(\xi\leq\xi_1\)</span>. Then <span class="math">\(D_\xi\)</span> is of the form</p>
<div class="math">
\[D_\xi = \{ \xi_1 \mid v_{\xi_1}(f) \geq s\},\]</div>
<p>where <span class="math">\(f\)</span> is a polynomial in <span class="math">\(x\)</span> or in <span class="math">\(x^{-1}\)</span>, irreducible over
<span class="math">\(\hat{\bar{K}}\)</span> and <span class="math">\(s\)</span> is a nonnegativ rational number.
The pair <span class="math">\((f,s)\)</span> determines <span class="math">\(\xi\)</span>, but this representation is not unique.</p>
<p>Note that we can simply extend the discoid representation to points of type I
by allowing <span class="math">\(s\)</span> to take the value <span class="math">\(\infty\)</span>.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Stefan Wewers (2017-02-10): initial version</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Lots</span> <span class="ow">and</span> <span class="n">lots</span> <span class="n">of</span> <span class="n">examples</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>TO DO:</p>
<ul class="simple">
<li>allow &#8220;virtual functions&#8221; for the evaluations of valuations (and derivations).
&#8220;Virtual functions&#8221; are products of rational functions with possible rational
exponents.</li>
<li>use more cached functions; this may improve speed</li>
<li>more systematic (and explicitly defined) relation between points and their
discoid representation</li>
<li>more doctests!</li>
</ul>
<dl class="class">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">BerkovichLine</code><span class="sig-paren">(</span><em>F</em>, <em>vK</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>The class of a Berkovich projective line over a discretely valued field.</p>
<p>Let <span class="math">\(K\)</span> be a field and <span class="math">\(v_K\)</span> a discrete valuation on <span class="math">\(K\)</span>. Let <span class="math">\(F=K(x)\)</span>
be a rational function field over <span class="math">\(K\)</span>. We consider <span class="math">\(F\)</span> a the function
field of the projective line <span class="math">\(X\)</span> over <span class="math">\(K\)</span>. Let <span class="math">\(X^{an}\)</span> denote the
<span class="math">\((K,v_K)\)</span>-analytic space associated to <span class="math">\(X\)</span>. Then a point <span class="math">\(\xi\)</span> on <span class="math">\(X^{an}\)</span>
may be identified with a (real valued) pseudo-valuation <span class="math">\(v_\xi\)</span> on <span class="math">\(F\)</span>
extending <span class="math">\(v_K\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">F</span></code> &#8211; a rational function field over a base field K</li>
<li><code class="docutils literal"><span class="pre">vK</span></code> &#8211; a discrete valuation on the base field K</li>
</ul>
<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.divisor">
<code class="descname">divisor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.divisor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the divisor of a rational function <span class="math">\(f\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(f\)</span> &#8211; a nonzero element of the function field of self</li>
</ul>
<p>OUTPUT:</p>
<p>the divisor of <span class="math">\(f\)</span>, as a list of pairs <span class="math">\((\xi, m)\)</span>, where <span class="math">\(\xi\)</span> is
a point of type I and m is the multiplicity of <span class="math">\(\xi\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.find_zero">
<code class="descname">find_zero</code><span class="sig-paren">(</span><em>xi1</em>, <em>xi2</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.find_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point between <code class="docutils literal"><span class="pre">xi1</span></code> and <code class="docutils literal"><span class="pre">xi2</span></code> where <code class="docutils literal"><span class="pre">f</span></code> has valuation <span class="math">\(0\)</span>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">xi1</span></code>, <code class="docutils literal"><span class="pre">xi2</span></code> &#8211; points on the Berkovich line such that <span class="math">\(\xi_1&lt;\xi2\)</span></p>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">f</span></code> &#8211; a nonconstant rational function; it is assumed that the signs</dt>
<dd><p class="first last">of the valuations of f at <span class="math">\(\xi1\)</span> and <span class="math">\(\xi2\)</span> are different</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>The smallest point between <span class="math">\(\xi1\)</span> and <span class="math">\(\xi2\)</span> where the valuation of <span class="math">\(f\)</span>
is zero.</p>
<p>NOTE:</p>
<p>We are assuming for the moment that the function</p>
<div class="math">
\[v \mapsto v(f)\]</div>
<p>is affine (i.e. has no kinks) on the interval <span class="math">\([\xi_1,\xi_2]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.gauss_point">
<code class="descname">gauss_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.gauss_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Gauss point of self.</p>
<p>The Gauss point is the type-II-point corresponding to the Gauss
valuation on <span class="math">\(K[x]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.infty">
<code class="descname">infty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.infty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point <span class="math">\(\infty\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.make_polynomial">
<code class="descname">make_polynomial</code><span class="sig-paren">(</span><em>f</em>, <em>in_unit_disk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.make_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn <code class="docutils literal"><span class="pre">f</span></code> into a polynomial.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; an element of <span class="math">\(F=K(x)\)</span> or of <span class="math">\(K[x]\)</span></li>
<li><code class="docutils literal"><span class="pre">in_unit_disk</span></code> &#8211; boolean</li>
</ul>
<p>OUTPUT:</p>
<p>Either <span class="math">\(f\)</span> of <span class="math">\(f(1/x)\)</span>, considered as a polynomial in <span class="math">\(K[x]\)</span>,
and depending on whether <code class="docutils literal"><span class="pre">in_unit_disk</span></code> is true or false.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.point_from_discoid">
<code class="descname">point_from_discoid</code><span class="sig-paren">(</span><em>phi</em>, <em>s</em>, <em>in_unit_disk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.point_from_discoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point on <code class="docutils literal"><span class="pre">self</span></code> determined by a discoid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">phi</span></code> &#8211; a monic and integral polynomial in <span class="math">\(K[x]\)</span></li>
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; a nonnegative rational number, or <span class="math">\(\infty\)</span></li>
<li><code class="docutils literal"><span class="pre">in_unit_disk</span></code> &#8211; a boolean (default: True)</li>
</ul>
<p>OUTPUT:</p>
<p>a point <span class="math">\(\xi\)</span> on the Berkovich line <code class="docutils literal"><span class="pre">self</span></code> which is the unique
boundary point of the discoid <span class="math">\(D\)</span> determined as follows: if
<code class="docutils literal"><span class="pre">in_unit_disk</span></code> is true then <span class="math">\(D\)</span> is the set of valuations <span class="math">\(v\)</span> on
<span class="math">\(K[x]\)</span> such that <span class="math">\(v(\phi)\geq s\)</span>. Otherwise, it is the image of this
point under the automorphism <span class="math">\(x\to 1/x\)</span>.</p>
<p>If <span class="math">\(D\)</span> defined above is not irreducible (and hence not a discoid) then
an error is raised.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.point_from_polynomial_pseudovaluation">
<code class="descname">point_from_polynomial_pseudovaluation</code><span class="sig-paren">(</span><em>v</em>, <em>in_unit_disk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.point_from_polynomial_pseudovaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point corresponding to a pseudo-valuation on a poylnomial ring.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">v</span></code> &#8211; a discrete pseudo-valuation on the polynomial ring <span class="math">\(K[x]\)</span>,</dt>
<dd><p class="first last">extending the base valuation <span class="math">\(v_K\)</span></p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">in_unit_disk</span></code> (default=True) &#8211; boolean</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>The point on the unit disk corresponding to <code class="docutils literal"><span class="pre">v</span></code> (if <code class="docutils literal"><span class="pre">in_unit_disk</span></code>
is true), or the point on the inverse unit disk corresponding to <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.point_from_pseudovaluation">
<code class="descname">point_from_pseudovaluation</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.point_from_pseudovaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point on the Berkovich line corresponding to the pseudovaluation <code class="docutils literal"><span class="pre">v</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">v</span></code> &#8211; a discrete pseudovaluation on the function field of <code class="docutils literal"><span class="pre">self</span></code>,</dt>
<dd><p class="first last">extending the base valuation <span class="math">\(v_K\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>The point <span class="math">\(\xi\)</span> on the Berkovich line <span class="math">\(X\)</span> =``self`` corresponding to
the pseudo valuation <code class="docutils literal"><span class="pre">v</span></code> on the function field of <span class="math">\(X\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.points_from_inequality">
<code class="descname">points_from_inequality</code><span class="sig-paren">(</span><em>f</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.points_from_inequality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the boundary points of the affinoid given an inequality.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a monic and integral polynomial in <span class="math">\(x\)</span> or in <span class="math">\(1/x\)</span></li>
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; a nonnegative rational number, or <span class="math">\(\infty\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>a list of points which are the boundary points of the affinoid given
by the inequality <span class="math">\(v(f) \geq s\)</span>. Note that the affinoid is a union
of finitely many discoids (or of finitely many algebraic points if
<span class="math">\(s=\infty\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the moment we have to assume that if <span class="math">\(f=g(1/x)\)</span>, then all the
roots of <span class="math">\(g\)</span> have strictly positive valuations.</p>
</div>
<p>EXAMPLES:</p>
<blockquote>
<div>sage: from mclf import *
sage: F.&lt;x&gt; = FunctionField(QQ)
sage: v_2 = pAdicValuation(QQ, 2)
sage: X = BerkovichLine(F, v_2)
sage: f = x^2 + 2
sage: X.points_from_inequality(f, 3)
[Point of type II on Berkovich line, corresponding to v(x^2 + 2) &gt;= 3]
sage: from mclf.padic_extensions.weak_padic_galois_extensions import WeakPadicGaloisExtension
sage: LL = WeakPadicGaloisExtension(v_2, f.numerator())
sage: L = LL.field()
sage: vL = LL.valuation()
sage: FL.&lt;x&gt; = FunctionField(L)
sage: XL = BerkovichLine(FL, vL)
sage: f = FL(f)
sage: XL.points_from_inequality(f, 3)
[Point of type II on Berkovich line, corresponding to v(x + pi2) &gt;= 3/2]
sage: XL.points_from_inequality(f, 4)
[Point of type II on Berkovich line, corresponding to v(x + pi2) &gt;= 5/2,
Point of type II on Berkovich line, corresponding to v(x + 7*pi2) &gt;= 5/2]</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.BerkovichLine.polynomial_divisor">
<code class="descname">polynomial_divisor</code><span class="sig-paren">(</span><em>f</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.BerkovichLine.polynomial_divisor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the divisor of zeroes of a squarefree polynomial.</p>
<p>INPUT:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">f</span></code> &#8211; a squarefree polynomial in the generator of the function</dt>
<dd><p class="first last">field of self</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">m</span></code> &#8211; an integer</p>
</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>The divisor of <span class="math">\(f\)</span>, multiplied with <span class="math">\(m\)</span>.</p>
<p>NOTE:</p>
<p>At the moment, we must require that the Newton polygon of <span class="math">\(f\)</span> has
either only nonpositive or only positive slopes. So the zeroes of
<span class="math">\(f\)</span> lie all inside the closed unit disk, or all outside.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">PointOnBerkovichLine</code><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>A point on a Berkovich projective line.</p>
<p>We only allow two different types of points:</p>
<ul>
<li><dl class="first docutils">
<dt>Type I, algebraic: these are the points that come from a closed point</dt>
<dd><p class="first last">on the (algebraic) projective line over the completed base field.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Type II: these are the points which correspond to discrete valuations</dt>
<dd><p class="first last">on the function field whose residue field is a function field over the
residue base field</p>
</dd>
</dl>
</li>
</ul>
<p>In particular, the Gauss valuation on <span class="math">\(F=K(x)\)</span> with respect to the parameter
<span class="math">\(x\)</span> corresponds t a point <span class="math">\(\xi^g\)</span> of type II on <span class="math">\(X^{an}\)</span> which we call
the <em>Gauss point</em>.</p>
<p>The set <span class="math">\(X^{an}\)</span> has a canonical partial ordering in which the Gauss point
is the smallest elements. All point of type I are maximal elements.</p>
<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.base_field">
<code class="descname">base_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.base_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the base field of this Berkovich line.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.base_valuation">
<code class="descname">base_valuation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.base_valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valuation on the base field of this Berkovich line.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.berkovich_line">
<code class="descname">berkovich_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.berkovich_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Berkovich line of which this point lies.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.function_field">
<code class="descname">function_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.function_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function field of this Berkovich line.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.is_strictly_less">
<code class="descname">is_strictly_less</code><span class="sig-paren">(</span><em>xi1</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.is_strictly_less" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal"><span class="pre">self</span></code> is strictly smaller than <code class="docutils literal"><span class="pre">xi1</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.PointOnBerkovichLine.make_polynomial">
<code class="descname">make_polynomial</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.PointOnBerkovichLine.make_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polynomial corresponding to <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; an element of <span class="math">\(F=K(x)\)</span></li>
</ul>
<p>OUTPUT:</p>
<dl class="docutils">
<dt>If <code class="docutils literal"><span class="pre">f</span></code> is an element of the function field <span class="math">\(F=K(x)\)</span> the we return</dt>
<dd><ul class="first last simple">
<li>f as an element of <span class="math">\(K[x]\)</span> if possible and <code class="docutils literal"><span class="pre">self</span></code> lies in the unit disk</li>
<li>f(1/x) as an element of <span class="math">\(K[x]\)</span> if possible and <a href="#id1"><span class="problematic" id="id2">``</span></a>lies outside the unit disk</li>
</ul>
</dd>
</dl>
<p>Otherwise an error is raised.</p>
<p>This function is useful to converting elements of the function field to
elements of the domain of the MacLane valuation underlying <code class="docutils literal"><span class="pre">self</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">TypeIIPointOnBerkovichLine</code><span class="sig-paren">(</span><em>X</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>A point of type II on a Berkovich line.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code> &#8211; a Berkovich line over a valued field K</li>
<li><code class="docutils literal"><span class="pre">v</span></code> &#8211; a discrete valuation on the function field of X extending the base valuation</li>
</ul>
<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.approximation">
<code class="descname">approximation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.approximation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an approximation of <code class="docutils literal"><span class="pre">self</span></code>.
For a point of type II, <code class="docutils literal"><span class="pre">self</span></code> is already an approximation of itself.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.discoid">
<code class="descname">discoid</code><span class="sig-paren">(</span><em>certified_point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.discoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a representation of the discoid of which <code class="docutils literal"><span class="pre">self</span></code> is the
unique boundary point.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">certified_point</span></code> (default=None) &#8211; this argument is not used</dt>
<dd><p class="first last">for type-II-points</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <span class="math">\((f, s)\)</span>, where <span class="math">\(f\)</span> is a polynomial in the generator <span class="math">\(x\)</span> of the
function field of <span class="math">\(X\)</span>, or a polynomial in <span class="math">\(1/x\)</span>, and where <span class="math">\(s\)</span> is a
nonnegative rational number. This data represents a discoid <span class="math">\(D\)</span> via
the condition <span class="math">\(v_\xi(f)\geq s\)</span>.</p>
<p>Then <code class="docutils literal"><span class="pre">self</span></code> is the unique boundary
point of <span class="math">\(D\)</span>, and if, moreover, <code class="docutils literal"><span class="pre">self</span></code> is not the Gauss point then
<span class="math">\(D\)</span> contains precisely the points <span class="math">\(\xi\)</span> which are greater or equal to
<code class="docutils literal"><span class="pre">self</span></code>. If <code class="docutils literal"><span class="pre">self</span></code> is the Gauss point then <span class="math">\(D\)</span> is the standard
closed unit disk, <span class="math">\(f=x\)</span> and <span class="math">\(s=0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.improved_approximation">
<code class="descname">improved_approximation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.improved_approximation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an improved approximation of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is meaningless for type-II-points, so self is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.infimum">
<code class="descname">infimum</code><span class="sig-paren">(</span><em>xi2</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.infimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the infimum of self and <code class="docutils literal"><span class="pre">xi2</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi2</span></code> &#8211; a point of type I or II on the Berkovich line</li>
</ul>
<p>OUTPUT:</p>
<p>The infimum of self and <span class="math">\(\xi_2\)</span> (w.r.t. to the natural partial ordering).
Unless <span class="math">\(\xi_2=\infty\)</span> or self is equal to <span class="math">\(\xi_2\)</span>,
the result is a point of type II.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_equal">
<code class="descname">is_equal</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if self is equal to <code class="docutils literal"><span class="pre">xi</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_gauss_point">
<code class="descname">is_gauss_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_gauss_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is the Gauss point.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_in_unit_disk">
<code class="descname">is_in_unit_disk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_in_unit_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>True is self is contained in the unit disk.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_inductive">
<code class="descname">is_inductive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_inductive" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <code class="docutils literal"><span class="pre">self</span></code> corresponds to an inductive pseud-valuation.
This is always true for points of type II.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_leq">
<code class="descname">is_leq</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_leq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if self is less or equal to <code class="docutils literal"><span class="pre">xi</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi</span></code> &#8211; a point of type I or II</li>
</ul>
<p>OUTPUT:</p>
<p>True if self is less or equal to <code class="docutils literal"><span class="pre">xi</span></code> (w.r.t. the natural
partial order on <span class="math">\(X\)</span>)</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_limit_point">
<code class="descname">is_limit_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_limit_point" title="Permalink to this definition">¶</a></dt>
<dd><p>True is <code class="docutils literal"><span class="pre">self</span></code> corresponds to a limit valuation.
This is never true for points of type II.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.point_in_between">
<code class="descname">point_in_between</code><span class="sig-paren">(</span><em>xi1</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.point_in_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a point in between <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">xi1</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi1</span></code> &#8211; a point which is strictly smaller than <code class="docutils literal"><span class="pre">self</span></code></li>
</ul>
<p>OUTPUT: a point which lies strictly between <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">xi1</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.pseudovaluation">
<code class="descname">pseudovaluation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.pseudovaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pseudovaluation corresponding to this point.</p>
<p>OUTPUT:</p>
<p>Since <code class="docutils literal"><span class="pre">self</span></code> is a point of type II, the output is a discrete
valuation on the function field of the underlying Berkovich line.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring">
<code class="descname">pseudovaluation_on_polynomial_ring</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pseudo-valuation on the polynomial ring &#8216;K[y]&#8217;
corresponding to <code class="docutils literal"><span class="pre">self</span></code>, where <span class="math">\(y\)</span> is either <span class="math">\(x\)</span> or <span class="math">\(1/x\)</span> depending
on whether self lies in the standard closed unit disk or not.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the type of self.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.v">
<code class="descname">v</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate element of the function field on the valuation corresponding to self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; an element of the function field of the underlying projective line</li>
</ul>
<p>OUTPUT:</p>
<p>the value <span class="math">\(v(f)\)</span>, where <span class="math">\(v\)</span> is the valuation corresponding to self</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.valuation">
<code class="descname">valuation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valuation corresponding to this point.</p>
<p>OUTPUT:</p>
<p>The discrete valuation on the function field of the underlying Berkovich
line corresponding to this point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine">
<em class="property">class </em><code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">TypeIPointOnBerkovichLine</code><span class="sig-paren">(</span><em>X</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine" title="Permalink to this definition">¶</a></dt>
<dd><p>An algebraic point of type I.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(X\)</span> &#8211; a Berkovich projective line over a valued field <span class="math">\(K\)</span></li>
<li><span class="math">\(v\)</span> &#8211; an infinite pseudo-valuation on the function field of <span class="math">\(X\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>The point on <span class="math">\(X\)</span> corresponding to <span class="math">\(v\)</span>.</p>
<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.approximation">
<code class="descname">approximation</code><span class="sig-paren">(</span><em>certified_point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.approximation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an approximation of this point.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">certified</span> <span class="pre">point</span></code> (default=None) &#8211; a point on the Berkovich line</li>
</ul>
<p>OUTPUT:</p>
<p>A a point which is inductive and approximates <code class="docutils literal"><span class="pre">self</span></code>, in such a way that
we can distinguish <code class="docutils literal"><span class="pre">self</span></code> from <code class="docutils literal"><span class="pre">certified</span> <span class="pre">point</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">self</span></code> is an inductive point, then <code class="docutils literal"><span class="pre">self</span></code> is returned. Otherwise,
<code class="docutils literal"><span class="pre">self</span></code> is a limit point, and the output is a point of type II greater
or equal to <code class="docutils literal"><span class="pre">self</span></code> (i.e. corresponding to a discoid containing <code class="docutils literal"><span class="pre">self</span></code>).
If <code class="docutils literal"><span class="pre">certified_point</span></code> is not None and distinct from <code class="docutils literal"><span class="pre">self</span></code>, then
the output is not greater or equal to <code class="docutils literal"><span class="pre">certified_point</span></code>.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">We should also make sure that the approximation has the same degree
as the point itself. If the point is generated as part of the support of
a principal divisor, then this should be ok, because of the default
&#8220;require_final_EF=True&#8221; in &#8220;vK.approximants(f)&#8221;.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.discoid">
<code class="descname">discoid</code><span class="sig-paren">(</span><em>certified_point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.discoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a representation of a discoid approximating <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">certified_point</span></code> (default=None) &#8211; a point of type II</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <span class="math">\((f, s)\)</span>, where <span class="math">\(f\)</span> is a polynomial in the generator <span class="math">\(x\)</span> of the
function field of <span class="math">\(X\)</span>, or <span class="math">\(f=1/x\)</span>, and where <span class="math">\(s\)</span> is a nonrational number,
or is equal to <span class="math">\(\infty\)</span>.
This data represents a (possibly degenerate) discoid <span class="math">\(D\)</span> via the condition
<span class="math">\(v_\xi(f)\geq s\)</span>.</p>
<p><span class="math">\(D\)</span> as above is either the degenerate discoid with <span class="math">\(s=\infty\)</span> which has
<code class="docutils literal"><span class="pre">self</span></code> as the unique point, or <span class="math">\(D\)</span> is an approximation of <code class="docutils literal"><span class="pre">self</span></code>
(this simply means that <code class="docutils literal"><span class="pre">self</span></code> is contained in <span class="math">\(D\)</span>). If
<code class="docutils literal"><span class="pre">certified_point</span></code> is given then it is guaranteed that it is not
contained in <span class="math">\(D\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.function_field_valuation">
<code class="descname">function_field_valuation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.function_field_valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function field valuation corresponding to this point</p>
<p>OUTPUT:</p>
<p>the discrete valuation on the function field <span class="math">\(F=K(x)\)</span> of <span class="math">\(X^{an}\)</span> which
corresponds to the image of this point on <span class="math">\(X=\mathbb{P}^1_K\)</span> (which is,
by hypothesis, a closed point).</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.improved_approximation">
<code class="descname">improved_approximation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.improved_approximation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an improved approximation of <code class="docutils literal"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.infimum">
<code class="descname">infimum</code><span class="sig-paren">(</span><em>xi2</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.infimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the infimum of self and <span class="math">\(\xi_2\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi2</span></code> &#8211; a point of type I or II on the Berkovich line</li>
</ul>
<p>OUTPUT:</p>
<p>The infimum of self and <span class="math">\(\xi_2\)</span>. Unless self or <span class="math">\(\xi_2\)</span> are equal,
this is a point of type II.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_equal">
<code class="descname">is_equal</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> is self is equal to <code class="docutils literal"><span class="pre">xi</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_gauss_point">
<code class="descname">is_gauss_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_gauss_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is the Gauss point.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_in_unit_disk">
<code class="descname">is_in_unit_disk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_in_unit_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>True is self is contained in the unit disk.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_inductive">
<code class="descname">is_inductive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_inductive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this points corresponds to an inductive valuation.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_leq">
<code class="descname">is_leq</code><span class="sig-paren">(</span><em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_leq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">self</span></code> is less or equal to <code class="docutils literal"><span class="pre">xi</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xi</span></code> &#8211; a point of type I or II</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> if self is less or equal to <code class="docutils literal"><span class="pre">xi</span></code> (w.r.t. the natural
partial order on <span class="math">\(X\)</span> for which the Gauss pont is the smallest element).
Since self is a point of type I and hence maximal, this is never true
unless <span class="math">\(xi\)</span> is equal to self.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_limit_point">
<code class="descname">is_limit_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_limit_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this point corresponds to a limit valuation.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.pseudovaluation">
<code class="descname">pseudovaluation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.pseudovaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pseudovaluation corresponding to this point.</p>
<p>OUTPUT:</p>
<p>a discrete pseudovaluation on the rational function field of the
Berkovich line of which <code class="docutils literal"><span class="pre">self</span></code> is a point.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring">
<code class="descname">pseudovaluation_on_polynomial_ring</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pseudovaluation representing <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<p>A discrete pseudovaluation on the polynomial ring <span class="math">\(K[x]\)</span> representing <code class="docutils literal"><span class="pre">self</span></code>.
It is either inductive or a limit valuation.</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the type of self</p>
</dd></dl>

<dl class="method">
<dt id="mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.v">
<code class="descname">v</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pseudo-valuation corresponding to self on <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">f</span></code> &#8211; an element of the function field <span class="math">\(K(x)\)</span></dt>
<dd><p class="first last">(or of the polynomial ring <span class="math">\(K[x]\)</span>).</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>The value <span class="math">\(v(f)\)</span>, where v is the pseudo-valuation corresponding to <code class="docutils literal"><span class="pre">self</span></code>.
If <span class="math">\(f\)</span> is in <span class="math">\(K[x]\)</span> then we take for <span class="math">\(v\)</span> the MacLane pseudo-valuation
corresponding to <code class="docutils literal"><span class="pre">self</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.berkovich_line.equality_of_pseudo_valuations">
<code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">equality_of_pseudo_valuations</code><span class="sig-paren">(</span><em>v1</em>, <em>v2</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.equality_of_pseudo_valuations" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide whether two pseudo-valuations are equal.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">v1</span></code>, <code class="docutils literal"><span class="pre">v2</span></code> &#8211; two pseudo-valuations on the same rational</dt>
<dd><p class="first last">function field <span class="math">\(F=K(x)\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>True if <code class="docutils literal"><span class="pre">v1</span></code> is equal to <code class="docutils literal"><span class="pre">v2</span></code>, False otherwise.</p>
<p>We actually assume that the restriction of <code class="docutils literal"><span class="pre">v1</span></code> and <code class="docutils literal"><span class="pre">v2</span></code> to the
constant base field are equal.</p>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.berkovich_line.mac_lane_infimum">
<code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">mac_lane_infimum</code><span class="sig-paren">(</span><em>v1</em>, <em>v2</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.mac_lane_infimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the infimum of <span class="math">\(v_1\)</span> and <span class="math">\(v_2\)</span>.</p>
<p>INPUT:</p>
<p>-<code class="docutils literal"><span class="pre">v1</span></code>, <code class="docutils literal"><span class="pre">v2</span></code> &#8211; MacLane valuations on <span class="math">\(K[x]`\)</span></p>
<p>OUTPUT:</p>
<p>on the set of all MacLane valuations on <span class="math">\(K[x]\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.berkovich_line.normalized_reduction">
<code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">normalized_reduction</code><span class="sig-paren">(</span><em>v</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.normalized_reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized reduction of f with respect to v.</p>
<p>INPUT:</p>
<ul class="simple">
<li>v &#8211; type II valuation on a rational function field F = K(x)</li>
<li>f &#8211; a strongly irreducible polynom in K[x], or 1/x</li>
</ul>
<p>OUTPUT:</p>
<p>a nonzero element fb in the residue field of v ???
Precise definition needed!</p>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.berkovich_line.valuation_from_discoid">
<code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">valuation_from_discoid</code><span class="sig-paren">(</span><em>vK</em>, <em>f</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.valuation_from_discoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inductive valuation corresponding to a discoid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vK</span></code> &#8211; a discrete valuation on a field <span class="math">\(K\)</span></li>
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a nonconstant monic integral polynomial over <span class="math">\(K\)</span></li>
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; a nonnegative rational number, or <span class="math">\(\infty\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>an inductive valuation <code class="docutils literal"><span class="pre">v</span></code> on the domain of <code class="docutils literal"><span class="pre">f</span></code>, extending <code class="docutils literal"><span class="pre">vK</span></code>,
corresponding to the discoid <span class="math">\(D\)</span> defined by <span class="math">\(w(f)\geq s\)</span>. In other words,
this means that <span class="math">\(D\)</span> defined above is irreducible (and hence a discoid),
and <span class="math">\(v\)</span> is its unique boundary point.</p>
<p>If <span class="math">\(D\)</span> is not irreducible, an error is raised.</p>
</dd></dl>

<dl class="function">
<dt id="mclf.berkovich.berkovich_line.valuations_from_inequality">
<code class="descclassname">mclf.berkovich.berkovich_line.</code><code class="descname">valuations_from_inequality</code><span class="sig-paren">(</span><em>vK</em>, <em>f</em>, <em>s</em>, <em>v0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mclf.berkovich.berkovich_line.valuations_from_inequality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of inductive valuations corresponding to the given inequlities.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vK</span></code> &#8211; a discrete valuation on a field <span class="math">\(K\)</span></li>
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a nonconstant monic integral polynomial over <span class="math">\(K\)</span></li>
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; a nonnegative rational number, or <span class="math">\(\infty\)</span></li>
<li><code class="docutils literal"><span class="pre">v0</span></code> &#8211; an inductive valuation on the parent of <code class="docutils literal"><span class="pre">f</span></code> (default: <code class="docutils literal"><span class="pre">None</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>a list of inductive valuations on the domain of <code class="docutils literal"><span class="pre">f</span></code>, extending <code class="docutils literal"><span class="pre">vK</span></code>,
corresponding to the boundary points of the irreducible components of the
affinoid defined by the condition <span class="math">\(v(f)\geq s\)</span>. Note that these components
are all discoids.</p>
<p>If <span class="math">\(v_0\)</span> is given then the output only includes the valuations greater or
equal to <span class="math">\(v_0\)</span>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="berkovich.html"
                        title="previous chapter">The Berkovich line</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="berkovich_trees.html"
                        title="next chapter">Finite subtrees of the Berkovich line</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/berkovich_line.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="berkovich_trees.html" title="Finite subtrees of the Berkovich line"
             >next</a> |</li>
        <li class="right" >
          <a href="berkovich.html" title="The Berkovich line"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MCLF  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="berkovich.html" >The Berkovich line</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, Stefan Wewers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>