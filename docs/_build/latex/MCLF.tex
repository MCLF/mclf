% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{MCLF Documentation}
\date{Aug 09, 2017}
\release{1.0}
\author{Stefan Wewers}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Berkovich curves}
\label{berkovich:berkovich-curves}\label{berkovich::doc}\label{berkovich:welcome-to-mclf-s-documentation}

\section{The Berkovich line}
\label{berkovich_line::doc}\label{berkovich_line:the-berkovich-line}\phantomsection\label{berkovich_line:module-mclf.berkovich.berkovich_line}\index{mclf.berkovich.berkovich\_line (module)}
The Berkovich projective line over a discretely valued field.

Let \$K\$ be a field and \$v\_K\$ a discrete valuation on \titleref{K}. Let \titleref{F=K(x)}
be a rational function field over \titleref{K}. We consider \titleref{F} as the function
field of the projective line \titleref{X} over \titleref{K}. Let \(X^{an}\) denote the
\titleref{(K,v\_K)}-analytic space associated to \titleref{X}. Then a point \(\xi\) on
\(X^{an}\) may be identified with a (real valued) pseudo-valuation
\(v_\xi\) on \titleref{F} extending \titleref{v\_K}.

Note that we do not assume \titleref{K} to be complete with respect to \titleref{v\_K}. Hence we
can work with `exact' fields, e.g. number fields.

There are only two kind of `points' which are relevant for us and can be handled
using the mac\_lane infrastructure:
\begin{itemize}
\item {} \begin{description}
\item[{Type I, algebraic: these are the points that come from a closed point}] \leavevmode
on the (algebraic) projective line over the completed base field.

\end{description}

\item {} \begin{description}
\item[{Type II: these are the points which correspond to discrete valuations}] \leavevmode
on the function field whose residue field is a function field over the
residue base field

\end{description}

\end{itemize}

For both these kind of points, the corresponding pseudovaluation on \titleref{F} are
directly realizable inside the \code{mac\_lane} infrastructure.

If \titleref{v\_xi(x)geq 0} we say that \titleref{xi} lies \emph{in the unit disk}. Then the
restriction of \titleref{v\_xi} to \titleref{K{[}x{]}} is a discrete pseudo-valuation which can be
realized either as an inductive valuation, or as a limit valuation.

If \titleref{xi} does not lie in the unit disk, then we use instead the restriction
of \titleref{v\_xi} to the polynomial ring \titleref{K{[}x\textasciicircum{}\{-1\}{]}} (internally, we use the ring
\titleref{K{[}x{]}}, though).

By a result of Berkovich, the topological space \titleref{X\textasciicircum{}\{an\}} is a \emph{simply connected
quasi-polyhedron}. Among other things this means that for any two points
\titleref{xi\_1,xi2in X\textasciicircum{}\{an\}} there exists a unique closed subset
\begin{equation*}
\begin{split}[\xi_1,\xi_2]\subset X^{an}\end{split}
\end{equation*}
which is homeomorphic to the unit interval \titleref{{[}0,1{]}subsetRR} in such a way that
\titleref{xi\_1,xi\_2} are mapped to the endpoints \titleref{0,1}.

Let \titleref{xi\textasciicircum{}gin X\textasciicircum{}\{an\}} denote the \emph{Gauss point}, corresponding to the Gauss
valuation on \titleref{F=K(x)} with respect to the parameter \titleref{x}. Then \titleref{X\textasciicircum{}\{an\}} has a
unique partial ordering determined by the following two conditions:
- \titleref{xi\textasciicircum{}g} is the smallest element
- we have \titleref{xi\_1\textless{}xi\_2} if and only if \titleref{xi\_2} lies in a connected component
\begin{quote}

of \titleref{X\textasciicircum{}\{an\}-\{xi\_1\}} which does not contain \titleref{xi\textasciicircum{}g}.
\end{quote}

A point \titleref{xi} of type II has a \emph{discoid representation} as follows. If
\titleref{xi=xi\textasciicircum{}g} then \titleref{D\_xi} is defined as the closed unit disk. Otherwise,
\titleref{D\_xi} is defined of the set of all points \titleref{xi\_1in X\textasciicircum{}\{an\}} such that
\titleref{xileqxi\_1}. Then \titleref{D\_xi} is of the form
\begin{equation*}
\begin{split}D_\xi = \{ \xi_1 \mid v_{\xi_1}(f) \geq s\},\end{split}
\end{equation*}
where \titleref{f} is a polynomial in \titleref{x} or in \titleref{x\textasciicircum{}\{-1\}}, irreducible over
\(\hat{\bar{K}}\) and \titleref{s} is a nonnegativ rational number.
The pair \titleref{(f,s)} determines \titleref{xi}, but this representation is not unique.

Note that we can't simply extend the discoid representation to points of type I
by allowing \titleref{s} to take the value \titleref{infty}.

AUTHORS:
\begin{itemize}
\item {} 
Stefan Wewers (2017-02-10): initial version

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Lots} \PYG{o+ow}{and} \PYG{n}{lots} \PYG{n}{of} \PYG{n}{examples}\PYG{o}{\PYGZgt{}}
\end{Verbatim}

TO DO:
\begin{itemize}
\item {} 
allow ``virtual functions'' for the evaluations of valuations (and derivations).
``Virtual functions'' are products of rational functions with possible rational
exponents.

\item {} 
use more cached functions; this may improve speed

\item {} 
more systematic (and explicitly defined) relation between points and their
discoid representation

\item {} 
more doctests!

\end{itemize}
\index{BerkovichLine (class in mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine}\pysiglinewithargsret{\strong{class }\code{mclf.berkovich.berkovich\_line.}\bfcode{BerkovichLine}}{\emph{F}, \emph{vK}}{}
The class of a Berkovich projective line over a discretely valued field.

Let \titleref{K} be a field and \titleref{v\_K} a discrete valuation on \titleref{K}. Let \titleref{F=K(x)}
be a rational function field over \titleref{K}. We consider \titleref{F} a the function
field of the projective line \titleref{X} over \titleref{K}. Let \titleref{X\textasciicircum{}\{an\}} denote the
\titleref{(K,v\_K)}-analytic space associated to \titleref{X}. Then a point \titleref{xi} on \titleref{X\textasciicircum{}\{an\}}
may be identified with a (real valued) pseudo-valuation \titleref{v\_xi} on \titleref{F}
extending \titleref{v\_K}.

INPUT:
\begin{itemize}
\item {} 
\code{F} -- a rational function field over a base field K

\item {} 
\code{vK} -- a discrete valuation on the base field K

\end{itemize}
\index{divisor() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.divisor}\pysiglinewithargsret{\bfcode{divisor}}{\emph{f}}{}
Return the divisor of a rational function \titleref{f}.

INPUT:
\begin{itemize}
\item {} 
\titleref{f} -- a nonzero element of the function field of self

\end{itemize}

OUTPUT:

the divisor of \titleref{f}, as a list of pairs \titleref{(xi, m)}, where \titleref{xi} is
a point of type I and m is the multiplicity of \titleref{xi}.

\end{fulllineitems}

\index{find\_zero() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.find_zero}\pysiglinewithargsret{\bfcode{find\_zero}}{\emph{xi1}, \emph{xi2}, \emph{f}}{}
Return the point between \code{xi1} and \code{xi2} where \code{f} has valuation \titleref{0}.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{xi1}, \code{xi2} -- points on the Berkovich line such that}] \leavevmode
\code{\textbackslash{}xi\_1{}`{}`\textless{}{}`{}`xi2}

\end{description}

\item {} \begin{description}
\item[{\code{f} -- a nonconstant rational function; it is assumed that the signs}] \leavevmode
of the valuations of f at \code{xi1} and \code{xi2} are different

\end{description}

\end{itemize}

OUTPUT:

The smallest point between \code{xi1} and \code{xi2} where the valuation of \code{f}
is zero.

We are assuming for the moment that the function
\begin{equation*}
\begin{split}v \mapsto v(f)\end{split}
\end{equation*}
is affine (i.e. has no kinks) on the interval \titleref{{[}xi\_1,xi\_2{]}}.

\end{fulllineitems}

\index{gauss\_point() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.gauss_point}\pysiglinewithargsret{\bfcode{gauss\_point}}{}{}
Return the Gauss point of self.

The Gauss point is the type-II-point corresponding to the Gauss
valuation on \titleref{K{[}x{]}}.

\end{fulllineitems}

\index{infty() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.infty}\pysiglinewithargsret{\bfcode{infty}}{}{}
Return the point \titleref{infty}.

\end{fulllineitems}

\index{make\_polynomial() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.make_polynomial}\pysiglinewithargsret{\bfcode{make\_polynomial}}{\emph{f}, \emph{in\_unit\_disk=True}}{}
Turn \code{f} into a polynomial.

INPUT:
\begin{itemize}
\item {} 
\code{f} -- an element of \titleref{F=K(x)} or of \titleref{K{[}x{]}}

\item {} 
\code{in\_unit\_disk} -- boolean

\end{itemize}

OUTPUT:

Either \titleref{f} of \titleref{f(1/x)}, considered as a polynomial in \titleref{K{[}x{]}},
and depending on whether \code{in\_uni\_disk} is true or false.

\end{fulllineitems}

\index{point\_from\_discoid() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.point_from_discoid}\pysiglinewithargsret{\bfcode{point\_from\_discoid}}{\emph{phi}, \emph{s}, \emph{in\_unit\_disk=True}}{}
Return the point on \code{self} determined by a discoid.

INPUT:
\begin{itemize}
\item {} 
\code{phi} -- a monic and integral polynomial in \titleref{K{[}x{]}}

\item {} 
\code{s} -- a nonnegative rational number, or \titleref{infty}

\item {} 
\code{in\_unit\_disk} -- a boolean (default: True)

\end{itemize}

OUTPUT:

a point \titleref{xi} on the Berkovich line \code{self} which is the unique
boundary point of the discoid \titleref{D} determined as follows: if
\code{in\_unit\_disk} is true then \titleref{D} is the set of valuations \titleref{v} on
\titleref{K{[}x{]}} such that \titleref{v(phi)geq s}. Otherwise, it is the image of this
point under the automorphism \titleref{xto 1/x}.

If \titleref{D} defined above is not irreducible (and hence not a discoid) then
an error is raised.

\end{fulllineitems}

\index{point\_from\_polynomial\_pseudovaluation() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.point_from_polynomial_pseudovaluation}\pysiglinewithargsret{\bfcode{point\_from\_polynomial\_pseudovaluation}}{\emph{v}, \emph{in\_unit\_disk=True}}{}
Return the point corresponding to a pseudo-valuation on a poylnomial ring.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{v} -- a discrete pseudo-valuation on the polynomial ring \titleref{K{[}x{]}},}] \leavevmode
extending the base valuation \titleref{v\_K}

\end{description}

\item {} 
\code{in\_unit\_disk} (default=True) -- boolean

\end{itemize}

OUTPUT:

The point on the unit disk corresponding to \code{v} (if \code{in\_unit\_disk}
is true), or the point on the inverse unit disk corresponding to \code{v}.

\end{fulllineitems}

\index{point\_from\_pseudovaluation() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.point_from_pseudovaluation}\pysiglinewithargsret{\bfcode{point\_from\_pseudovaluation}}{\emph{v}}{}
Return the point on the Berkovich line corresponding to the pseudovaluation \code{v}.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{v} -- a discrete pseudovaluation on the function field of \code{self},}] \leavevmode
extending the base valuation \titleref{v\_K}

\end{description}

\end{itemize}

OUTPUT:

The point \titleref{xi} on the Berkovich line \titleref{X} ={}`{}`self{}`{}` corresponding to
the pseudo valuation \code{v} on the function field of \titleref{X}.

\end{fulllineitems}

\index{polynomial\_divisor() (mclf.berkovich.berkovich\_line.BerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.BerkovichLine.polynomial_divisor}\pysiglinewithargsret{\bfcode{polynomial\_divisor}}{\emph{f}, \emph{m}}{}
Return the divisor of zeroes of a squarefree polynomial.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{f} -- a squarefree polynomial in the generator of the function}] \leavevmode
field of self

\end{description}

\item {} 
\code{m} -- an integer

\end{itemize}

OUTPUT:

The divisor of \titleref{f}, multiplied with \titleref{m}.

NOTE:

At the moment, we must require that the Newton polygon of \titleref{f} has
either only nonpositive or only positive slopes. So the zeroes of
\titleref{f} lie all inside the closed unit disk, or all outside.

\end{fulllineitems}


\end{fulllineitems}

\index{PointOnBerkovichLine (class in mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.PointOnBerkovichLine}\pysigline{\strong{class }\code{mclf.berkovich.berkovich\_line.}\bfcode{PointOnBerkovichLine}}
A point on a Berkovich projective line.

We only allow two different types of points:
\begin{itemize}
\item {} \begin{description}
\item[{Type I, algebraic: these are the points that come from a closed point}] \leavevmode
on the (algebraic) projective line over the completed base field.

\end{description}

\item {} \begin{description}
\item[{Type II: these are the points which correspond to discrete valuations}] \leavevmode
on the function field whose residue field is a function field over the
residue base field

\end{description}

\end{itemize}

In particular, the Gauss valuation on \titleref{F=K(x)} with respect to the parameter
\titleref{x} corresponds t a point \titleref{xi\textasciicircum{}g} of type II on \titleref{X\textasciicircum{}\{an\}} which we call
the \emph{Gauss point}.

The set \titleref{X\textasciicircum{}\{an\}} has a canonical partial ordering in which the Gauss point
is the smallest elements. All point of type I are maximal elements.
\index{is\_strictly\_less() (mclf.berkovich.berkovich\_line.PointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.PointOnBerkovichLine.is_strictly_less}\pysiglinewithargsret{\bfcode{is\_strictly\_less}}{\emph{xi1}}{}
return True if self is strictly smaller than xi1.

\end{fulllineitems}

\index{make\_polynomial() (mclf.berkovich.berkovich\_line.PointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.PointOnBerkovichLine.make_polynomial}\pysiglinewithargsret{\bfcode{make\_polynomial}}{\emph{f}}{}
Return the polynomial corresponding to \code{f}.

INPUT:
\begin{itemize}
\item {} 
\code{f} -- an element of \titleref{F=K(x)}

\end{itemize}

OUTPUT:
\begin{description}
\item[{If \code{f} is an element of the function field \titleref{F=K(x)} the we return}] \leavevmode\begin{itemize}
\item {} 
f as an element of \titleref{K{[}x{]}} if possible and \code{self} lies in the unit disk

\item {} 
f(1/x) as an element of \titleref{K{[}x{]}} if possible and {\color{red}\bfseries{}{}`{}`}lies outside the unit disk

\end{itemize}

\end{description}

Otherwise an error is raised.

This function is useful to converting elements of the function field to
elements of the domain of the MacLane valuation underlying \code{self}.

\end{fulllineitems}


\end{fulllineitems}

\index{TypeIIPointOnBerkovichLine (class in mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine}\pysiglinewithargsret{\strong{class }\code{mclf.berkovich.berkovich\_line.}\bfcode{TypeIIPointOnBerkovichLine}}{\emph{X}, \emph{v}}{}
A point of type II on a Berkovich line.
INPUT:
\begin{itemize}
\item {} 
\code{X} -- a Berkovich line over a valued field K

\item {} 
\code{v} -- a discrete valuation on the function field of X extending the base valuation

\end{itemize}
\index{approximation() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.approximation}\pysiglinewithargsret{\bfcode{approximation}}{}{}
Return an approximation of \code{self}.
For a point of type II, \code{self} is already an approximation of itself.

\end{fulllineitems}

\index{discoid() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.discoid}\pysiglinewithargsret{\bfcode{discoid}}{\emph{certified\_point=None}}{}
Return a representation of the discoid of which \code{self} is the
unique boundary point.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{certified\_point} (default=None) -- this argument is not used}] \leavevmode
for type-II-points

\end{description}

\end{itemize}

OUTPUT:

A pair \titleref{(f, s)}, where \titleref{f} is a polynomial in the generator \titleref{x} of the
function field of \titleref{X}, or a polynomial in \titleref{1/x}, and where \titleref{s} is a
nonnegative rational number. This data represents a discoid \titleref{D} via
the condition \titleref{v\_xi(f)geq s}.

Then \code{self} is the unique boundary
point of \titleref{D}, and if, moreover, \code{self} is not the Gauss point then
\titleref{D} contains precisely the points \titleref{xi} which are greater or equal to
\code{self}. If \code{self} is the Gauss point then \titleref{D} is the standard
closed unit disk, \titleref{f=x} and \titleref{s=0}.

\end{fulllineitems}

\index{improved\_approximation() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.improved_approximation}\pysiglinewithargsret{\bfcode{improved\_approximation}}{}{}
Return an improved approximation of \code{self}.
This is meaningless for type-II-points, so self is returned.

\end{fulllineitems}

\index{infimum() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.infimum}\pysiglinewithargsret{\bfcode{infimum}}{\emph{xi2}}{}
Return the infimum of self and xi2.

INPUT:
\begin{itemize}
\item {} 
\code{xi2} -- a point of type I or II on the Berkovich line

\end{itemize}

OUTPUT:

The infimum of self and \titleref{xi\_2} (w.r.t. to the natural partial ordering).
Unless \titleref{xi\_2=infty} or self is equal to \titleref{xi\_2},
the result is a point of type II.

\end{fulllineitems}

\index{is\_equal() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_equal}\pysiglinewithargsret{\bfcode{is\_equal}}{\emph{xi}}{}
Return True if self is equal to \code{xi}.

\end{fulllineitems}

\index{is\_inductive() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_inductive}\pysiglinewithargsret{\bfcode{is\_inductive}}{}{}
True if \code{self} corresponds to an inductive pseud-valuation.
This is always true for points of type II.

\end{fulllineitems}

\index{is\_leq() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_leq}\pysiglinewithargsret{\bfcode{is\_leq}}{\emph{xi}}{}
Return True if self is less or equal to xi.

INPUT:
\begin{itemize}
\item {} 
\code{xi} -- a point of type I or II

\end{itemize}

OUTPUT:

True if self is less or equal to \code{xi} (w.r.t. the natural
partial order on \titleref{X})

\end{fulllineitems}

\index{is\_limit\_point() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.is_limit_point}\pysiglinewithargsret{\bfcode{is\_limit\_point}}{}{}
True is \code{self} corresponds to a limit valuation.
This is never true for points of type II.

\end{fulllineitems}

\index{point\_in\_between() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.point_in_between}\pysiglinewithargsret{\bfcode{point\_in\_between}}{\emph{xi1}}{}
Return a point in between \code{self} and \code{xi1}.

INPUT:
\begin{itemize}
\item {} 
\code{xi1} -- a point which is strictly smaller than \code{self}

\end{itemize}

OUTPUT: a point which lies strictly between \code{self} and \code{xi1}

\end{fulllineitems}

\index{pseudovaluation\_on\_polynomial\_ring() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring}\pysiglinewithargsret{\bfcode{pseudovaluation\_on\_polynomial\_ring}}{}{}
Return the pseudo-valuation on the polynomial ring `K{[}y{]}'
corresponding to \code{self}, where \titleref{y} is either \titleref{x} or \titleref{1/x} depending
on whether self lies in the standard closed unit disk or not.

\end{fulllineitems}

\index{type() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.type}\pysiglinewithargsret{\bfcode{type}}{}{}
Return the type of self.

\end{fulllineitems}

\index{v() (mclf.berkovich.berkovich\_line.TypeIIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIIPointOnBerkovichLine.v}\pysiglinewithargsret{\bfcode{v}}{\emph{f}}{}
Evaluate element of the function field on the valuation corresponding to self.

INPUT:
\begin{itemize}
\item {} 
\code{f} -- an element of the function field of the underlying projective line

\end{itemize}

OUTPUT:

the value \titleref{v(f)}, where \titleref{v} is the valuation corresponding to self

\end{fulllineitems}


\end{fulllineitems}

\index{TypeIPointOnBerkovichLine (class in mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine}\pysiglinewithargsret{\strong{class }\code{mclf.berkovich.berkovich\_line.}\bfcode{TypeIPointOnBerkovichLine}}{\emph{X}, \emph{v}}{}
An algebraic point of type I.

INPUT:
\begin{itemize}
\item {} 
\titleref{X} -- a Berkovich projective line over a valued field \titleref{K}

\item {} 
\titleref{v} -- an infinite pseudo-valuation on the function field of \titleref{X}

\end{itemize}

OUTPUT:

The point on \titleref{X} corresponding to \titleref{v}.
\index{approximation() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.approximation}\pysiglinewithargsret{\bfcode{approximation}}{\emph{certified\_point=None}}{}
Return an approximation of \code{self}.

INPUT:
\begin{itemize}
\item {} 
\code{certified point} (default=None) -- a point on the Berkovich line

\end{itemize}

OUTPUT:

An inductive point which approximates \code{self}, in such a way that
we can distinguish \code{self} from \code{certified point}.

If \code{self} is an inductive point, then \code{self} is returned. Otherwise,
\code{self} is a limit point, and the output is a point of type II greater
or equal to \code{self} (i.e. corresponding to a discoid containing \code{self}).
If \code{certified\_point} is not None and distinct from \code{self}, then
the output is not greater or equal to \code{certified\_point}.

TO DO : We should also make sure that the approximation has the same degree
as the point itself. If the point is generated as part of the support of
a principal divisor, then this should be ok, because of the default
``require\_final\_EF=True'' in ``vK.approximants(f)''.

\end{fulllineitems}

\index{discoid() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.discoid}\pysiglinewithargsret{\bfcode{discoid}}{\emph{certified\_point=None}}{}
Return a representation of a discoid approximating \code{self}.

INPUT:
\begin{itemize}
\item {} 
\code{certified\_point} (default=None) -- a point of type II

\end{itemize}

OUTPUT:

A pair \titleref{(f, s)}, where \titleref{f} is a polynomial in the generator \titleref{x} of the
function field of \titleref{X}, or \titleref{f=1/x}, and where \titleref{s} is a nonrational number,
or is equal to \titleref{infty}.
This data represents a (possibly degenerate) discoid \titleref{D} via the condition
\titleref{v\_xi(f)geq s}.

\titleref{D} as above is either the degenerate discoid with \titleref{s=infty} which has
\code{self} as the unique point, or \titleref{D} is an approximation of \code{self}
(this simply means that \code{self} is contained in \titleref{D}). If
\code{certified\_point} is given then it is guaranteed that it is not
contained in \titleref{D}.

\end{fulllineitems}

\index{improved\_approximation() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.improved_approximation}\pysiglinewithargsret{\bfcode{improved\_approximation}}{}{}
Return an improved approximation of \code{self}.

\end{fulllineitems}

\index{infimum() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.infimum}\pysiglinewithargsret{\bfcode{infimum}}{\emph{xi2}}{}
Return the infimum of self and \titleref{xi\_2}.

INPUT:
\begin{itemize}
\item {} 
\code{xi2} -- a point of type I or II on the Berkovich line

\end{itemize}

OUTPUT:

The infimum of self and \titleref{xi\_2}. Unless self or \titleref{xi\_2} are equal,
this is a point of type II.

\end{fulllineitems}

\index{is\_equal() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_equal}\pysiglinewithargsret{\bfcode{is\_equal}}{\emph{xi}}{}
Return True is self is equal to \code{xi}.

\end{fulllineitems}

\index{is\_gauss\_point() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_gauss_point}\pysiglinewithargsret{\bfcode{is\_gauss\_point}}{}{}
Return True if self is the Gauss point.

\end{fulllineitems}

\index{is\_in\_unit\_disk() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_in_unit_disk}\pysiglinewithargsret{\bfcode{is\_in\_unit\_disk}}{}{}
True is self is contained in the unit disk.

\end{fulllineitems}

\index{is\_inductive() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_inductive}\pysiglinewithargsret{\bfcode{is\_inductive}}{}{}
True if \code{self} corresponds to an inductive MacLane valuation.

\end{fulllineitems}

\index{is\_leq() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_leq}\pysiglinewithargsret{\bfcode{is\_leq}}{\emph{xi}}{}
Return True is self is less or equal to xi.

INPUT:
\begin{itemize}
\item {} 
\code{xi} -- a point of type I or II

\end{itemize}

OUTPUT:

True if self is less or equal to \code{xi} (w.r.t. the natural
partial order on \titleref{X} for which the Gauss pont is the smallest element).
Since self is a point of type I and hence maximal, this is never true
unless \titleref{xi} is equal to self.

\end{fulllineitems}

\index{is\_limit\_point() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.is_limit_point}\pysiglinewithargsret{\bfcode{is\_limit\_point}}{}{}
True if \code{self} corresponds to a limit valuation.

\end{fulllineitems}

\index{pseudovaluation\_on\_polynomial\_ring() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.pseudovaluation_on_polynomial_ring}\pysiglinewithargsret{\bfcode{pseudovaluation\_on\_polynomial\_ring}}{}{}
Return the MacLane valuation representing \code{self}.

OUTPUT:

A MacLane valuation on the polynomial ring \titleref{K{[}x{]}} representing \code{self}.
It is either inductive or a limit valuation.

\end{fulllineitems}

\index{type() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.type}\pysiglinewithargsret{\bfcode{type}}{}{}
Return the type of self

\end{fulllineitems}

\index{v() (mclf.berkovich.berkovich\_line.TypeIPointOnBerkovichLine method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.TypeIPointOnBerkovichLine.v}\pysiglinewithargsret{\bfcode{v}}{\emph{f}}{}
Evaluate the pseudo-valuation corresponding to self on \code{f}.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{f} -- an element of the function field \titleref{K(x)}}] \leavevmode
(or of the polynomial ring \titleref{K{[}x{]}}).

\end{description}

\end{itemize}

OUTPUT:

The value \titleref{v(f)}, where v is the pseudo-valuation corresponding to \code{self}.
If \titleref{f} is in \titleref{K{[}x{]}} then we take for \titleref{v} the MacLane pseudo-valuation
corresponding to \code{self}.

\end{fulllineitems}


\end{fulllineitems}

\index{equality\_of\_pseudo\_valuations() (in module mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.equality_of_pseudo_valuations}\pysiglinewithargsret{\code{mclf.berkovich.berkovich\_line.}\bfcode{equality\_of\_pseudo\_valuations}}{\emph{v1}, \emph{v2}}{}
Decide whether two pseudo-valuations are equal.

INPUT:
\begin{itemize}
\item {} \begin{description}
\item[{\code{v1}, \code{v2} -- two pseudo-valuations on the same rational}] \leavevmode
function field \titleref{F=K(x)}

\end{description}

\end{itemize}

OUTPUT:

True if \code{v1} is equal to \code{v2}, False otherwise.

We actually assume that the restriction of \code{v1} and \code{v2} to the
constant base field are equal.

\end{fulllineitems}

\index{mac\_lane\_infimum() (in module mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.mac_lane_infimum}\pysiglinewithargsret{\code{mclf.berkovich.berkovich\_line.}\bfcode{mac\_lane\_infimum}}{\emph{v1}, \emph{v2}}{}
Return the infimum of \titleref{v\_1} and \titleref{v\_2}.

INPUT:

-\code{v1}, \code{v2} -- MacLane valuations on \titleref{K{[}x{]}{}`}

OUTPUT:

on the set of all MacLane valuations on \titleref{K{[}x{]}}.

\end{fulllineitems}

\index{normalized\_reduction() (in module mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.normalized_reduction}\pysiglinewithargsret{\code{mclf.berkovich.berkovich\_line.}\bfcode{normalized\_reduction}}{\emph{v}, \emph{f}}{}
Return the normalized reduction of f with respect to v.

INPUT:
\begin{itemize}
\item {} 
v -- type II valuation on a rational function field F = K(x)

\item {} 
f -- a strongly irreducible polynom in K{[}x{]}, or 1/x

\end{itemize}

OUTPUT:

a nonzero element fb in the residue field of v ???
Precise definition needed!

\end{fulllineitems}

\index{valuation\_from\_discoid() (in module mclf.berkovich.berkovich\_line)}

\begin{fulllineitems}
\phantomsection\label{berkovich_line:mclf.berkovich.berkovich_line.valuation_from_discoid}\pysiglinewithargsret{\code{mclf.berkovich.berkovich\_line.}\bfcode{valuation\_from\_discoid}}{\emph{vK}, \emph{f}, \emph{s}}{}
Return the inductive valuation corresponding to a discoid.

INPUT:
\begin{itemize}
\item {} 
\code{vK} -- a discrete valuation on a field \titleref{K}

\item {} 
\code{f} -- a nonconstant monic integral polynomial over \titleref{K}

\item {} 
\code{s} -- a nonnegative rational number, or \titleref{infty}

\end{itemize}

OUTPUT:

an inductive valuation \code{v} on the domain of \code{f}, extending \code{vK},
corresponding to the discoid \titleref{D} defined by \titleref{w(f)geq s}. In other words,
this means that \titleref{D} defined above is irreducible (and hence a discoid),
and \titleref{v} is its unique boundary point.

If \titleref{D} is not irreducible, an error is raised.

\end{fulllineitems}



\section{Berkovich trees}
\label{berkovich_trees:berkovich-trees}\label{berkovich_trees::doc}\phantomsection\label{berkovich_trees:module-mclf.berkovich.berkovich_trees}\index{mclf.berkovich.berkovich\_trees (module)}
Finite children of the Berkovich projective line

Let \titleref{K} be a field and \titleref{v\_K} a discrete valuation on \titleref{K}. Let \titleref{X=mathbb\{P\textasciicircum{}1\_K\}}
be the projective line over \titleref{K}. Let \titleref{X\textasciicircum{}\{an\}} denote the
\titleref{(K,v\_K)}-analytic space associated to \titleref{X}. We call \titleref{X\textasciicircum{}\{an\}} the \emph{Berkovich
line} over \titleref{K}.

Let \titleref{xi\textasciicircum{}g} be the \emph{Gauss point} on \titleref{X\textasciicircum{}\{an\}}, corresponding to the Gauss
valuation on the function field of \titleref{X} with respect to the canonical parameter
\titleref{x}. Then \titleref{X\textasciicircum{}\{an\}} has a natural partial ordering for which \titleref{xi\textasciicircum{}g} is the
smallest element. With respect to this partial ordering, any two elements have
a unique infimum.

A \emph{Berkovich tree} is a finite (nonempty) subset \titleref{T} with the
property that for any two elements in \titleref{T} the infimum is also contained in
\titleref{T}. In particular, a \titleref{T} has a least element, called the \emph{root} of the tree.

Given any finite subset \titleref{S} of \titleref{X\textasciicircum{}\{an\}}, there is now a unique minimal
subtree \titleref{T} contaning \titleref{S}. We call \titleref{T} the tree \emph{spanned} by \titleref{S}.

This module realizes finite subtrees of \titleref{X\textasciicircum{}\{an\}} as combinatorial objects,
more precisely as \emph{finite rooted combinatorial trees}. So a tree consists
of a root, and a list of children. If the tree is a subtree of another tree,
then there is a link to its parent.

AUTHORS:
\begin{itemize}
\item {} 
Stefan Wewers (2017-02-13): initial version

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Lots} \PYG{o+ow}{and} \PYG{n}{lots} \PYG{n}{of} \PYG{n}{examples}\PYG{o}{\PYGZgt{}}
\end{Verbatim}
\index{BerkovichTree (class in mclf.berkovich.berkovich\_trees)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree}\pysiglinewithargsret{\strong{class }\code{mclf.berkovich.berkovich\_trees.}\bfcode{BerkovichTree}}{\emph{X}, \emph{root=None}, \emph{children=None}, \emph{parent=None}}{}
Create a new Berkovich tree \titleref{T}.

INPUT:
\begin{itemize}
\item {} 
\code{X} -- a Berkovich line

\item {} 
\code{root} -- a point of \code{X} (default: None)

\item {} 
\code{children} -- a list of Berkovich trees on \code{X} (default = None)

\item {} 
\code{parent} -- a Berkovich tree or None (default: None)

\end{itemize}

OUTPUT:

A Berkovich tree \titleref{T} on \titleref{X} with root \code{root}, children \code{children} and
parent \code{parent}.
\titleref{T} may be empty (no root and no children), but if there are children
then there must be root.
\index{adapt\_to\_function() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.adapt_to_function}\pysiglinewithargsret{\bfcode{adapt\_to\_function}}{\emph{f}}{}
Add all zeroes and poles of \titleref{f} as leaves of the tree.

INPUT:
\begin{itemize}
\item {} 
\code{f} -- a rational function on \titleref{X}

\end{itemize}

OUTPUT:

the new tree obtained by adding all zeroes and poles of \titleref{f} as 
vertices to the old tree.

\end{fulllineitems}

\index{add\_point() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.add_point}\pysiglinewithargsret{\bfcode{add\_point}}{\emph{xi}}{}
Return the tree spanned by self and the point xi.

INPUT:
\begin{itemize}
\item {} 
xi -- A point of type I or II on X

\end{itemize}

OUTPUT:

T1, T2, where
\begin{itemize}
\item {} 
T1 is the tree obtained from T0=self after inserting xi as a vertex.

\item {} 
T2 is the subtree of T1 with root xi

\end{itemize}

If T0 has a parent, then the root of T0 must be less than xi.
Therefore, the parent of T1 will be the original parent of T0.

Note that this command may change the tree T0!  For instance, xi may
become the root of T1 and then T0 has T1 as new parent.

\end{fulllineitems}

\index{children() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.children}\pysiglinewithargsret{\bfcode{children}}{}{}
Return the list of all children.

\end{fulllineitems}

\index{copy() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Return a copy of self.

\end{fulllineitems}

\index{find\_point() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.find_point}\pysiglinewithargsret{\bfcode{find\_point}}{\emph{xi}}{}
Find subtree with root \code{xi}.

INPUT:
\begin{itemize}
\item {} 
\code{xi} -- a point on the Berkovich line underlying \code{self}

\end{itemize}

OUTPUT:

The subtree \titleref{T} of \code{self} with root \code{xi}, or \code{None} if \code{xi}
is not a vertex of \code{self}.

\end{fulllineitems}

\index{graph() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.graph}\pysiglinewithargsret{\bfcode{graph}}{}{}
Return a graphical representation of self.

OUTPUT:

G, vert\_dict,

where G is a graph object and vert\_dict is a dictionary associating
to a vertex of G the corresponding vertex of self.

\end{fulllineitems}

\index{has\_parent() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.has_parent}\pysiglinewithargsret{\bfcode{has\_parent}}{}{}
Return True if self has a parent.

\end{fulllineitems}

\index{is\_leaf() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.is_leaf}\pysiglinewithargsret{\bfcode{is\_leaf}}{}{}
Return True if self is a leaf.

\end{fulllineitems}

\index{leaves() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.leaves}\pysiglinewithargsret{\bfcode{leaves}}{}{}
Return the list of all vertices.

\end{fulllineitems}

\index{make\_parent() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.make_parent}\pysiglinewithargsret{\bfcode{make\_parent}}{\emph{parent}}{}
add \code{parent} as parent of self.

\end{fulllineitems}

\index{parent() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.parent}\pysiglinewithargsret{\bfcode{parent}}{}{}
Return the parent of self.

\end{fulllineitems}

\index{paths() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.paths}\pysiglinewithargsret{\bfcode{paths}}{}{}
Return the list of all directed paths of the tree.

OUTPUT:

the list of all directed paths of the tree, as a list of pairs 
\titleref{(xi\_1,xi\_2)}, where \titleref{xi\_2} is a child of \titleref{xi\_1}.

\end{fulllineitems}

\index{position() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.position}\pysiglinewithargsret{\bfcode{position}}{\emph{xi}}{}
Find the position of \code{xi} in the tree T=self.

INPUT:
\begin{itemize}
\item {} 
\code{xi} -- a point on the Berkovich line underlying T

\end{itemize}

OUTPUT:

xi1, T1, T2, is\_vertex,

where
- xi1 is the image of xi under the retraction map onto the total
\begin{quote}

space of T
\end{quote}
\begin{itemize}
\item {} 
T1 is the smallest subtree of T whose total space contains xi1

\item {} 
T2 is the child of T1 such that xi1 lies on the edge connecting
T1 and T2 (or is equal to T1 if xi1 is the root of T1)

\item {} \begin{description}
\item[{is\_vertex is True if xi1 is a vertex of T (which is then the root}] \leavevmode
of T1) or False otherwise

\end{description}

\end{itemize}

\end{fulllineitems}

\index{print\_tree() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.print_tree}\pysiglinewithargsret{\bfcode{print\_tree}}{\emph{depth=0}}{}
Print the vertices of the tree, with identation corresponding to depth.

It would be nicer to plot the graph and then list the points corresponding
to the vertices.

\end{fulllineitems}

\index{root() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.root}\pysiglinewithargsret{\bfcode{root}}{}{}
Return the root of the tree.

\end{fulllineitems}

\index{subtrees() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.subtrees}\pysiglinewithargsret{\bfcode{subtrees}}{}{}
Return the list of all subtrees.

\end{fulllineitems}

\index{vertices() (mclf.berkovich.berkovich\_trees.BerkovichTree method)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.BerkovichTree.vertices}\pysiglinewithargsret{\bfcode{vertices}}{}{}
Return the list of all vertices.

\end{fulllineitems}


\end{fulllineitems}

\index{create\_graph\_recursive() (in module mclf.berkovich.berkovich\_trees)}

\begin{fulllineitems}
\phantomsection\label{berkovich_trees:mclf.berkovich.berkovich_trees.create_graph_recursive}\pysiglinewithargsret{\code{mclf.berkovich.berkovich\_trees.}\bfcode{create\_graph\_recursive}}{\emph{T}, \emph{G}, \emph{vertex\_dict}, \emph{root\_index}}{}
Create recursively a graph from a Berkovich tree.

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{m}
\item {\texttt{mclf.berkovich.berkovich\_line}}, \pageref{berkovich_line:module-mclf.berkovich.berkovich_line}
\item {\texttt{mclf.berkovich.berkovich\_trees}}, \pageref{berkovich_trees:module-mclf.berkovich.berkovich_trees}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
