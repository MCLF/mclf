# -*- coding: utf-8 -*-
r"""
Finite field extensions
=======================

Let `K` be a *standard field* and `L/K` a finite field extension. Then
`L` is a standard field, too. Moreover, `L/K` is automatically *simple*,
i.e. generated by one element `\alpha\in L`. Fixing a choice of such a
generator, we obtain a `K`-linear isomorphism

.. MATH::

    L \cong L_{\rm rel} := K[x]/(f),

where `f\in K[x]` is the minimal polynomial of `\alpha` over `K`. We call
`L_{\rm rel}` the **relative model** of the finite extension `L/K` (depending
on the choice of the **relative generator** `\alpha`).

Representing a finite extension `L/K` by a relative model makes it very
convenient to perform certain tasks which are important for this project:

- computing characteristic and minimal polynomials, norms, traces etc.
  of elements of `L`, relative to the base field `K`,
- extending valuations from `K` to `L`,
- restricting valuations from `L` to  `K`.

In this module we implement a class :class:`FiniteExtensionOfStandardFields`
representing a finite extension `L/K` of two standard fields, which provides
access to an internal relative model and methods implementing the various
useful tasks described above.

The class :class:`FiniteExtensionOfStandardFields` is a child of the class
:class:`StandardField <mclf.fields.standard_fields.StandardField>`.
In this way, the extension `L/K` is considered as the standard field `L`,
together with an embedding of a standard subfield `K` and the choice of a
relative model `L_{rel}=K[x]/(f)`, or, in other words, as a relative extension.

There are essentially two distinct ways to create an instance of this class.
Both are accessible via the creator function :func:`finite_field_extension`.
This functions accepts as input

- an embedding of standard fields `\phi:K\to L`, where `K` and `L` are of the
  same dimension, or
- a pair `(K, f)`, where `K` is a standard field and `f` is an irreducible,
  univariate polynomial over `K`,

and returns an object of :class:`FiniteExtensionOfStandardFields`.

In the first variant, the new object will return the field `L` as the
*extension field* and the field `K` as the *relative base field* of the finite
extensions::

    sage: from mclf import *
    sage: K = standard_rational_function_field(QQ, "x")
    sage: x = K.generator()
    sage: phi = K.hom(K, x^2 + 1)
    sage: L = finite_field_extension(phi); L
    Rational function field in x over Rational Field, as finite extension of
    Rational function field in x over Rational Field

    sage: L.extension_field().is_equal(phi.Codomain())
    True
    sage: L.relative_base_field().is_equal(phi.Domain())
    True
    sage: L.embedding_of_base_field().is_equal(phi)
    True

The relative model of `L/K` is computed and used only internally::

    sage: L.relative_model()
    Function field in T defined by T^2 - x + 1


In the second variant, the input `(K, f)` determines the relative base field
`K` and the relative model `K[x]/(f)`, and the standard form of the extension
field `L` is computed internally::

    sage: y = K.polynomial_generator("y")
    sage: f = y^2 + x^3 + 1
    sage: M = finite_field_extension(K, f); M
    Function field in y defined by y^2 + x^3 + 1, as finite extension of
    Rational function field in x over Rational Field

    sage: M.relative_base_field().is_equal(K)
    True
    sage: M.relative_polynomial() == f
    True

This second way of creating a finite extension can also be accessed via the
method :meth:`extension <mclf.fields.standard_fields.StandardField.extension>`
of :class:`StandardField <mclf.fields.standard_fields.StandardField>`::

    sage: K.extension(f)
    Function field in y defined by y^2 + x^3 + 1, as finite extension of
    Rational function field in x over Rational Field


Towers of finite extensions
---------------------------

Since finite extension are standard fields, it is possible to construct
arbitrary towers of finite extensions iteratively. For instance, we can do the
following::

    sage: K0 = standard_field(QQ)
    sage: x = K0.polynomial_generator("x")
    sage: K1 = K0.extension(x^2 - 2, "a")
    sage: a = K1.generator()
    sage: K2 = K1.extension(x^2 - a, "b"); K2
    Number Field in b with defining polynomial x^4 - 2, as finite extension
    of Number Field in a with defining polynomial x^2 - 2

    sage: K2.relative_base_field()
    Number Field in a with defining polynomial x^2 - 2, as finite extension of
    Rational Field

We call `K_2/K_1/K_0` an **extension tower**; it is realized implicitely as
an iteration of finite simple extensions; there is no explicit realization
as a class.

We can construct the total extension `K_2/K_0` via ::

    sage: L, s, t = K1.composition_with_superextension(K2)
    sage: L
    Number Field in x with defining polynomial x^4 - 2, as finite extension of
    Rational Field


.. TODO::

    - complete implementation of superextensions and subextensions;
      in particular, the method :meth:`as_extension_of`


EXAMPLES::

    sage: from mclf import *
    sage: k0 = standard_finite_field(2)
    sage: k1 = standard_finite_field(4)
    sage: k1_k0 = finite_field_extension(k0.hom(k1))
    sage: k1_k0
    Finite Field in z2 of size 2^2, as finite extension of Finite Field
    of size 2

The base field and the extension field of a standard extensions can be accessed
via the methods :meth:`domain` and :meth:`codomain`.::

    sage: k1_k0.domain()
    Finite Field of size 2
    sage: k1_k0.codomain()
    Finite Field in z2 of size 2^2

We can check the degree of a finite extension.::

    sage: k1_k0.relative_degree()
    2

A finite extension has a generator and a polynomial; these define the
standard model of the extension.::

    sage: k1_k0.relative_generator()
    z2
    sage: k1_k0.relative_polynomial()
    x^2 + x + 1

We can compose finite extensions, and compute subextensions with given
generators.::

    sage: a = k1.generator()
    sage: x = k1.polynomial_generator("x")
    sage: k2_k1 = k1_k0.extension(x^2 + x + a)

We can compute the total extension as follows::

    sage: k2_k0, s, t = k1_k0.composition_with_superextension(k2_k1)
    sage: k2_k0
    Finite Field in z4 of size 2^4, as finite extension of
    Finite Field of size 2


A finite extension can also be defined via an injective field homomorphism.::

    sage: K = standard_rational_function_field(k0, "x")
    sage: x = K.generator()
    sage: phi = K.hom(K, x^2+x)
    sage: K_K = finite_field_extension(phi)
    sage: K_K
    Rational function field in x over Finite Field of size 2,
    as finite extension of Rational function field in x over Finite Field
    of size 2
    sage: K_K.relative_generator()
    x
    sage: K_K.relative_polynomial()
    T^2 + T + x

"""

from mclf.fields.standard_fields import (
    standard_field, StandardField, StandardFiniteField, StandardNumberField)
from mclf.fields.standard_function_fields import (
    StandardFunctionField, StandardRationalFunctionField,
    StandardNonrationalFunctionField)
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.all import lcm


def finite_field_extension(*args):
    r""" Return the finite field extension determined by the input.

    INPUT:

    - ``args`` -- data determining a finite field extension `L/K`

    OUTPUT: a Sage object representing the finite field extension `L/K`.

    The arguments may be

    - an injective field morphism `\phi:L\to K`, or
    - a pair `(K, f)`, where `K` is a standard field and `g` is a univariate
      irreducible polynomial over `K`.
    - a tripel `(K, f, a)`, where `(K, f)` is as above, and `a` is an
      alphanumeric string.

    Here the fields `K` and `L` are assumed to be standard fields; they may be
    either objects of the Sage category ``Fields`` or instances of
    :class:`StandardField`.

    In the first case, the result is the finite field extension determined by
    `\phi`. In particular, the extension field is equal to the codomain of
    `\phi`, whereas the relative model is computed internally.

    In the second and third case, the input determines the relative base field
    `K` and relative model `K[x]/(f)`, and the (standard form of) the extension
    field `L` is computed internally.

    In the third case, we use ``a`` for the name of the generator of the
    relative model. If ``a`` is not given, we use the variable name of the
    polynomial `f` instead.

    """
    if len(args) == 1:
        phi = args[0]
        return finite_field_extension_from_embedding(phi)
    elif len(args) == 2:
        return finite_field_extension_from_polynomial(args[0], args[1])
    elif len(args) == 3:
        return finite_field_extension_from_polynomial(args[0], args[1], args[2])
    else:
        raise TypeError("Wrong number of parameters")


def trivial_extension(K):
    r""" Return the standard field `K` as a finite extension of itself.

    INPUT:

    - ``K`` -- a standard field

    OUTPUT:

    The standard field `K` as a finite extension of itself.

    The convention is that the relative generator of the trivial extension
    `K/K` is `1`, hence the relative polynomial is `T - 1`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = trivial_extension(QQ); K
        Rational Field, as finite extension of Rational Field
        sage: K.relative_generator()
        1
        sage: K.relative_polynomial()
        T - 1
        sage: K.relative_model()
        Number Field in T with defining polynomial T - 1
        sage: K.relative_norm(1)
        1

    """
    if not isinstance(K, StandardField):
        K = standard_field(K)
    T = K.polynomial_generator("T")
    return finite_field_extension_from_polynomial(K, T - 1)


def finite_field_extension_from_embedding(phi):
    r""" Return the finite field extension given by an embedding of
    standard fields.

    INPUT:

    - ``phi`` -- an embedding `\phi:K\to L` of standard fields

    OUTPUT:

    the finite fields extension `L/K`, as an instance of
    :class:`FiniteExtensionOfStandardField`.

    If `L/K` is not finite, an error is raised.

    ALGORITHM:

    Our goal is to construct a finite simple extension `M/K` and a `K`-linear
    isomorphism `\psi:L\to M` which is a left inverse of this embedding
    `\phi:K\to L`.

    Let

    .. MATH::

        L_0\subset L_1\subset\ldots \subset L_r=L

    be the natural sequence of subfield of `L` such that `L_i/L_{i-1}`
    is a simple extension, generated by one element `\alpha_i\in L_i`.
    Since `L_0` is the common prime field of `K` and `L`, we have a unique
    embedding `\psi_0:L_0\to K` which is a right inverse of `\phi`.

    We construct inductively a sequence of finite simple extensions
    `M_0=K\subset M_1\subset\ldots \subset M_r` and embeddings

    .. MATH::

        \phi_i: M_i\hookrightarrow L, \quad \psi_i: L_i \hookrightarrow M_i, \
            \quad i=1,\ldots,r,

    such that

    - the restriction of `\phi_i` to `K=M_0` is equal to `\phi`,
    - the restriction of `\psi_i` to `L_{i-1}` is equal to `\psi_{i-1}`,
    - each `\phi_i` is a let inverse of `\psi_i`.

    Then `M:=M_r` is a finite extension of `K` and `\psi:=\psi_r:L\to M` and
    `\phi_r:M\to L` are mutually inverse, is `K`-linear isomorphisms.

    The last step is to collapse the extension `M/K`, which is a tower of
    simple extension, to a single simple extension. This is also done
    inductively, using the method
    :meth:`FiniteExtensionOfStandardFields.superextension`.


    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_rational_function_field(GF(2), "t")
        sage: k = standard_finite_field(4)
        sage: x, y = k.polynomial_generators(["x", "y"])
        sage: L = standard_function_field(x^3 + y^2)
        sage: x, y = L.generators()
        sage: phi = K.hom(L, x + y)
        sage: L = finite_field_extension_from_embedding(phi); L
        Function field in y defined by y^2 + x^3, as finite extension of
        Rational function field in t over Finite Field of size 2

        sage: L.relative_generator()
        (x + z2 + 1)*y + x^2 + z2*x

        sage: L.relative_polynomial()
        T^6 + t*T^5 + (t + 1)*T^4 + t^3*T^3 + (t^6 + t^5 + t^4 + t^2)*T^2
        + (t^7 + t^6 + t^4)*T + t^10 + t^5 + t^4

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        EmbeddingOfStandardFields, embedding_of_standard_fields)
    if not isinstance(phi, EmbeddingOfStandardFields):
        phi = embedding_of_standard_fields(phi)
    assert phi.is_finite_extension()

    # initialization:
    K = phi.Domain()                # K and L are in StandardFields!
    L = phi.Codomain()
    M = K.as_extension_of_itself()  # M is the trivial extension of K
    L0 = L.prime_subfield()         # L0, L1 are natural subfields of L
    L0_to_M = L0.hom(M)             # there is a unique embedding
    M_to_L = phi

    # we walk through the tower of natural subfields of L;
    # in each step we create a finite simple extension M1/M corresponding to
    # the finite intermediate extension L1/L0
    for L1 in L.natural_subfields()[1:]:
        if L1.is_function_field() and L1.is_rational_function_field():
            assert L1.constant_base_field().is_equal(L0)
            # L1/L0 is a rational function field
            M1, L1_to_M1, M1_to_L = _lift_embedding_to_rational_function_field(
                M, L0_to_M, L1, M_to_L)
        else:
            f = L1.polynomial()
            alpha = L1.generator()
            # L1/L0 is finite, f the minimal polynomial of the gen alpha
            M1, L1_to_M1, M1_to_L = _lift_embedding_to_finite_simple_extension(
                M, L0_to_M, L1, alpha, f, M_to_L)
            # now M1/k is a finite simple extension
        # replace M/K with M1/M/K
        M, M1_to_M, M_to_M1 = M.composition_with_superextension(M1)
        L0 = L1
        L0_to_M = L1_to_M1.post_compose(M1_to_M)
        M_to_L = M_to_M1.post_compose(M1_to_L)

    # end of loop; L0 = L, so M and M_to_L are what we want; moreover:
    L_to_M = L0_to_M

    return _new_model_of_finite_field_extension(phi, M, L_to_M, M_to_L)


def _new_model_of_finite_field_extension(phi, M, s, t):
    r""" Helper function.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`
    - ``M`` -- a finite extension of `K`, `M/K`,
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`

    OUTPUT:

    the finite extension `L/K` with embedding morphism `\phi`, and with the
    same relative model as `M`.

    This is a helper function for :func:`finite_field_extension_from_embedding`

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_finite_field(2)
        sage: x = K.polynomial_generator("x")
        sage: L = K.extension(x^3+x+1, "a")
        sage: M = K.extension(x^3+x^2+1, "b")
        sage: s = L.hom(M, M.generator()+2)
        sage: t = s.inverse()
        sage: phi = L.embedding_of_base_field()
        sage: N = _new_model_of_finite_field_extension(phi, M, s, t)
        sage: N.relative_generator()
        z3 + 1

    """
    K = phi.Domain()
    L = phi.Codomain()
    M_rel = M.relative_model()
    s = s.sage_morphism().post_compose(M.to_relative_model())
    t = M.from_relative_model().post_compose(t.sage_morphism())

    if L.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M_rel, s, t)
    elif L.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M_rel, s, t)
    elif L.is_function_field():
        if L.is_rational_function_field():
            return FiniteExtensionOfFunctionFieldsRational(phi, M_rel, s, t)
        else:
            return FiniteExtensionOfFunctionFieldsNonrational(phi, M_rel, s, t)
    else:
        raise NotImplementedError()


def _lift_embedding_to_rational_function_field(
        K, L0_to_K, L1, K_to_L):
    r""" Helper function for :meth:`finite_field_extension_from_embedding`.

    INPUT:

    - ``K`` -- a standard_function_field
    -  ``L0_to_K`` an embedding of standard fields `\psi_0:L_0\to K`
    - ``L1`` -- a rational function field over L0,
      as a subfield of a standard field `L`
    - ``K_to_L`` -- an embedding `\phi_0:K\to L`

    It is assumed that the composition `\phi_0\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M, \psi_1, \phi_1)`, where

    - `M/K` is a finite simple extension
    - `\psi_1:L_1\to M` is an extension of `\psi_0:L_0\to K`
    - `\phi_1:M\to L` is an extension of `\phi_0:K\to L`,

    and such that `\phi_1\circ\psi_1:L_1\to L` is the natural inclusion.

    EXAMPLES::

        sage: from mclf import *
        sage: k = standard_finite_field(2)
        sage: K = standard_rational_function_field(k, "x")
        sage: x = K.generator()
        sage: phi0 = K.hom(K, x^2 + x)
        sage: psi0 = k.hom(K)
        sage: L = K.as_subfield_of_itself()
        sage: M, psi, phi = _lift_embedding_to_rational_function_field(K, psi0, L, phi0)
        sage: M
        Function field in y defined by y^2 + y + x, as finite extension of
        Rational function field in x over Finite Field of size 2

    """
    L = L1.Overfield()
    t = L1.generator()
    x = K.generators()[0]
    x1 = K_to_L(x)
    f = L.algebraic_relation(x1, t)
    f_K = L0_to_K.change_coefficients(f)
    # we have f(phi(x), t) = 0
    # we need an extension M/K containing an element beta
    # such that phi(beta) = t, then we would have
    # f_K(x, beta) = 0; this leaves only finitely many possibilities
    # for beta
    _, T = f_K.parent().gens()
    f_K = f_K(x, T).univariate_polynomial().change_variable_name("S")
    for g in K.prime_factors(f_K):
        g_L = K_to_L.change_coefficients(g)
        if g_L(t).is_zero():
            M = K.extension(g)
            beta = M.relative_generator()
            M_to_L = M.relative_hom(L, t, K_to_L)
            L1_to_M = L1.hom(M, beta, L0_to_K)
            assert L1_to_M.post_compose(M_to_L).is_equal(L1.embedding())
            return M, L1_to_M, M_to_L
    # if we get here, something went wrong
    raise AssertionError()


def _lift_embedding_to_finite_simple_extension(
        M, L0_to_M, L1, alpha, f, M_to_L):
    r""" Helper function for :meth:`finite_field_extension_from_embedding`.

    INPUT:

    - ``M`` -- a finite field extension `M/K`
    - ``L0_to_M`` an embedding of standard fields `\psi_0:L_0\to M`
    - ``L1`` -- a finite field extension over L0, which is a natural
      subfield of `L`
    - `alpha` -- the generator of `L_1/L_0`
    - `f` -- the minimal polynomial of `\alpha` over `L_0`
    - ``M_to_L`` -- an embedding `\phi:M\to L`

    It is assumed that the composition `\phi\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M_1, \psi_1, \phi_1)`, where

    - `M_1/M` is a finite simple extension
    - `\psi_1:L_1\to M_1` is an extension of `\psi_0:L_0\to M`
    - `\phi_1:M_1\to L` is an extension of `\phi:M\to L`,

    and such that `\phi\circ\psi_1:L_1\to L` is the natural inclusion.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(QQ)
        sage: x = K.polynomial_generator("x")
        sage: M = K.extension(x^2 - 2, "a")
        sage: a = M.relative_generator()
        sage: f = M.relative_polynomial()
        sage: L0_to_M = K.hom(M)
        sage: L1 = M
        sage: M_to_L = M.hom(M, -a)
        sage: M1, psi1, phi1 = _lift_embedding_to_finite_simple_extension(M, L0_to_M, L1, a, f, M_to_L)
        sage: psi1
        the embedding of Number Field in a with defining polynomial x^2 - 2
        into Number Field in a with defining polynomial x^2 - 2,
        sending a to -a

    """
    L = M_to_L.Codomain()
    f_M = L0_to_M.change_coefficients(f)
    found_factor = False
    for g in M.prime_factors(f_M):
        g_L = M_to_L.change_coefficients(g)
        if g_L(alpha).is_zero():
            factor_found = True
            M1 = M.extension(g)
            M1_to_L = M1.relative_hom(L, alpha, M_to_L)
            L0_to_M1 = L0_to_M.post_compose(M1.embedding_of_base_field())
            L1_to_M1 = L1.hom(M1, M1.relative_generator(), L0_to_M1)
    assert factor_found, "something went wrong"
    return M1, L1_to_M1, M1_to_L


def finite_field_extension_from_polynomial(K, f, gen_name=None):
    r""" Return the finite field extension given by an irreducible polynomial.

    INPUT:

    - ``K`` -- a standard field
    - ``f`` -- an univariate polynomial, irreducible over `K`
    - ``gen_name`` -- an alphanumeric string (optional)

    OUTPUT:

    the finite field extension `L:=K[x]/(f)` over `K`. If ``gen_name`` is
    given, it is used for the name of the generator of `L/K`.


    EXAMPLES::

        sage: from mclf import *
        sage: R.<x> = QQ[]
        sage: K = standard_number_field(x^2-2, "a")
        sage: a = K.generator()
        sage: finite_field_extension_from_polynomial(K, x^2 - a, "b")
        Number Field in b with defining polynomial x^4 - 2, as finite
        extension of Number Field in a with defining polynomial x^2 - 2

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        embedding_of_standard_fields)
    from mclf.fields.standard_fields import homomorphism_on_standard_field
    if not isinstance(K, StandardField):
        K = standard_field(K)
    f = K.change_coefficients(f)
    if gen_name is None:
        gen_name = f.variable_name()

    M = make_extension(K.standard_model(), f, gen_name)
    if f.degree() == 1:
        L = K
        phi = K.hom(L)
        L_to_M = homomorphism_on_standard_field(L.standard_model(), M)
        # L_to_M = L.standard_model().hom(M)
        M_to_L = homomorphism_on_standard_field(M, L.standard_model(),
                                                -f[0]/f[1], phi)
        # M_to_L = M.hom([-f[0]/f[1]], phi)
    else:
        L = standard_field(M)
        phi = K.hom(L)
        L_to_M = L.to_original_model()
        M_to_L = L.from_original_model()

    if K.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M, L_to_M, M_to_L)
    elif K.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M, L_to_M, M_to_L)
    elif K.is_function_field():
        if L.is_rational_function_field():
            return FiniteExtensionOfFunctionFieldsRational(
                phi, M, L_to_M, M_to_L)
        else:
            return FiniteExtensionOfFunctionFieldsNonrational(
                phi, M, L_to_M, M_to_L)
    else:
        raise NotImplementedError()


class FiniteExtensionOfStandardFields(StandardField):
    r""" An object representing a finite extension of a standard field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    Here `M` is a Sage field equipped with the method :meth:`base_field`,
    and its base field has to a equal to the standard model of the domain
    `K` of `\phi`.

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    To create an instance of this class you should use the function
    :func:`finite_field_extension`.


    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(GF(4))
        sage: x = K.polynomial_generator("x")
        sage: f = x^3 + x^2 + x + K.generator() + 1
        sage: L = finite_field_extension(K, f); L
        Finite Field in z6 of size 2^6, as finite extension of Finite Field
        in z2 of size 2^2

    We may view `L` has a standard field.::

        sage: L.standard_model()
        Finite Field in z6 of size 2^6

    Internally, the extension is represented by a "relative model"::

        sage: L.relative_model()
        Univariate Quotient Polynomial Ring in x over Finite Field in z2
        of size 2^2 with modulus x^3 + x^2 + x + z2 + 1

    Viewing `L` as a relative extension, it is defined by its *relative base
    field* (also identical to the *domain*), the *relative generator*, and the
    *relative polynomial* (which is the relative minimal polynomial of the
    relative generator).::

        sage: L.relative_base_field()
        the standard field with 4 elements
        sage: L.relative_generator()
        z6
        sage: L.relative_polynomial()
        x^3 + x^2 + x + z2 + 1


    """

    def __init__(self, phi, M, s, t):
        from mclf.fields.embeddings_of_standard_fields import (
            EmbeddingOfStandardFields)
        if not isinstance(phi, EmbeddingOfStandardFields):
            phi = embedding_of_standard_fields(phi)
        K = phi.Domain()
        L = phi.Codomain()

        self._relative_base_field = K
        self._extension_field = L
        self._embedding = phi

        assert hasattr(M, "base_ring"), "M = {} does not have the attribute \
            `base_ring`".format(M)
        assert M.is_field(), "M = {} is not a field".format(M)
        assert M.base_ring() == K.standard_model(), "the base field of M={} \
            must be equal to K = {}".format(M, K.standard_model())
        self._relative_generator = t(M.gen())
        if hasattr(M, "relative_polynomial"):
            self._relative_polynomial = M.relative_polynomial()
        elif hasattr(M, "polynomial"):
            self._relative_polynomial = M.polynomial()
        elif hasattr(M, "modulus"):
            self._relative_polynomial = M.modulus()
        else:
            raise TypeError("M = {} is not of the correct type".format(M))
        self._relative_model = M
        self._to_relative_model = s
        self._from_relative_model = t

        # we initialize this extension as a standard field
        if L.is_finite():
            StandardFiniteField.__init__(self, L)
        elif L.is_number_field():
            StandardNumberField.__init__(self, L)
        elif L.is_function_field():
            if L.is_rational_function_field():
                StandardRationalFunctionField.__init__(self, L)
            else:
                StandardNonrationalFunctionField.__init__(self, L)

    def __repr__(self):
        return "{}, as finite extension of {}".format(self.codomain(),
                                                      self.domain())

    def relative_base_field(self):
        r""" Return the relative base field of this finite extension.

        Note that we return an instance of the class :class:`StandardField`.
        """
        return self._relative_base_field

    def domain(self):
        r""" Return the standard model of the relative base field; it is the
        domain of the embedding defining this standard extension.
        """
        return self.relative_base_field().standard_model()

    def extension_field(self):
        r""" Return the extension field of this finite extension.

        """
        return self._extension_field

    def codomain(self):
        r""" Return the standard model of the extension field; it is the
        codomain of the embedding defining this standard extension.
        """
        return self.standard_model()

    def embedding_of_base_field(self):
        r""" Return the embedding of the base field into the extension field.

        """
        return self._embedding

    def relative_model(self):
        r""" Return the relative model of this finite field extension.

        """
        return self._relative_model

    def to_relative_model(self):
        r""" Return the isomorphism from the extension field
        to the relative model.

        """
        return self._to_relative_model

    def from_relative_model(self):
        r""" Return the isomorphism from the relative model to the
        standard model of the extension field.

        """
        return self._from_relative_model

    def relative_degree(self):
        r""" Return the degree of this field extension.

        This must be implemented by the subclass.
        """
        return self.relative_polynomial().degree()

    def relative_polynomial(self):
        r""" Return the polynomial corresponding to the standard model of this
        extension.

        """
        return self._relative_polynomial

    def relative_generator(self):
        r""" Return the generator of this finite extension.

        """
        return self._relative_generator

    def relative_minpoly(self, t, var_name="T"):
        r""" Return the minimal polynomial of this element over the base field
        of this finite extension.

        INPUT:

        - `t` -- an element of the extension field `L`
        - ``varname`` -- an alphanumeric string (default: "T")

        OUTPUT:

        The minimal polynomial of `t` over the relative base field `K`.

        If ``var_name`` is not given, we use the letter "T" as a default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F0 = standard_rational_function_field(k, "x")
            sage: x = F0.generator()
            sage: y = F0.polynomial_generator("y")
            sage: F = F0.extension(y^3 + x^4 + x + 1)
            sage: y = F.relative_generator()
            sage: F.relative_minpoly(y + x)
            T^3 + x*T^2 + x^2*T + x^4 + x^3 + x + 1

        """
        return self.to_relative_model()(t).minpoly().\
            change_variable_name(var_name)

    def relative_norm(self, a):
        r""" Return the norm of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the norm of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: K = standard_finite_field(4)
            sage: a = K.polynomial_generator("a")
            sage: L = K.extension(a^2 + a + K.generator())
            sage: a = L.relative_generator()
            sage: L.relative_norm(a)
            z2

            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 - 2, "a")
            sage: a = K.generator()
            sage: L = K.extension(x^3 + a*x + 2, "b")
            sage: b = L.generator()
            sage: L.relative_norm(b)
            -2

        """
        a = self.to_relative_model()(a)
        if hasattr(a, "relative_norm"):
            b = a.relative_norm()
        elif hasattr(a, "norm"):
            b = a.norm()
        else:
            raise AssertionError()
        return b

    def relative_trace(self, a):
        r""" Return the trace of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the trace of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 + x + 1, "a")
            sage: b = K.polynomial_generator("b")
            sage: L = K.extension(b^3 + b^2 + K.generator() + 1)
            sage: L.relative_trace(L.generator())
            -2

        """
        return self.to_relative_model()(a).trace()

    def relative_charpoly(self, a, var_name="T"):
        r""" Return the characteristic polynomial of an element under this
        finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension
        - ``var_name`` -- an alphanumeric string (default: "T")

        OUTPUT:

        the characteristic polynomial of `a` with respect to this finite field
        extension `L/K`.

        If ``var_name`` is not given, we choose the letter "T" by default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F = standard_rational_function_field(k, "x")
            sage: x = F.generator()
            sage: phi = F.hom(F, x^2 + 1)
            sage: FF = finite_field_extension(phi)
            sage: FF.relative_charpoly(x)
            T^2 + x + 1

        """
        return self.to_relative_model()(a).charpoly().\
            change_variable_name(var_name)

    def relative_hom(self, M, beta, *phi0):
        r""" Return the homomorphism to another field extending a base
        homomorphism, given by the image of the relative generator.

        INPUT:

        - ``M`` -- a field
        - ``beta`` -- an element of M
        - ``phi0`` -- an embedding `\phi_0:K\to M` of the relative base field
                      of this extension `L/K` into M

        OUTPUT:

        the homomorphism `\phi:L\to M` extending `\phi_0` sending
        the relative generator `\alpha` of `L/K` to `\beta`.

        Such an embedding exists iff `\beta` is a root of the image of
        the minimal polynomial of `\alpha` under `\phi_0`. If this is not
        true, an error is raised.

        If `\phi_0` is omitted, `K` must be a subfield of `M` and then we
        let `\phi_0:K\to M` be the natural inclusion.

        The field `M` may be given as a Sage field, or as an instance of
        the mclf class
        :class:`EmbeddingOfStandardFields <mclf.fields.standard_fields.EmbeddingOfStandardFields>`.


        EXAMPLES::

            sage: from mclf import *
            sage: K = GF(2)
            sage: L = GF(4)
            sage: L_K = finite_field_extension(K.hom(L))
            sage: alpha = L_K.relative_generator()
            sage: L_K.relative_hom(L, alpha + L.one())
            the embedding of Finite Field in z2 of size 2^2 into Finite Field
            in z2 of size 2^2, sending z2 to z2 + 1

        """
        K = self.domain()
        f = self.relative_polynomial()
        # make sure beta lies in M
        beta = M(beta)
        # turn M into a bare field
        if isinstance(M, StandardField):
            M = M.standard_model()

        if len(phi0) == 0:
            # phi0 was omitted from the input
            if not K.is_subring(M):
                print("L_K = ", self)
                print("K = ", K)
                print("M = ", M)
            assert K.is_subring(M), "the base field must be a subfield of M"
            phi0 = K.hom(M)
        elif len(phi0) == 1:
            phi0 = phi0[0]
            assert K.is_subring(phi0.domain())
            assert phi0.codomain().is_subring(M)
        else:
            raise ValueError("Wrong number of parameters")

        # check existence
        f_M = f.map_coefficients(phi0, M)
        assert f_M(beta).is_zero(), "the homomorphism doesn't exist"

        from mclf.fields.standard_fields import (
            homomorphism_on_standard_field)
        phi1 = homomorphism_on_standard_field(self.relative_model(),
                                              M, [beta], phi0)
        phi = self.to_relative_model().post_compose(phi1)
        from mclf.fields.embeddings_of_standard_fields import (
            embedding_of_standard_fields)
        return embedding_of_standard_fields(phi)

    def iterated_relative_base_fields(self):
        r""" Return the list of all iterated relative base fields of this
        extension.

        """
        K = self.relative_base_field()
        if isinstance(K, FiniteExtensionOfStandardFields):
            return [K] + K.iterated_relative_base_fields()
        else:
            return [K]

    def as_extension_of(self, K0):
        r""" Return this extension field as a finite simple extension of `K_0`.

        INPUT:

        - ``K0`` -- a standard field of which this field `K` is a finite
          extension

        To determine whether and how `K` is a finite extension of `K_0` we
        proceed as follows:

        1. we check is `K_0` is a subfield of `K`, as an instance of
           :class:`StandardSubfield <mclf.field.standard_subfields.\
           StandardSubfield`,

        2. we check whether `K_0` occurs in the list of iterated relative base
           fields of `K`, via the method :meth:`iterated_relative_base_fields`.


        OUTPUT:

        the finite extension `K/K_0`, as an instance of
        :class:`StandardFiniteFieldExtension`.

        """
        if isinstance(K0, StandardSubfield):
            assert K0.Overfield().is_equal(self)
            phi = K0.embedding()
            assert phi0.is_finite_extension()
            return finite_field_extension(phi)
        elif isinstance(K0, StandardField):
            assert any(K0.is_equal(base_field)
                       for base_field in self.iterative_relative_base_field())
            # it is tempting to just compute the embedding of K0 into K
            # and then apply "finite_field_extension_from_embedding", but
            # this is circular and would lead to an infinite loop
            raise NotImplementedError()
        else:
            raise TypeError()

    def composition_with_superextension(self, M):
        r""" Return the composition of this extension with a superextension.

        INPUT:

        - ``M`` -- a finite extension `M/L` of this extension `L/K`

        OUTPUT:

        A triple `(N, s, t)`, where `N/K` is a finite simple extension,
        `s:M\to N` is a `K`-linear isomorphism and `t` is the inverse of `s`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 - 2, "a")
            sage: a = K.generator()
            sage: L = K.extension(x^2 - a, "b")
            sage: b = L.relative_generator()
            sage: M = L.extension(x^2 - b, "c")
            sage: N, s, t = L.composition_with_superextension(M)

        """
        from mclf.fields.standard_fields import homomorphism_on_standard_field
        # fix some notation
        K = self.relative_base_field()
        L = self
        assert M.relative_base_field().is_equal(L)
        L_to_M = M.embedding_of_base_field()
        K_to_M = L.embedding_of_base_field().post_compose(L_to_M)

        # we need to work with the relative model of L
        L_rel = L.relative_model()
        L_rel_to_M = homomorphism_on_standard_field(
            L_rel, M.standard_model(), L_to_M(L.relative_generator()), K_to_M)

        # we first find an element gamma in M which generates M/K
        # for this we use the method `primitive_element` associated
        # to a Sage function field
        g = M.relative_polynomial().map_coefficients(
            L.to_relative_model(), L_rel)
        M1 = L_rel.extension(g, g.variable_name()+"1")
        M1_to_M = homomorphism_on_standard_field(M1, M.standard_model(),
                                                 M.relative_generator(),
                                                 L_rel_to_M)
        # this doesn't always work
        # we need our own function "primitive_element"
        from mclf.fields.standard_fields import primitive_element
        gamma = M1_to_M(primitive_element(M1))
        # gamma = M1_to_M(M1.primitive_element())

        # we compute the minimal polynomial g of gamma over K
        f = M.minimal_polynomial(gamma)  # the minpoly over the prime field
        for g in K.prime_factors(f):
            g_M = g.map_coefficients(K_to_M, M.standard_model())
            if g_M(gamma).is_zero():
                N = finite_field_extension_from_polynomial(K, g)
                N_to_M = N.relative_hom(M, gamma, K_to_M)
                M_to_N = N_to_M.inverse()
                return N, M_to_N, N_to_M
        # if we get here, something went wrong
        raise AssertionError()

    def restriction_of_valuation(self, w):
        r""" Compute the restriction of a valuation from the codomain to the
        domain of this field extension.

        INPUT:

        - ``w`` -- a valuation on the codomain `L` of this extension

        OUTPUT:

        the restriction `v:=w|_K` to the domain `K` of this extension.

        This method must be implemented by the appropriate subclass.

        .. NOTE::

            It is not clear if this method is very useful. The algorithm for
            computing the restriction depends more on the type of the fields
            `K` and `L`, and on the nature of the valuation, and not so much
            on the type of the extension `L/K`. Therefore, these algorithms
            should rather be implemented by the appropriate subclasses of
            :class:`ValuedField`.

        """
        raise NotImplementedError()


# the following subclasses are only defined to be consitent with inheritance.
# For instance, we only need the class `FiniteExtensionOfFiniteField` so that
# its instances inherit the special methods from `StandardFiniteField` which
# are distinct from and not defined on `StandardField`.


class FiniteExtensionOfFiniteFields(
        FiniteExtensionOfStandardFields, StandardFiniteField):
    r""" An object representing a finite extension of a finite field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardFiniteField <mclf.fields.standard_fields.\
        StandardFiniteField>`.

    """


class FiniteExtensionOfNumberFields(FiniteExtensionOfStandardFields,
                                    StandardNumberField):
    r""" An object representing a finite extension of a number field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardNumberField <mclf.fields.standard_fields.\
        StandardNumberField>`.


    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(CyclotomicField(3, "theta"))
        sage: x = K.polynomial_generator("x")
        sage: f = x^3 - K.generator()
        sage: L = finite_field_extension(K, f); L
        Number Field in x with defining polynomial x^6 + x^3 + 1,
        as finite extension of Cyclotomic Field of order 3 and degree 2

    We may view `L` has a standard field.::

        sage: L.standard_model()
        Number Field in x with defining polynomial x^6 + x^3 + 1

        sage: L.original_model()
        Number Field in x with defining polynomial x^3 - theta
        over its base field

    Viewing `L` as a relative extension, it is defined by its
    *relative base field* (also identical to the *domain*), the
    *relative generator*, and the *relative polynomial* (which is the
    relative minimal polynomial of the relative generator).::

        sage: L.relative_base_field()
        Cyclotomic Field of order 3 and degree 2 as a standard field
        sage: L.relative_generator()
        x
        sage: L.relative_polynomial()
        x^3 - theta

    """


class FiniteExtensionOfFunctionFields(FiniteExtensionOfStandardFields,
                                      StandardFunctionField):
    r""" An object representing a finite extension of a function field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardFunctionField <mclf.fields.standard_fields.\
        StandardFunctionField>`.

    """


class FiniteExtensionOfFunctionFieldsRational(FiniteExtensionOfStandardFields,
                                              StandardRationalFunctionField):
    r""" An object representing a finite extension of a function field,
    which is itself a rational funciton field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L` is a rational function field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardRationalFunctionField <mclf.fields.\
        standard_function_fields.StandardRationalFunctionField>`.

    """


class FiniteExtensionOfFunctionFieldsNonrational(
        FiniteExtensionOfStandardFields, StandardNonrationalFunctionField):
    r""" An object representing a finite extension of a function field,
    which is itself a nonrational function field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L` is a nonrational function field
                 and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardNonrationalFunctionField <mclf.fields.\
        standard_function_fields.StandardNonrationalFunctionField>`.

    """


# ----------------------------------------------------------------------------


def make_extension(K, f, gen_name):
    r""" Return the finite extension of a standard field with given equation.

    INPUT:

    - ``K`` -- a standard field
    - ``f`` -- an irreducible univariate polynomial over `K`
    - ``var_name`` -- an alphanumeric string

    OUTPUT:
    The finite simple extension of `K` with equation `f` and generator name
    ``gen_name``.

    """
    L = K.extension(f, gen_name)
    assert L.is_field(), "L = {} is not a field!".format(L)
    assert hasattr(L, "base_ring") and L.base_ring() is K
    return L


def algebraic_relation(K, x, y):
    r""" Return an algebraic relation between `x` and `y`.

    INPUT:

    - ``K`` -- a function field, with constant base field `k`
    - ``x,y`` -- elements of `K`

    OUTPUT:

    an irreducible bivariate polynomial `f` over `k` such that `f(x,y)=0`.

    EXAMPLES::

        sage: from mclf import *
        sage: K0.<x> = FunctionField(GF(2))
        sage: R.<y> = K0[]
        sage: K.<y> = K0.extension(y^2+x^3+1)
        sage: algebraic_relation(K, x, y)
        x^3 + y^2 + 1
        sage: S.<z> = K[]
        sage: L.<z> = K.extension(z^2+z+x+y)
        sage: algebraic_relation(L, z+1, y)
        x^6 + x^5 + x^4*y + x^4 + x^2*y^2 + x^3 + x^2*y + x*y^2 + y^3 + y^2 + 1

    """
    K0 = K.rational_function_field()
    k = K0.constant_base_field()
    f = minimal_polynomial(x, K0)
    g = minimal_polynomial(y, K0)
    A = PolynomialRing(k, "X, Y, T")
    X, Y, T = A.gens()
    F = bivariate_equation(f)(T, X)
    G = bivariate_equation(g)(T, Y)
    B = PolynomialRing(k, "x, y")
    X, Y = B.gens()
    h = F.resultant(G, T)(X, Y, 0).radical()
    assert len(h.factor()) == 1, "h should be irreducible!?"
    assert h(x, y).is_zero()
    return h


def bivariate_equation(f):
    r"""

    INPUT:

    - ``f`` -- an univariate polynomial over a rational function field `K=k(t)`

    OUTPUT:

    The bivariate polynomial `F\in k[t, x]` obtained from `f` by clearing the
    denominators of the coefficients of `f`.


    EXAMPLES::

        sage: from mclf import *
        sage: K.<t> = FunctionField(QQ)
        sage: R.<x> = K[]
        sage: bivariate_equation(x^3/t + (t+1)*x + t*(t-2))
        t^3 + t^2*x + x^3 - 2*t^2 + t*x

    """
    R = f.parent()
    K = R.base_ring()
    k = K.constant_base_field()
    A = PolynomialRing(k, [K.variable_name(), R.variable_name()])
    t, x = A.gens()
    d = lcm([f[i].denominator() for i in range(f.degree() + 1)])
    f = d * f
    F = sum(f[i].numerator()(t) * x**i for i in range(f.degree() + 1))
    return F


# --------------------------------------------------------------------------

# this should be outdated, or not?

def minimal_polynomial(alpha, K):
    r""" Return the minimal polynomial of `\alpha` over the field `K`.

    INPUT:

    - ``alpha`` -- an elemenent of a field `L`
    - ``K`` -- a subfield of `L` over which `\alpha` is algebraic

    OUTPUT: the minimal polynomial of `\alpha` over `K`.

    """
    L = alpha.parent()
    assert K.is_subring(L), "K must be a subfield of L"
    if K == L:
        from sage.rings.polynomial.polynomial_ring_constructor import (
            PolynomialRing)
        A = PolynomialRing(K, 'T')
        return A.gen() - alpha
    elif L.base_ring() == K:
        return alpha.minpoly('T')
    else:
        A = matrix_of_extension_element(alpha, K)
        f = A.minimal_polynomial('T')
        assert f(alpha) == 0, "Error!"
        return f


def matrix_of_extension_element(alpha, K):
    r""" Return the matrix corresponding to this element
    of the field extension.

    """
    L = alpha.parent()
    M = L.base_ring()
    if M == K:
        return alpha.matrix()
    assert K.is_subring(M), "K must be a subring of M"
    A = alpha.matrix()
    n = A.nrows()
    D = {}
    for i in range(n):
        for j in range(n):
            D[(i, j)] = matrix_of_extension_element(A[i, j], K)
    m = D[(0, 0)].nrows()
    N = n * m
    from sage.matrix.constructor import matrix
    B = matrix(K, N, N)
    for i in range(n):
        for j in range(n):
            for k in range(m):
                for ell in range(m):
                    B[i*m+k, j*m+ell] = D[(i, j)][k, ell]
    return B
