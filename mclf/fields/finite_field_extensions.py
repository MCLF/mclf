# -*- coding: utf-8 -*-
r"""
Finite field extensions
=======================

Let `K` be a *standard field* and `L/K` a finite field extension. Then
`L` is a standard field, too. Moreover, `L/K` is automatically *simple*,
i.e. generated by one element `\alpha\in L`. Fixing a choice of such a
generator, we obtain a `K`-linear isomorphism

.. MATH::

    L \cong L_{\rm rel} := K[x]/(f),

where `f\in K[x]` is the minimal polynomial of `\alpha` over `K`. We call
`K_{\rm rel}` the **relative model** of the finite extension `L/K` (depending
on the choice of the **relative generator** `\alpha`).

Representing a finite extension `L/K` by a relative model makes it very
convenient to perform certain tasks which are important for this project:

- computing characteristic and minimal polynomials, norms, traces etc.
  of elements of `L`, relative to the base field `K`,
- extending valuations from `K` to `L`,
- restricting valuations from `L` to  `K`.

In this module we implement a class :class:`FiniteExtensionOfStandardFields`
representing a finite extension `L/K` of two standard fields, which provides
access to an internal relative model and methods implementing the various
useful tasks described above.

The class :class:`FiniteExtensionOfStandardFields` is a child of the class
:class:`StandardField <mclf.fields.standard_fields.StandardField>`.
In this way, the extension `L/K` is considered as the standard field `L`,
together with an embedding of a standard subfield `K` and the choice of a
relative model `L_{rel}=K[x]/(f)`, or, in other words, as a relative extension.

There are essentially two distinct ways to create an instance of this class.
Both are accessible via the creator function :func:`finite_field_extension`.
This functions accepts as input

- an embedding of standard fields `\phi:K\to L`, where `K` and `L` are of the
  same dimension, or
- a pair `(K, f)`, where `K` is a standard field and `f` is an irreducible,
  univariate polynomial over `K`,

and returns an object of :class:`FiniteExtensionOfStandardFields`.

In the first variant, the new object will return the field `L` as the
*extension field* and the field `K` as the *relative base field* of the finite
extensions::

    sage: L_K = finite_field_extension(phi)
    sage: L_K.extension_field().is_equal(phi.Codomain())
    True
    sage: L_K.relative_base_field().is_equal(phi.Domain())
    True
    sage: L_K.embedding().is_equal(phi)
    True

The relative model of `L/K` is computed internally.

In the second variant, the input `(K, f)` determines the relative base field
`K` and the relative model `K[x]/(f)`, and the standard form of the extension
field `L` is computed internally::

    sage: L_K = finite_field_extension(K, f)
    sage: L_K.relative_base_field().is_equal(K)
    True
    sage: L_K.relative_polynomial() == f
    True

This second way of creating a finite extension can also be accessed via the
method :meth:`extension <mclf.fields.standard_fields.StandardField.extension>`
of :class:`StandardField <mclf.fields.standard_fields.StandardField>`::

    sage: K.extension(f)


Towers of finite extensions
---------------------------

Since finite extension are standard fields, it is possible to construct
arbitrary towers of finite extensions iteratively. For instance, we can do the
following::

    sage: K0 = standard_field(QQ)
    sage: x = K0.polynomial_generator("x")
    sage: K1 = K0.extension(x^2 - 2, "a")
    sage: a = K1.generator()
    sage: K2 = K1.extension(x^2 - a, "b"); K2
    Number Field in b with defining polynomial x^4 - 2, as finite extension
    of Number Field in a with defining polynomial x^2 - 2

    sage: K2.relative_base_field()
    Number Field in a with defining polynomial x^2 - 2, as finite extension of
    Rational Field

We call `K_2/K_1/K_0` an **extension tower**; it is realized implicitely as
an iteration of finite simple extensions; there is no explicit realization
as a class.

We can construct the total extension `K_2/K_0` via ::

    sage: K2.as_extension_of(K0)

The method :meth:`as_extension_of <FiniteExtensionOfStandardFields.\
as_extension_of>` any step of the extension tower below `K_2`. The possible
candidates can be obtained via the method
:meth:`iterated_relative_base_fields <FiniteExtensionOfStandardFields.\
iterated_relative_base_fields>`::

    sage: K2.iterated_relative_base_fields()
    [Number Field in a with defining polynomial x^2 - 2, as finite extension of
     Rational Field,
     Rational Field as a standard field]


.. TODO::

    - implement superextensions and subextensions; in particular, the method
      :meth:`as_extension_of`


EXAMPLES::

    sage: from mclf import *
    sage: k0 = GF(2); k1 = GF(4)
    sage: k1_k0 = finite_field_extension(k0.hom(k1))
    sage: k1_k0
    Finite Field in z2 of size 2^2, as finite extension of Finite Field
    of size 2

The base field and the extension field of a standard extensions can be accessed
via the methods :meth:`domain` and :meth:`codomain`.::

    sage: k1_k0.domain()
    Finite Field of size 2
    sage: k1_k0.codomain()
    Finite Field in z2 of size 2^2

We can check the degree of a finite extension.::

    sage: k1_k0.relative_degree()
    2

A finite extension has a generator and a polynomial; these define the
standard model of the extension.::

    sage: k1_k0.relative_generator()
    z2
    sage: k1_k0.relative_polynomial()
    x^2 + x + 1

We can compose finite extensions, and compute subextensions with given
generators.::

    sage: k2 = GF(16)
    sage: k2_k1 = finite_field_extension(k1.hom(k2))
    sage: k2_k0 = k1_k0.superextension(k2_k1)
    sage: k2_k0

    sage: k2_k0.subextension(k1.gen())

We can also compute the base change of an extension with respect to another
one.::

    sage: k2_k0.base_change(k1_k0)


A finite extension can also be defined via an injective field homomorphism.::

    sage: K.<x> = FunctionField(k0)
    sage: phi = K.hom([x^2+x])
    sage: K_K = finite_field_extension(phi)
    sage: K_K
    Rational function field in x over Finite Field of size 2,
    as finite extension of Rational function field in x over Finite Field
    of size 2
    sage: K_K.relative_generator()
    x
    sage: K_K.relative_polynomial()
    T^2 + T + x

"""

from mclf.fields.standard_fields import (
    standard_field, StandardField, StandardFiniteField, StandardNumberField,
    StandardFunctionField)
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.all import lcm


def finite_field_extension(*args):
    r""" Return the finite field extension determined by the input.

    INPUT:

    - ``args`` -- data determining a finite field extension `L/K`

    OUTPUT: a Sage object representing the finite field extension `L/K`.

    The arguments may be

    - an injective field morphism `\phi:L\to K`, or
    - a pair `(K, f)`, where `K` is a standard field and `g` is a univariate
      irreducible polynomial over `K`.
    - a tripel `(K, f, a)`, where `(K, f)` is as above, and `a` is an
      alphanumeric string.

    Here the fields `K` and `L` are assumed to be standard fields; they may be
    either objects of the Sage category ``Fields`` or instances of
    :class:`StandardField`.

    In the first case, the result is the finite field extension determined by
    `\phi`. In particular, the extension field is equal to the codomain of
    `\phi`, whereas the relative model is computed internally.

    In the second and third case, the input determines the relative base field
    `K` and relative model `K[x]/(f)`, and the (standard form of) the extension
    field `L` is computed internally.

    In the third case, we use ``a`` for the name of the generator of the
    relative model. If ``a`` is not given, we use the variable name of the
    polynomial `f` instead.

    """
    if len(args) == 1:
        phi = args[0]
        return finite_field_extension_from_embedding(phi)
    elif len(args) == 2:
        return finite_field_extension_from_polynomial(args[0], args[1])
    elif len(args) == 3:
        return finite_field_extension_from_polynomial(args[0], args[1], args[2])
    else:
        raise TypeError("Wrong number of parameters")


def trivial_extension(K):
    r""" Return the standard field `K` as a finite extension of itself.

    INPUT:

    - ``K`` -- a standard field

    OUTPUT:

    The standard field `K` as a finite extension of itself.

    The convention is that the relative generator of the trivial extension
    `K/K` is `1`, hence the relative polynomial is `T - 1`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = trivial_extension(QQ); K
        Rational Field, as finite extension of Rational Field
        sage: K.relative_generator()
        1
        sage: K.relative_polynomial()
        T - 1
        sage: K.relative_model()
        Number Field in T with defining polynomial T - 1
        sage: K.relative_norm(1)
        1

    """
    if not isinstance(K, StandardField):
        K = standard_field(K)
    T = K.polynomial_generator("T")
    return finite_field_extension_from_polynomial(K, T - 1)
    raise NotImplementedError()


def finite_field_extension_from_embedding(phi):
    r""" Return the finite field extension given by an embedding of
    standard fields.

    INPUT:

    - ``phi`` -- an embedding `\phi:K\to L` of standard fields

    OUTPUT:

    the finite fields extension `L/K`, as an instance of
    :class:`FiniteExtensionOfStandardField`.

    If `L/K` is not finite, an error is raised.

    ALGORITHM:

    Our goal is to construct a finite simple extension `M/K` and a `K`-linear
    isomorphism `\psi:L\to M` which is a left inverse of this embedding
    `\phi:K\to L`.

    Let

    .. MATH::

        L_0\subset L_1\subset\ldots \subset L_r=L

    be the natural sequence of subfield of `L` such that `L_i/L_{i-1}`
    is a simple extension, generated by one element `\alpha_i\in L_i`.
    Since `L_0` is the common prime field of `K` and `L`, we have a unique
    embedding `\psi_0:L_0\to K` which is a right inverse of `\phi`.

    We construct inductively a sequence of finite simple extensions
    `M_0=K\subset M_1\subset\ldots \subset M_r` and embeddings

    .. MATH::

        \phi_i: M_i\hookrightarrow L, \quad \psi_i: L_i \hookrightarrow M_i, \
            \quad i=1,\ldots,r,

    such that

    - the restriction of `\phi_i` to `K=M_0` is equal to `\phi`,
    - the restriction of `\psi_i` to `L_{i-1}` is equal to `\psi_{i-1}`,
    - each `\phi_i` is a let inverse of `\psi_i`.

    Then `M:=M_r` is a finite extension of `K` and `\psi:=\psi_r:L\to M` and
    `\phi_r:M\to L` are mutually inverse, is `K`-linear isomorphisms.

    The last step is to collapse the extension `M/K`, which is a tower of
    simple extension, to a single simple extension. This is also done
    inductively, using the method
    :meth:`FiniteExtensionOfStandardFields.superextension`.


    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_rational_function_field(GF(2), "t")
        sage: k = standard_finite_field(4)
        sage: x, y = k.polynomial_generators(["x", "y"])
        sage: L = standard_function_field(x^3 + y^2)
        sage: x, y = L.generators()
        sage: phi = K.hom(L, x + y)
        sage: L = finite_field_extension_from_embedding(phi); L
        Function field in y defined by y^2 + x^3, as finite extension of
        Rational function field in t over Finite Field of size 2

        sage: L.relative_generator()
        (x + z2 + 1)*y + x^2 + z2*x

        sage: L.relative_polynomial()
        T^6 + t*T^5 + (t + 1)*T^4 + t^3*T^3 + (t^6 + t^5 + t^4 + t^2)*T^2
        + (t^7 + t^6 + t^4)*T + t^10 + t^5 + t^4

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        EmbeddingOfStandardFields, embedding_of_standard_fields)
    if not isinstance(phi, EmbeddingOfStandardFields):
        phi = embedding_of_standard_fields(phi)
    assert phi.is_finite_extension()

    # initialization:
    K = phi.Domain()                # K and L are in StandardFields!
    L = phi.Codomain()
    M = K.as_extension_of_itself()  # M is the trivial extension of K
    L0 = L.prime_subfield()         # L0, L1 are natural subfields of L
    L0_to_M = L0.hom(M)             # there is a unique embedding
    M_to_L = phi

    # we walk through the tower of natural subfields of L;
    # in each step we create a finite simple extension M1/M corresponding to
    # the finite intermediate extension L1/L0
    for L1 in L.natural_subfields()[1:]:
        if L1.is_function_field() and L1.is_rational_function_field():
            assert L1.constant_base_field().is_equal(L0)
            # L1/L0 is a rational function field
            M1, L1_to_M1, M1_to_L = lift_embedding_to_rational_function_field(
                M, L0_to_M, L1, M_to_L)
        else:
            f = L1.polynomial()
            alpha = L1.generator()
            # L1/L0 is finite, f the minimal polynomial of the gen alpha
            M1, L1_to_M1, M1_to_L = lift_embedding_to_finite_simple_extension(
                M, L0_to_M, L1, alpha, f, M_to_L)
            # now M1/k is a finite simple extension
        # replace M/K with M1/M/K
        M, M1_to_M, M_to_M1 = M.composition_with_superextension(M1)
        L0 = L1
        L0_to_M = L1_to_M1.post_compose(M1_to_M)
        M_to_L = M_to_M1.post_compose(M1_to_L)

    # end of loop; L0 = L, so M and M_to_L are what we want; moreover:
    L_to_M = L0_to_M

    if K.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M, L_to_M, M_to_L)
    elif K.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M, L_to_M, M_to_L)
    elif K.is_function_field():
        return FiniteExtensionOfFunctionFields(phi, M, L_to_M, M_to_L)
    else:
        raise NotImplementedError()


def lift_embedding_to_rational_function_field(
        K, L0_to_K, L1, K_to_L):
    r""" Helper function for :meth:`finite_field_extension_from_embedding`.

    INPUT:

    - ``K`` -- a standard_function_field
    -  ``L0_to_K`` an embedding of standard fields `\psi_0:L_0\to K`
    - ``L1`` -- a rational function field over L0,
      as a subfield of a standard field `L`
    - ``K_to_L`` -- an embedding `\phi_0:K\to L`

    It is assumed that the composition `\phi_0\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M, \psi_1, \phi_1)`, where

    - `M/K` is a finite simple extension
    - `\psi_1:L_1\to M` is an extension of `\psi_0:L_0\to K`
    - `\phi_1:M\to L` is an extension of `\phi_0:K\to L`,

    and such that `\phi_1\circ\psi_1:L_1\to L` is the natural inclusion.

    EXAMPLES::

        sage: from mclf import *
        sage: k = standard_finite_field(2)
        sage: K = standard_rational_function_field(k, "x")
        sage: x = K.generator()
        sage: phi0 = K.hom(K, x^2 + x)
        sage: psi0 = k.hom(K)
        sage: L = K.as_subfield_of_itself()
        sage: M, psi, phi = lift_embedding_to_rational_function_field(K,
            psi0, L, phi0)
        sage: M
        Function field in y defined by y^2 + y + x, as finite extension of
        Rational function field in x over Finite Field of size 2

    """
    L = L1.Overfield()
    t = L1.generator()
    x = K.generators()[0]
    x1 = K_to_L(x)
    f = L.algebraic_relation(x1, t)
    f_K = L0_to_K.change_coefficients(f)
    # we have f(phi(x), t) = 0
    # we need an extension M/K containing an element beta
    # such that phi(beta) = t, then we would have
    # f_K(x, beta) = 0; this leaves only finitely many possibilities
    # for beta
    _, T = f_K.parent().gens()
    f_K = f_K(x, T).univariate_polynomial()
    for g in K.prime_factors(f_K):
        g_L = K_to_L.change_coefficients(g)
        if g_L(t).is_zero():
            M = K.extension(g)
            beta = M.relative_generator()
            M_to_L = M.relative_hom(L, t, K_to_L)
            L1_to_M = L1.hom(M, beta, L0_to_K)
            assert L1_to_M.post_compose(M_to_L).is_equal(L1.embedding())
            return M, L1_to_M, M_to_L
    # if we get here, something went wrong
    raise AssertionError()


def lift_embedding_to_finite_simple_extension(
        M, L0_to_M, L1, alpha, f, M_to_L):
    r""" Helper function for :meth:`finite_field_extension_from_embedding`.

    INPUT:

    - ``M`` -- a finite field extension `M/K`
    - ``L0_to_M`` an embedding of standard fields `\psi_0:L_0\to M`
    - ``L1`` -- a finite field extension over L0, which is a natural
      subfield of `L`
    - `alpha` -- the generator of `L_1/L_0`
    - `f` -- the minimal polynomial of `\alpha` over `L_0`
    - ``M_to_L`` -- an embedding `\phi:M\to L`

    It is assumed that the composition `\phi\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M_1, \psi_1, \phi_1)`, where

    - `M_1/M` is a finite simple extension
    - `\psi_1:L_1\to M_1` is an extension of `\psi_0:L_0\to M`
    - `\phi_1:M_1\to L` is an extension of `\phi:M\to L`,

    and such that `\phi\circ\psi_1:L_1\to L` is the natural inclusion.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(QQ)
        sage: x = K.polynomial_generator("x")
        sage: M = K.extension(x^2 - 2, "a")
        sage: a = M.relative_generator()
        sage: f = M.relative_polynomial()
        sage: L0_to_M = K.hom(M)
        sage: L1 = M
        sage: M_to_L = M.hom(M, -a)
        sage: M1, psi1, phi1 = lift_embedding_to_finite_simple_extension(
            M, L0_to_M, L1, a, f, M_to_L)
        sage: psi1
        the embedding of Number Field in a with defining polynomial x^2 - 2
        into Number Field in a with defining polynomial x^2 - 2,
        sending a to -a

    """
    L = M_to_L.Codomain()
    f_M = L0_to_M.change_coefficients(f)
    found_factor = False
    for g in M.prime_factors(f_M):
        g_L = M_to_L.change_coefficients(g)
        if g_L(alpha).is_zero():
            factor_found = True
            M1 = M.extension(g)
            M1_to_L = M1.relative_hom(L, alpha, M_to_L)
            L0_to_M1 = L0_to_M.post_compose(M1.embedding_of_base_field())
            L1_to_M1 = L1.hom(M1, M1.relative_generator(), L0_to_M1)
    assert factor_found, "something went wrong"
    return M1, L1_to_M1, M1_to_L


def finite_field_extension_from_polynomial(K, f, gen_name=None):
    r""" Return the finite field extension given by an irreducible polynomial.

    INPUT:

    - ``K`` -- a standard field
    - ``f`` -- an univariate polynomial, irreducible over `K`
    - ``gen_name`` -- an alphanumeric string (optional)

    OUTPUT:

    the finite field extension `L:=K[x]/(f)` over `K`. If ``gen_name`` is
    given, it is used for the name of the generator of `L/K`.


    EXAMPLES::

        sage: from mclf import *
        sage: R.<x> = QQ[]
        sage: K = standard_number_field(x^2-2, "a")
        sage: a = K.generator()
        sage: finite_field_extension_from_polynomial(K, x^2 - a, "b")
        Number Field in b with defining polynomial x^4 - 2, as finite
        extension of Number Field in a with defining polynomial x^2 - 2

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        embedding_of_standard_fields)
    from mclf.fields.standard_fields import homomorphism_on_standard_field
    if not isinstance(K, StandardField):
        K = standard_field(K)
    f = K.change_coefficients(f)
    if gen_name is None:
        gen_name = f.variable_name()

    M = K.standard_model().extension(f, gen_name)
    if f.degree() == 1:
        L = K
        phi = K.hom(L)
        L_to_M = homomorphism_on_standard_field(L.standard_model(), M)
        # L_to_M = L.standard_model().hom(M)
        M_to_L = homomorphism_on_standard_field(M, L.standard_model(),
                                                -f[0]/f[1], phi)
        # M_to_L = M.hom([-f[0]/f[1]], phi)
    else:
        L = standard_field(M)
        phi = K.hom(L)
        L_to_M = L.to_original_model()
        M_to_L = L.from_original_model()

    if K.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M, L_to_M, M_to_L)
    elif K.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M, L_to_M, M_to_L)
    elif K.is_function_field():
        return FiniteExtensionOfFunctionFields(phi, M, L_to_M, M_to_L)
    else:
        raise NotImplementedError()


class FiniteExtensionOfStandardFields(StandardField):
    r""" An object representing a finite extension of a standard field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    To create an instance of this class you should use the function
    :func:`finite_field_extension`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(GF(4))
        sage: x = K.polynomial_generator("x")
        sage: f = x^3 + x^2 + x + K.generator() + 1
        sage: L = finite_field_extension(K, f); L
        Finite Field in z6 of size 2^6, as finite extension of Finite Field
        in z2 of size 2^2

    We may view `L` has a standard field.::

        sage: L.standard_model()
        Finite Field in z6 of size 2^6

    Internally, the extension is represented by a "relative model"::

        sage: L.relative_model()
        Univariate Quotient Polynomial Ring in x over Finite Field in z2
        of size 2^2 with modulus x^3 + x^2 + x + z2 + 1

    Viewing `L` as a relative extension, it is defined by its *relative base
    field* (also identical to the *domain*), the *relative generator*, and the
    *relative polynomial* (which is the relative minimal polynomial of the
    relative generator).::

        sage: L.relative_base_field()
        the standard field with 4 elements
        sage: L.relative_generator()
        z6
        sage: L.relative_polynomial()
        x^3 + x^2 + x + z2 + 1


    """

    def __init__(self, phi, M, s, t):
        from mclf.fields.embeddings_of_standard_fields import (
            EmbeddingOfStandardFields)
        if not isinstance(phi, EmbeddingOfStandardFields):
            phi = embedding_of_standard_fields(phi)
        K = phi.Domain()
        L = phi.Codomain()
        self._relative_base_field = K
        self._extension_field = L
        self._embedding = phi

        # we initialize this extension as a standard field
        if K.is_finite():
            StandardFiniteField.__init__(self, L)
        elif K.is_number_field():
            StandardNumberField.__init__(self, L)
        elif K.is_function_field():
            StandardFunctionField.__init__(self, L)

        self._relative_generator = t(M.gen())
        if hasattr(M, "relative_polynomial"):
            self._relative_polynomial = M.relative_polynomial()
        elif hasattr(M, "polynomial"):
            self._relative_polynomial = M.polynomial()
        elif hasattr(M, "modulus"):
            self._relative_polynomial = M.modulus()
        else:
            raise TypeError("M is not of the correct type")
        self._relative_model = M
        self._to_relative_model = s
        self._from_relative_model = t

    def __repr__(self):
        return "{}, as finite extension of {}".format(self.codomain(),
                                                      self.domain())

    def relative_base_field(self):
        r""" Return the relative base field of this finite extension.

        Note that we return an instance of the class :class:`StandardField`.
        """
        return self._relative_base_field

    def domain(self):
        r""" Return the standard model of the relative base field; it is the
        domain of the embedding defining this standard extension.
        """
        return self.relative_base_field().standard_model()

    def extension_field(self):
        r""" Return the extension field of this finite extension.

        """
        return self._extension_field

    def codomain(self):
        r""" Return the standard model of the extension field; it is the
        codomain of the embedding defining this standard extension.
        """
        return self.standard_model()

    def embedding_of_base_field(self):
        r""" Return the embedding of the base field into the extension field.

        """
        return self._embedding

    def relative_model(self):
        r""" Return the relative model of this finite field extension.

        """
        return self._relative_model

    def to_relative_model(self):
        r""" Return the isomorphism from the extension field
        to the relative model.

        """
        return self._to_relative_model

    def from_relative_model(self):
        r""" Return the isomorphism from the relative model to the
        standard model of the extension field.

        """
        return self._from_relative_model

    def relative_degree(self):
        r""" Return the degree of this field extension.

        This must be implemented by the subclass.
        """
        return self.relative_polynomial().degree()

    def relative_polynomial(self):
        r""" Return the polynomial corresponding to the standard model of this
        extension.

        """
        return self._relative_polynomial

    def relative_generator(self):
        r""" Return the generator of this finite extension.

        """
        return self._relative_generator

    def relative_minpoly(self, t, var_name="T"):
        r""" Return the minimal polynomial of this element over the base field
        of this finite extension.

        INPUT:

        - `t` -- an element of the extension field `L`
        - ``varname`` -- an alphanumeric string (default: "T")

        OUTPUT:

        The minimal polynomial of `t` over the relative base field `K`.

        If ``var_name`` is not given, we use the letter "T" as a default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F0 = standard_rational_function_field(k, "x")
            sage: x = F0.generator()
            sage: y = F0.polynomial_generator("y")
            sage: F = F0.extension(y^3 + x^4 + x + 1)
            sage: y = F.relative_generator()
            sage: F.relative_minpoly(y + x)
            T^3 + x*T^2 + x^2*T + x^4 + x^3 + x + 1

        """
        return self.to_relative_model()(t).minpoly().\
            change_variable_name(var_name)

    def relative_norm(self, a):
        r""" Return the norm of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the norm of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: K = standard_finite_field(4)
            sage: a = K.polynomial_generator("a")
            sage: L = K.extension(a^2 + a + K.generator())
            sage: a = L.relative_generator()
            sage: L.relative_norm(a)
            z2

        """
        return self.to_relative_model()(a).norm()

    def relative_trace(self, a):
        r""" Return the trace of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the trace of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 + x + 1, "a")
            sage: b = K.polynomial_generator("b")
            sage: L = K.extension(b^3 + b^2 + K.generator() + 1)
            sage: L.relative_trace(L.generator())
            -2

        """
        return self.to_relative_model()(a).trace()

    def relative_charpoly(self, a, var_name="T"):
        r""" Return the characteristic polynomial of an element under this
        finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension
        - ``var_name`` -- an alphanumeric string (default: "T")

        OUTPUT:

        the characteristic polynomial of `a` with respect to this finite field
        extension `L/K`.

        If ``var_name`` is not given, we choose the letter "T" by default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F = standard_rational_function_field(k, "x")
            sage: x = F.generator()
            sage: phi = F.hom(F, x^2 + 1)
            sage: FF = finite_field_extension(phi)
            sage: FF.relative_charpoly(x)

        """
        return self.to_relative_model()(a).charpoly().\
            change_variable_name(var_name)

    def relative_hom(self, M, beta, *phi0):
        r""" Return the homomorphism to another field extending a base
        homomorphism, given by the image of the relative generator.

        INPUT:

        - ``M`` -- a field
        - ``beta`` -- an element of M
        - ``phi0`` -- an embedding `\phi_0:K\to M` of the relative base field
                      of this extension `L/K` into M

        OUTPUT:

        the homomorphism `\phi:L\to M` extending `\phi_0` sending
        the relative generator `\alpha` of `L/K` to `\beta`.

        Such an embedding exists iff `\beta` is a root of the image of
        the minimal polynomial of `\alpha` under `\phi_0`. If this is not
        true, an error is raised.

        If `\phi_0` is omitted, `K` must be a subfield of `M` and then we
        let `\phi_0:K\to M` be the natural inclusion.

        The field `M` may be given as a Sage field, or as an instance of
        the mclf class
        :class:`EmbeddingOfStandardFields <mclf.fields.standard_fields.EmbeddingOfStandardFields>`.


        EXAMPLES::

            sage: from mclf import *
            sage: K = GF(2)
            sage: L = GF(4)
            sage: L_K = finite_field_extension(K.hom(L))
            sage: alpha = L_K.relative_generator()
            sage: L_K.relative_hom(L, alpha + L.one())
            the embedding of Finite Field in z2 of size 2^2 into Finite Field
            in z2 of size 2^2, sending z2 to z2 + 1

        """
        K = self.domain()
        f = self.relative_polynomial()
        # make sure beta lies in M
        beta = M(beta)
        # turn M into a bare field
        if isinstance(M, StandardField):
            M = M.standard_model()

        if len(phi0) == 0:
            # phi0 was omitted from the input
            if not K.is_subring(M):
                print("L_K = ", self)
                print("K = ", K)
                print("M = ", M)
            assert K.is_subring(M), "the base field must be a subfield of M"
            phi0 = K.hom(M)
        elif len(phi0) == 1:
            phi0 = phi0[0]
            assert K.is_subring(phi0.domain())
            assert phi0.codomain().is_subring(M)
        else:
            raise ValueError("Wrong number of parameters")

        # check existence
        f_M = f.map_coefficients(phi0, M)
        assert f_M(beta).is_zero(), "the homomorphism doesn't exist"

        from mclf.fields.standard_fields import (
            homomorphism_on_standard_field)
        phi1 = homomorphism_on_standard_field(self.relative_model(),
                                              M, [beta], phi0)
        phi = self.to_relative_model().post_compose(phi1)
        from mclf.fields.embeddings_of_standard_fields import (
            embedding_of_standard_fields)
        return embedding_of_standard_fields(phi)

    def iterated_relative_base_fields(self):
        r""" Return the list of all iterated relative base fields of this
        extension.

        """
        K = self.relative_base_field()
        if isinstance(K, FiniteExtensionOfStandardFields):
            return [K] + K.iterated_relative_base_fields()
        else:
            return [K]

    def as_extension_of(self, K0):
        r""" Return this extension field as a finite simple extension of `K_0`.

        INPUT:

        - ``K0`` -- a standard field of which this field `K` is a finite
          extension

        To determine whether and how `K` is a finite extension of `K_0` we
        proceed as follows:

        1. we check is `K_0` is a subfield of `K`, as an instance of
           :class:`StandardSubfield <mclf.field.standard_subfields.\
           StandardSubfield`,

        2. we check whether `K_0` occurs in the list of iterated relative base
           fields of `K`, via the method :meth:`iterated_relative_base_fields`.


        OUTPUT:

        the finite extension `K/K_0`, as an instance of
        :class:`StandardFiniteFieldExtension`.

        """
        if isinstance(K0, StandardSubfield):
            assert K0.Overfield().is_equal(self)
            phi = K0.embedding()
            assert phi0.is_finite_extension()
            return finite_field_extension(phi)
        elif isinstance(K0, StandardField):
            assert any(K0.is_equal(base_field)
                       for base_field in self.iterative_relative_base_field())
            # it is tempting to just compute the embedding of K0 into K
            # and then apply "finite_field_extension_from_embedding", but
            # this is circular and would lead to an infinite loop
            raise NotImplementedError()
        else:
            raise TypeError()

    def composition_with_superextension(self, M):
        r""" Return the composition of this extension with a superextension.

        INPUT:

        - ``M`` -- a finite extension `M/L` of this extension `L/K`

        OUTPUT:

        A triple `(N, s, t)`, where `N/K` is a finite simple extension,
        `s:M\to N` is a `K`-linear isomorphism and `t` is the inverse of `s`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 - 2, "a")
            sage: a = K.generator()
            sage: L = K.extension(x^2 - a, "b")
            sage: b = L.relative_generator()
            sage: M = L.extension(x^2 - b, "c")
            sage: N, s, t = L.composition_with_superextension(M)

        """
        from mclf.fields.standard_fields import homomorphism_on_standard_field
        # fix some notation
        K = self.relative_base_field()
        L = self
        assert M.relative_base_field().is_equal(L)
        L_to_M = M.embedding_of_base_field()
        K_to_M = L.embedding_of_base_field().post_compose(L_to_M)

        # we need to work with the relative model of L
        L_rel = L.relative_model()
        L_rel_to_M = homomorphism_on_standard_field(
            L_rel, M.standard_model(), L_to_M(L.relative_generator()), K_to_M)

        # we first find an element gamma in M which generates M/K
        # for this we use the method `primitive_element` associated
        # to a Sage function field
        g = M.relative_polynomial().map_coefficients(
            L.to_relative_model(), L_rel)
        M1 = L_rel.extension(g, g.variable_name()+"1")
        M1_to_M = homomorphism_on_standard_field(M1, M.standard_model(),
                                                 M.relative_generator(),
                                                 L_rel_to_M)
        # M1_to_M = M1.hom([M.relative_generator()], base_map=L_to_M)
        gamma = M1_to_M(M1.primitive_element())

        # we compute the minimal polynomial g of gamma over K
        f = M.minimal_polynomial(gamma)  # the minpoly over the prime field
        for g in K.prime_factors(f):
            g_M = g.map_coefficients(K_to_M, M.standard_model())
            if g_M(gamma).is_zero():
                N = finite_field_extension_from_polynomial(K, g)
                N_to_M = N.relative_hom(M, gamma, K_to_M)
                M_to_N = N_to_M.inverse()
                return N, M_to_N, N_to_M
        # if we get here, something went wrong
        raise AssertionError()

    def restriction_of_valuation(self, w):
        r""" Compute the restriction of a valuation from the codomain to the
        domain of this field extension.

        INPUT:

        - ``w`` -- a valuation on the codomain `L` of this extension

        OUTPUT:

        the restriction `v:=w|_K` to the domain `K` of this extension.

        This method must be implemented by the appropriate subclass.

        .. NOTE::

            It is not clear if this method is very useful. The algorithm for
            computing the restriction depends more on the type of the fields
            `K` and `L`, and on the nature of the valuation, and not so much
            on the type of the extension `L/K`. Therefore, these algorithms
            should rather be implemented by the appropriate subclasses of
            :class:`ValuedField`.

        """
        raise NotImplementedError()


# the following subclasses are only defined to be consitent with inheritance.
# For instance, we only need the class `FiniteExtensionOfFiniteField` so that
# its instances inherit the special methods from `StandardFiniteField` which
# are distinct from and not defined on `StandardField`.


class FiniteExtensionOfFiniteFields(
        FiniteExtensionOfStandardFields, StandardFiniteField):
    r""" An object representing a finite extension of a finite field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardFiniteField <mclf.fields.standard_fields.\
        StandardFiniteField>`.

    """


class FiniteExtensionOfNumberFields(FiniteExtensionOfStandardFields,
                                    StandardNumberField):
    r""" An object representing a finite extension of a number field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardNumberField <mclf.fields.standard_fields.\
        StandardNumberField>`.


    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(CyclotomicField(3, "theta"))
        sage: x = K.polynomial_generator("x")
        sage: f = x^3 - K.generator()
        sage: L = finite_field_extension(K, f); L
        Number Field in x with defining polynomial x^6 + x^3 + 1,
        as finite extension of Cyclotomic Field of order 3 and degree 2

    We may view `L` has a standard field.::

        sage: L.standard_model()
        Number Field in x with defining polynomial x^6 + x^3 + 1

        sage: L.original_model()
        Number Field in x with defining polynomial x^3 - theta
        over its base field

    Viewing `L` as a relative extension, it is defined by its
    *relative base field* (also identical to the *domain*), the
    *relative generator*, and the *relative polynomial* (which is the
    relative minimal polynomial of the relative generator).::

        sage: L.relative_base_field()
        Cyclotomic Field of order 3 and degree 2 as a standard field
        sage: L.relative_generator()
        x
        sage: L.relative_polynomial()
        x^3 - theta

    """


class FiniteExtensionOfFunctionFields(FiniteExtensionOfStandardFields,
                                      StandardFunctionField):
    r""" An object representing a finite extension of a function field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    .. NOTE::

        This class is only defined so that its instances inherit methods from
        both its two parent classes, :class:`FiniteExtensionOfStandardFields`
        and :class:`StandardFunctionField <mclf.fields.standard_fields.\
        StandardFunctionField>`.

    """

# ----------------------------------------------------------------------------


def relative_model_of_finite_extension(phi):
    r""" Return the relative model of a finite field extension.

    INPUT:

    - ``phi`` -- an embedding of fields `\phi:K\to L` which makes `L` a finite
                 extension of `K`

    The embedding `\phi` must be an instance of the class
    :class:`EmbeddingOfStandardFields <mclf.fields.\
    embeddings_of_standard_fields.EmbeddingOfStandardFields>`.

    OUTPUT:

    a tripel `(M, s, t)`, where `M` is a finite simple field extension of `K`,
    `s:L\to M` is a `K`-linear isomorphism, and `t:M\to L` is the inverse
    of `s`.

    Note that `M` is a base Sage field, not an instance of
    :class:`StandardField <mclf.fields.standard_fields.StandardField`.
    So `L` above refers to the standard model of the standard field `L`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_finite_field(4)
        sage: L = standard_finite_field(16)
        sage: phi = K.hom(L)
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        Univariate Quotient Polynomial Ring in xbar over Finite Field
        of size 2 with modulus x^4 + x + 1

        sage: K = standard_field(CyclotomicField(3))
        sage: L = standard_field(CyclotomicField(9))
        sage: phi = K.hom(L)
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        Number Field in x with defining polynomial x^3 - zeta3
        over its base field

    """
    K = phi.Domain()       # K and L are in `StandardField` !
    L = phi.Codomain()

    if K.is_finite():
        assert L.is_finite(), "If the domain is finite,\
                the codomain must be, too"
        # Since L has one absolute generator, we can use it as a relative
        # generator, too. We just have to find the correct irreducible factor g
        # of its minimal polynomial f over K.
        # However, for finite fields any factor will do! This is because
        # f completely splits over L, and we can take any root of the factor g
        # as a relative generator.
        f = L.polynomial()
        g = K.prime_factors(f)[0]
        alpha = L.roots(g)[0]
        # now L is iso to  M:=K[alpha |g(alpha)=0]
        # we construct M and the isomorphisms

        # for some types of finite fields, the method "extension" is not
        # available; so we create directly the quotient of a polynomial ring
        # the problem is that M will not have the method "polynomial";
        # we have to use "modulus" instead
        M = f.parent().quotient_by_principal_ideal(f)
        M_to_L = M.hom([alpha], L.standard_model())
        L_to_M = L.standard_model().hom([M.gen()])
        return M, L_to_M, M_to_L

    elif K.is_number_field():
        assert L.is_number_field(), "If the domain is a number field,\
            the codomain must be, too"
        # Again we let f be the minimal pol of the fixed absolute generator
        alpha = L.generator()
        f = L.polynomial()
        factors_of_f = K.prime_factors(f)
        # we find the factor which has alpha as a root and use it construct
        # the relative model of L/K
        for g in factors_of_f:
            g_L = g.map_coefficients(phi, L.standard_model())
            if g_L(alpha).is_zero():
                M = K.standard_model().extension(g, f.variable_name())
                M_to_L = M.hom([alpha], L.standard_model())
                L_to_M = L.standard_model().hom([M.gen()])
                return M, L_to_M, M_to_L
        # if we get here, something went wrong
        raise AssertionError("Couldn't find the correct irreducible factor")

    elif K.is_function_field():
        assert L.is_function_field(), "If the domain is a function field,\
            the codomain must be, too"
        return relative_model_of_finite_extension_of_function_fields(phi)


def relative_model_of_finite_extension_of_function_fields(phi):
    r""" Return the relative model of a finite extension of function fields.

    INPUT:

    - ``phi`` -- an embedding of function fields `\phi:K\to L`

    The embedding `\phi` may be given as a Sage morphism between
    fields, or as an instance of the class
    :class:`EmbeddingOfFunctionFields <mclf.fields.\
    embeddings_of_standard_fields.EmbeddingOfFunctionField`.

    OUTPUT:

    a tripel `(M, s, t)`, where `M` is a finite simple field extension of `K`,
    `s:L\to M` is a `K`-linear isomorphism, and `t:M\to L` is the inverse
    of `s`.

    EXAMPLES::

        sage: from mclf import *
        sage: k0 = standard_field(QQ)
        sage: K = standard_rational_function_field(k0, "x")
        sage: k = standard_field(CyclotomicField(5))
        sage: zeta = k.generator()
        sage: L = standard_rational_function_field(k, "y")
        sage: y = L.generator()
        sage: phi = K.hom(L, [y^2+y + zeta])
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        (Function field in T defined by zeta1^8 + 4*zeta1^7 +
        (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x - 1)*zeta1^4
         + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 +
         (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3 + x^2 + x + 1,
         Function Field morphism:
           From: Rational function field in y over Cyclotomic Field of order 5 and degree 4
           To:   Function field in zeta1 defined by zeta1^8 + 4*zeta1^7 + (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x -
         1)*zeta1^4 + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 + (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3
         + x^2 + x + 1
            Defn: y |--> zeta1
               zeta |--> zeta1,
         Function Field morphism:
           From: Function field in zeta1 defined by zeta1^8 + 4*zeta1^7 + (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x -
         1)*zeta1^4 + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 + (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3
         + x^2 + x + 1
           To:   Rational function field in y over Cyclotomic Field of order 5 and degree 4
           Defn: zeta1 |--> y
                 zeta1 |--> zeta
                 x |--> y^2 + y + zeta)

    The following caused an error in a previous version. The fix is not very
    satisfying, though. The introduction of the new variable a1 is quite
    superfluous.::

        sage: R.<a> = QQ[]
        sage: K.<a> = NumberField(a^2-2)
        sage: F.<x> = FunctionField(K)
        sage: phi = F.hom([x])
        sage: relative_model_of_finite_extension(phi)
        (Function field in a1 defined by a1 - x,
         Function Field morphism:
           From: Rational function field in x over Number Field in a
                 with defining polynomial a^2 - 2
           To:   Function field in a1 defined by a1 - x
           Defn: x |--> x
                 a |--> a,
         Function Field morphism:
           From: Function field in a1 defined by a1 - x
           To:   Rational function field in x over Number Field in a
                 with defining polynomial a^2 - 2
           Defn: a1 |--> x
                 a1 |--> a
                  x |--> x)


    """
    K = phi.Domain()       # K and L are in `StandardFunctionField` !
    L = phi.Codomain()

    # what do I need precisely here?
    # k, k_to_K, k_to_L = phi.common_subfield()
    # k is a subfield of L!

    L0 = L.prime_field()
    M = K.standard_model()
    M_to_L = phi
    L0_to_M = L0.hom(M)
    for L1, _, _ in L.structure():
        M, iota, M_to_L, L1_to_M = extend_embedding(
            M_to_L, K, L0, L1, L0_to_M)
        L0 = L1
        L0_to_M = L1_to_M
    return M, L0_to_M, M_to_L


def first_subextension(K0, K):
    r""" Return the smallest nontrivial subextension of K/K_0.

    INPUT:

    - ``K0``, ``K`` -- fields, where `K/K_0` is a finitely generated, nontrivial
                       extension

    OUTPUT:

    a subfield `K_1` of `K`, where `K_1/K_0` the smallest nontrivial subextension
    of `K/K_0` in the internal representation.

    EXAMPLES::

        sage: from mclf import *
        sage: K.<x> = FunctionField(GF(2))
        sage: first_subextension(GF(2), K)
        Rational function field in x over Finite Field of size 2
        sage: R.<t> = QQ[]
        sage: K.<alpha> = NumberField(t^2+t+1)
        sage: L.<beta> = K.extension(t^3 + alpha)
        sage: first_subextension(QQ, L)
        Number Field in alpha with defining polynomial t^2 + t + 1

    """
    assert K0.is_subring(K)
    assert K is not K0
    if K.base_field() is K0:
        return K
    elif hasattr(K, "rational_function_field") and K.rational_function_field() is K:
        if K.constant_base_field() is K0:
            return K
        else:
            return first_subextension(K0, K.constant_base_field())
    else:
        return first_subextension(K0, K.base_field())


# should be replaced by a method of "EmbeddingOfStandardField"
def extend_embedding(phi, k, L0, L1, psi0):
    r""" Return an extension of the embedding `\phi` one step.

    INPUT:

    - ``phi`` -- a field embedding `phi:K\to L`
    - ``k`` -- a subfield of `K` such that `K/k` is a standard extension.
    - ``L_0``, ``L_1`` -- subfields of `L` such that `L_1/L_0` is a simple extension
    - ``psi0`` -- an embedding `\psi_0:L_0\to K` which is a right inverse of `\phi`

    OUTPUT:

    a tupel `(K_1, \iota, \phi_1, \psi_1)`, where

    - `K_1/k` is a standard extension
    - `\iota:K\to K_1` is a `k`-linear embedding
    - `\phi_1:K_1\to L` is an extension of `\phi`, i.e. `\phi_1\circ\iota=\phi`
    - \psi_1:L_1\to K_1` is an extension of `\psi_0`.

    Moreover, the extension `\psi_1` is a right inverse of `\phi_1`, i.e.
    `\phi_1\circ\psi_1` is the identity on `L_1`.


    EXAMPLES::

        sage: from mclf import *
        sage: k = GF(2)
        sage: K.<x> = FunctionField(k)
        sage: phi = K.hom([x^2+x], K)
        sage: K1, iota, phi1, psi1 = extend_embedding(phi, k, k, K, k.hom(K))
        sage: K1
        Function field in T defined by T^2 + T + x
        sage: phi1(x)
        x^2 + x
        sage: phi1(K1.gen())
        x

    """
    from mclf.fields.standard_fields import is_rational_function_field
    K = phi.domain()
    L = phi.codomain()

    if is_finite_simple_extension(L1, L0):
        alpha = L1.gen()
        f = L1.polynomial()
        assert f(alpha).is_zero()
        for g, _ in f.map_coefficients(psi0, K).factor():
            if g.map_coefficients(phi, L)(alpha).is_zero():
                # K1, iota, beta = extend_standard_extension(K, k, g)
                # K1/k is a standard extension, iota:K->K1 is an embedding,
                # beta in K1 is a zero of g generating K1/K

                # define K1, iota and phi1
                K2 = K.extension(g, L1.variable_name() + "1")
                phi2 = K2.hom([alpha], phi)
                k_to_K2 = k.hom(K2)
                K1, K2_to_K1, K1_to_K2 = standard_model_of_finite_extension(
                    k_to_K2)
                phi1 = K1_to_K2.post_compose(phi2)
                iota = K.hom(K2).post_compose(K2_to_K1)
                # we also need a root of g generating K1/K
                beta = K2_to_K1(K2.gen())

                # for defn of psi1 we have the problem that the method "hom"
                # requires different input, depending on the type of field.
                # Using try/except is a somewhat dirty but pragmatic solution
                try:
                    psi1 = L1.hom([beta], K1, psi0)
                except TypeError:
                    psi1 = L1.hom([beta], K1)
                return K1, iota, phi1, psi1
        # if we get here, something went wrong
        raise AssertionError()

    elif is_rational_function_field(L1, L0):
        # then K/k must also be a function field
        t = L1.gen()
        x = K.rational_function_field().gen()
        f = algebraic_relation(L, phi(x), t)
        r, s = f.parent().gens()
        # f is an irreducible bivariate polynomial over L0 such that
        # f(phi(x),t)=0
        assert f(phi(x), t).is_zero()
        # we substitute r:=x and consider f as an univariate polynomial
        # in s over K
        f = f.map_coefficients(psi0, K)
        _, s = f.parent().gens()
        f = f(x, s).polynomial(s).change_ring(K)
        try:
            factorization = f.factor()
        except NotImplementedError:
            from mclf.fields.factor_polynomial_over_function_field \
                import factor_polynomial_over_function_field
            factorization = factor_polynomial_over_function_field(K, f)
        for g, _ in factorization:
            if g.map_coefficients(phi, L)(t).is_zero():
                K1, iota, beta = extend_standard_extension(K, k, g)
                phi1 = K1.hom([t], phi)
                psi1 = L1.hom([beta], psi0)
                return K1, iota, phi1, psi1
        # if we get here, something went wrong
        raise AssertionError()

    else:
        raise NotImplementedError()


# should soon be obsolete; it is only used in "extend_standard_extension" which
# will probably replace by a method of "FiniteExtensionOfStandardFields"
def is_finite_simple_extension(L, K):
    r""" Return whether `L/K` is a finite simple extension of fields.

    """
    return L.base_field() is K and hasattr(L, "polynomial")


# should be replaced by a method (superextension?) of
# FiniteExtensionOfStandardFields
def extend_standard_extension(K, k, g):
    r""" Return a finite extension of a standard extension.

    INPUT:

    - ``K`` -- a field
    - ``k`` -- a subfield of `K` such that `K/k` is a standard extension
    - ``g`` -- an irreducible polynomial over `K`

    OUTPUT:

    a tupel `(K_1,\iota, \beta)`, where

    - `K_1/k` is a standard extension,
    - `\iota:K\to K_1` is an embedding,
    - `\beta\in K_1` is such that `K_1=\iota(K)[\beta]` and `g^\iota(\beta)=0`.


    EXAMPLES::

        sage: from mclf import *
        sage: R.<x> = QQ[]
        sage: K.<theta> = NumberField(x^3 + x + 1)
        sage: g = x^2 + theta*x + 1
        sage: g.factor()
        x^2 + theta*x + 1
        sage: extend_standard_extension(K, QQ, g)
        (Number Field in theta with defining polynomial
         T^6 + 4*T^4 - T^3 + 4*T^2 + 1,
         Ring morphism:
           From: Number Field in theta with defining polynomial x^3 + x + 1
           To:   Number Field in theta with defining polynomial
                 T^6 + 4*T^4 - T^3 + 4*T^2 + 1
           Defn: theta |--> theta^5 + 4*theta^3 - theta^2 + 3*theta,
         theta)

    """
    phi = k.hom(K)
    if is_finite_extension(phi):
        # K/k should be simple
        assert K.base_field() is k
        if K is k:
            L = k.extension(g, "T")
            return L, k.hom(L), L.gen()
        h = K.polynomial()
        beta = K.gen()
        assert h(beta).is_zero()
        K1 = K.extension(g, "T1")
        gamma = K1.primitive_element()
        f = minimal_polynomial(gamma, k)
        L = k.extension(f, K.variable_name())
        try:
            h_roots = [beta_L for beta_L, _ in h.roots(L)]
        except NotImplementedError:
            from mclf.fields.factor_polynomial_over_function_field \
                import roots_of_polynomial_over_function_field
            h_roots = roots_of_polynomial_over_function_field(L, h)
        for beta_L in h_roots:
            try:
                iota = K.hom([beta_L], k.hom(L))
            except:
                iota = K.hom([beta_L])
            g_L = g.map_coefficients(iota, L)
            try:
                roots = [a for a, _ in g_L.roots()]
            except NotImplementedError:
                roots = roots_of_polynomial_over_function_field(L, g_L)
            if len(roots) > 0:
                return L, iota, roots[0]
        # if we get here, something went wrong
        raise AssertionError()
    else:
        from mclf.fields.standard_fields import (
            is_standard_function_field)
        assert is_standard_function_field(K)
        # K/k is a function field, so K1 should be a finite simple extension
        # of the rational subfield K0 = k(x)
        K0 = K.rational_function_field()
        return extend_standard_extension(K, K0, g)


def algebraic_relation(K, x, y):
    r""" Return an algebraic relation between `x` and `y`.

    INPUT:

    - ``K`` -- a function field, with constant base field `k`
    - ``x,y`` -- elements of `K`

    OUTPUT:

    an irreducible bivariate polynomial `f` over `k` such that `f(x,y)=0`.

    EXAMPLES::

        sage: from mclf import *
        sage: K0.<x> = FunctionField(GF(2))
        sage: R.<y> = K0[]
        sage: K.<y> = K0.extension(y^2+x^3+1)
        sage: algebraic_relation(K, x, y)
        x^3 + y^2 + 1
        sage: S.<z> = K[]
        sage: L.<z> = K.extension(z^2+z+x+y)
        sage: algebraic_relation(L, z+1, y)
        x^6 + x^5 + x^4*y + x^4 + x^2*y^2 + x^3 + x^2*y + x*y^2 + y^3 + y^2 + 1

    """
    K0 = K.rational_function_field()
    k = K0.constant_base_field()
    f = minimal_polynomial(x, K0)
    g = minimal_polynomial(y, K0)
    A = PolynomialRing(k, "X, Y, T")
    X, Y, T = A.gens()
    F = bivariate_equation(f)(T, X)
    G = bivariate_equation(g)(T, Y)
    B = PolynomialRing(k, "x, y")
    X, Y = B.gens()
    h = F.resultant(G, T)(X, Y, 0).radical()
    assert len(h.factor()) == 1, "h should be irreducible!?"
    assert h(x, y).is_zero()
    return h


def bivariate_equation(f):
    r"""

    INPUT:

    - ``f`` -- an univariate polynomial over a rational function field `K=k(t)`

    OUTPUT:

    The bivariate polynomial `F\in k[t, x]` obtained from `f` by clearing the
    denominators of the coefficients of `f`.


    EXAMPLES::

        sage: from mclf import *
        sage: K.<t> = FunctionField(QQ)
        sage: R.<x> = K[]
        sage: bivariate_equation(x^3/t + (t+1)*x + t*(t-2))
        t^3 + t^2*x + x^3 - 2*t^2 + t*x

    """
    R = f.parent()
    K = R.base_ring()
    k = K.constant_base_field()
    A = PolynomialRing(k, [K.variable_name(), R.variable_name()])
    t, x = A.gens()
    d = lcm([f[i].denominator() for i in range(f.degree() + 1)])
    f = d * f
    F = sum(f[i].numerator()(t) * x**i for i in range(f.degree() + 1))
    return F


# --------------------------------------------------------------------------

# this should be outdated, or not?

def minimal_polynomial(alpha, K):
    r""" Return the minimal polynomial of `\alpha` over the field `K`.

    INPUT:

    - ``alpha`` -- an elemenent of a field `L`
    - ``K`` -- a subfield of `L` over which `\alpha` is algebraic

    OUTPUT: the minimal polynomial of `\alpha` over `K`.

    """
    L = alpha.parent()
    assert K.is_subring(L), "K must be a subfield of L"
    if K == L:
        from sage.rings.polynomial.polynomial_ring_constructor import (
            PolynomialRing)
        A = PolynomialRing(K, 'T')
        return A.gen() - alpha
    elif L.base_ring() == K:
        return alpha.minpoly('T')
    else:
        A = matrix_of_extension_element(alpha, K)
        f = A.minimal_polynomial('T')
        assert f(alpha) == 0, "Error!"
        return f


def matrix_of_extension_element(alpha, K):
    r""" Return the matrix corresponding to this element
    of the field extension.

    """
    L = alpha.parent()
    M = L.base_ring()
    if M == K:
        return alpha.matrix()
    assert K.is_subring(M), "K must be a subring of M"
    A = alpha.matrix()
    n = A.nrows()
    D = {}
    for i in range(n):
        for j in range(n):
            D[(i, j)] = matrix_of_extension_element(A[i, j], K)
    m = D[(0, 0)].nrows()
    N = n * m
    from sage.matrix.constructor import matrix
    B = matrix(K, N, N)
    for i in range(n):
        for j in range(n):
            for k in range(m):
                for ell in range(m):
                    B[i*m+k, j*m+ell] = D[(i, j)][k, ell]
    return B
