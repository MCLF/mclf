# -*- coding: utf-8 -*-
r"""
Finite field extensions
=======================

Let `K` be a *standard field* and `L/K` a finite field extension. Then
`L` is a standard field, too. Moreover, `L/K` is automatically *simple*,
i.e. generated by one element `\alpha\in L`. Fixing a choice of such a
generator, we obtain a `K`-linear isomorphism

.. MATH::

    L \cong L_{\rm rel} := K[x]/(f),

where `f\in K[x]` is the minimal polynomial of `\alpha` over `K`. We call
`K_{\rm rel}` the **relative model** of the finite extension `L/K` (depending
on the choice of the **relative generator** `\alpha`).

Representing a finite extension `L/K` by a relative model makes it very
convenient to perform certain tasks which are important for this project:

- computing characteristic and minimal polynomials, norms, traces etc.
  of elements of `L`,
- extending and restricting valuations on `K` and `L`.

In this module we implement a class :class:`FiniteExtensionOfStandardFields`
representing a finite extension `L/K` of two standard fields, which provides
access to an internal relative model and methods implementing the various
useful tasks described above.

The most convenient way to create an instance of this class is via the
creator function :func:`finite_field_extension`. It accepts as input

- an embedding of fields `\phi:K\to L`. Here `K` and `L` must be standard
  fields, and `\phi` may be given either as a Sage morphism, or as an instance
  of the mclf class
  :class:`EmbeddingOfStandardField <mclf.fields.standard_fields.EmbeddingOfStandardFields>`,
- a pair of standard fields `(L, K)` where `K` is a subfield of `L`, i.e. there
  is a canonical embedding from `K` into `L`. The fields may be represented as
  objects of the Sage category ``Fields`` or as instances of the mclf class
  :class:`StandardField <mclf.fields.standard_fields.StandardField>`,
- a pair `(K, f)`, where `K` is a standard field and `f` is an irreducible,
  univariate polynomial over `K`. Again, the field `K` may be represented as
  an object of ``Fields`` or as an instance of
  :class:`StandardField <mclf.fields.standard_fields.StandardField>`.

The class :class:`FiniteExtensionOfStandardFields` is a child of the class
:class:`StandardField <mclf.fields.standard_fields.StandardField>`.
In this way, the extension `L/K` is considered as the standard field `L`,
together with an embedding of a standard subfield `K` and the choice of a
relative model `L_{rel}=K[x]/(f)`, or, in other words, as a relative extension.



TODO::

    - special treatment for extensions of degree one. Make sure that the
      extension field is equal to the base field
    - implement superextensions and subextensions


EXAMPLES::

    sage: from mclf import *
    sage: k0 = GF(2); k1 = GF(4)
    sage: k1_k0 = finite_field_extension(k0.hom(k1))
    sage: k1_k0
    Finite Field in z2 of size 2^2, as finite extension of Finite Field
    of size 2

The base field and the extension field of a standard extensions can be accessed
via the methods :meth:`domain` and :meth:`codomain`.::

    sage: k1_k0.domain()
    Finite Field of size 2
    sage: k1_k0.codomain()
    Finite Field in z2 of size 2^2

We can check the degree of a finite extension.::

    sage: k1_k0.relative_degree()
    2

A finite extension has a generator and a polynomial; these define the
standard model of the extension.::

    sage: k1_k0.relative_generator()
    z2
    sage: k1_k0.relative_polynomial()
    x^2 + x + 1

We can compose finite extensions, and compute subextensions with given
generators.::

    sage: k2 = GF(16)
    sage: k2_k1 = finite_field_extension(k1.hom(k2))
    sage: k2_k0 = k1_k0.superextension(k2_k1)
    sage: k2_k0

    sage: k2_k0.subextension(k1.gen())

We can also compute the base change of an extension with respect to another
one.::

    sage: k2_k0.base_change(k1_k0)


A finite extension can also be defined via an injective field homomorphism.::

    sage: K.<x> = FunctionField(k0)
    sage: phi = K.hom([x^2+x])
    sage: K_K = finite_field_extension(phi)
    sage: K_K
    Rational function field in x over Finite Field of size 2,
    as finite extension of Rational function field in x over Finite Field
    of size 2
    sage: K_K.relative_generator()
    x
    sage: K_K.relative_polynomial()
    T^2 + T + x

"""

from mclf.fields.standard_fields import (
    standard_field, StandardField, StandardFiniteField, StandardNumberField,
    StandardFunctionField)
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.all import lcm


def finite_field_extension(*args):
    r""" Return the finite field extension determined by the input.

    INPUT:

    - ``args`` -- data determining a finite field extension `L/K`

    OUTPUT: a Sage object representing the finite field extension `L/K`.

    The arguments may be

    - an injective field morphism `\phi:L\to K`, or
    - a pair `(K, f)`, where `K` is a standard field and `g` is a univariate
      irreducible polynomial over `K`.
    - a tripel `(K, f, a)`, where `(K, f)` is as above, and `a` is an
      alphanumeric string.

    Here the fields `K` and `L` are assumed to be standard fields; they may be
    either objects of the Sage category ``Fields`` or instances of the mclf
    class :class:`StandardField`.

    In the first case, the extension is `L/K` case. In the second case, we
    define `L:=K[x]/(f)`. In the third case, we use `a` for the name of the
    generator.

    """
    if len(args) == 1:
        phi = args[0]
        return finite_field_extension_from_embedding(phi)
    elif len(args) == 2:
        return finite_field_extension_from_polynomial(args[0], args[1])
    elif len(args) == 3:
        return finite_field_extension_from_polynomial(args[0], args[1], args[2])
    else:
        raise TypeError("Wrong number of parameters")


def extension_from_embedding(phi, L1=None):
    r""" Return the finite field extension corresponding to the an embedding.

    INPUT:

    - ``phi`` -- an embedding `\phi:K\to L` of standard fields
    - ``L1`` -- a subfield of `L` (default: ``None``)

    If `L_1` is given, then we assume it is a *natural subfield* of `L`,
    i.e. either the prime subfield, the standard model of `L` it self, or
    the rational base field of the standard function field `L`.

    OUTPUT:

    - if `L_1` is not given, then we return the codomain `L` as a finite
      extension of the domain `K`, such that `\phi` becomes the canonical
      embedding of the extension `L/K`
    - if `L_1` is given, then we return a triple `(M, \phi_1, \psi_1)`, where

      * `M/K` is a finite field extension,
      * `\phi_1:M\to L` is an extension of `\phi`,
      * `\psi_1:L_1\to M` is a right inverse of `\phi_1`, i.e. the
        composition `\phi_1\circ\psi_1:L_1\to L` is the natural inclusion.

    Note that for `L=L_1`, `\phi_1:M\to L` and `\psi_1:L\to M` are mutually
    inverse isomorphisms. Therefore, we can reduce the first case (where
    `L_1` is not given) to the second case for `L=L_1`.

    """
    K = phi.Domain()
    L = phi.Codomain()
    if L1 is None:
        L1 = L.standard_model()
        M, M_to_L, L_to_M = extension_from_embedding(phi, L1)
        return M.change_standard_model(M_to_L, L_to_M)
    elif L.is_prime_subfield(L1):
        M = K.as_extension_of_itself()
        M_to_L = phi
        L1_to_M = M.inclusion(L1)
        return M, M_to_L, L1_to_M
    elif L.is_rational_function_subfield(L1):
        raise NotImplementedError()
    else:
        # the following is not yet ready
        # we have to clarify how to deal with superextension, or even
        # towers of extensions
        L0, alpha, f = L.subfield_as_simple_extension(L1)
        M0, M0_to_L, L0_to_M0 = extension_from_embedding(phi, L0)
        f_M0 = f.change_coefficients(L0_to_M0)
        for g in M0.prime_factors(f_M0):
            g_L = g.change_coefficients(M0_to_L)
            if g_L(alpha).is_zero():
                M = M0.extension(g)
                # is this a tower ?
                M_to_L = M.relative_hom(L, alpha, M0_to_L)
                # I assume M is a tower, and I can refer to some subfield
                # as a relative base field
                L_to_M = L.hom(M, M.relative_generator(M0), L0_to_L)
                return M, M_to_L, L1_to_M
        # if we get here, something went wrong
        raise AssertionError("couldn't find the right factor")


def finite_field_extension_from_embedding(phi):
    r""" Return the finite field extension given by an embedding of
    standard fields.

    INPUT:

    - ``phi`` -- an embedding `\phi:K\to L` of standard fields

    OUTPUT:

    the finite fields extension `L/K`, as an instance of
    :class:`FiniteExtensionOfStandardField`.

    If `L/K` is not finite, an error is raised.

    ALGORITHM:

    Our goal is to construct a finite simple extension `M/K` and a `K`-linear
    isomorphism `\psi:L\to M` which is a left inverse of this embedding
    `\phi:K\to L`.

    Let

    .. MATH::

        L_0\subset L_1\subset\ldots \subset L_r=L

    be the natural sequence of subfield of `L` such that `L_i/L_{i-1}`
    is a simple extension, generated by one element `\alpha_i\in L_i`.
    Since `L_0` is the common prime field of `K` and `L`, we have a unique
    embedding `\psi_0:L_0\to K` which is a right inverse of `\phi`.

    We construct inductively a sequence of finite simple extensions
    `M_0=K\subset M_1\subset\ldots \subset M_r` and embeddings

    .. MATH::

        \phi_i: M_i\hookrightarrow L, \quad \psi_i: L_i \hookrightarrow M_i, \
            \quad i=1,\ldots,r,

    such that

    - the restriction of `\phi_i` to `K=M_0` is equal to `\phi`,
    - the restriction of `\psi_i` to `L_{i-1}` is equal to `\psi_{i-1}`,
    - each `\phi_i` is a let inverse of `\psi_i`.

    Then `M:=M_r` is a finite extension of `K` and `\psi:=\psi_r:L\to M` and
    `\phi_r:M\to L` are mutually inverse, is `K`-linear isomorphisms.

    The last step is to collapse the extension `M/K`, which is a tower of
    simple extension, to a single simple extension. This is also done
    inductively, using the method
    :meth:`FiniteExtensionOfStandardFields.superextension`.

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        EmbeddingOfStandardFields, embedding_of_standard_fields)
    if not isinstance(phi, EmbeddingOfStandardFields):
        phi = embedding_of_standard_fields(phi)
    assert phi.is_finite_extension()

    # initialization:
    K = phi.Domain()                # K and L are in StandardFields!
    L = phi.Codomain()
    M = K.as_extension_of_itself()  # M is a finite extension of K
    L0 = L.prime_field()            # L0, L1 are natural subfields of L
    L0_to_M = L0.hom(M.standard_model())
    M_to_L = phi

    # we walk through the tower of natural subfields of L;
    # in each step we create a finite simple extension M1/M corresponding to
    # the finite intermediate extension L1/L0
    for L1, alpha, f in L.structure():
        # we have L1 = L0[alpha], natural subfield of L
        if f.is_zero():
            # L1/L0 is a rational function field, generated by alpha
            M1, L1_to_M1, M1_to_L = _lift_embedding_to_rational_function_field(
                M, L0_to_M, L1, M_to_L)
        else:
            # L1/L0 is finite, f the minimal polynomial of the gen alpha
            M1, L1_to_M1, M1_to_L = _lift_embedding_to_finite_simple_extension(
                M, L0_to_M, L1, alpha, f, M_to_L)
        M = M1.as_extension_of(K)
        L0 = L1
        L0_to_M = L1_to_M1
        M_to_L = M1_to_L

    # end of loop; L0 = L, so M and M_to_L are what we want; moreover:
    L_to_M = L0_to_M

    if K.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M, L_to_M, M_to_L)
    elif K.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M, L_to_M, M_to_L)
    elif K.is_function_field():
        return FiniteExtensionOfFunctionFields(phi, M, L_to_M, M_to_L)
    else:
        raise NotImplementedError()


def _lift_embedding_to_rational_function_field(
        M, L0_to_M, L1, M_to_L):
    r""" Helper function.

    INPUT:

    - ``M`` -- a finite field extension `M/K`
    -  ``L0_to_M`` an embedding of standard fields `\psi_0:L_0\to M`
    - ``L1`` -- a rational function field over L0, which is a subfield of `L`
    - ``M_to_L`` -- an embedding `\phi:M\to L`

    It is assumed that the composition `\phi\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M_1, \psi_1, \phi_1)`, where

    - `M_1/M` is a finite simple extension
    - `\psi_1:L_1\to M_1` is an extension of `\psi_0:L_0\to M`
    - `\phi_1:M_1\to L` is an extension of `\phi:M\to L`,

    and such that `\phi\circ\psi_1:L_1\to L` is the natural inclusion.

    """
    raise NotImplementedError()


def lift_embedding_to_finite_simple_extension(
        M, L0_to_M, L1, alpha, f, M_to_L):
    r""" Helper function

    INPUT:

    - ``M`` -- a finite field extension `M/K`
    -  ``L0_to_M`` an embedding of standard fields `\psi_0:L_0\to M`
    - ``L1`` -- a finite field extension over L0, which is a subfield of `L`
    - `alpha` -- the generator of `L_1/L_0`
    - `f` -- the minimal polynomial of `\alpha` over `L_0`
    - ``M_to_L`` -- an embedding `\phi:M\to L`

    It is assumed that the composition `\phi\circ\psi_0:L_0\to L` is the
    natural inclusion.

    OUTPUT:

    a triple `(M_1, \psi_1, \phi_1)`, where

    - `M_1/M` is a finite simple extension
    - `\psi_1:L_1\to M_1` is an extension of `\psi_0:L_0\to M`
    - `\phi_1:M_1\to L` is an extension of `\phi:M\to L`,

    and such that `\phi\circ\psi_1:L_1\to L` is the natural inclusion.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(QQ)
        sage: x = K.polynomial_generator("x")
        sage: M = K.extension(x^2 - 2, "a")
        sage: a = M.relative_generator()
        sage: f = M.relative_polynomial()
        sage: L0_to_M = QQ.hom(M.standard_model())
        sage: L1 = M.standard_model()
        sage: M_to_L = M.hom(M, -a)
        sage: lift_embedding_to_finite_simple_extension(M, L0_to_M, L1, a, f, M_to_L)


    """
    L = M_to_L.Codomain()
    f_M = f.map_coefficients(L0_to_M, M.standard_model())
    found_factor = False
    for g in M.prime_factors(f_M):
        g_L = M_to_L.change_coefficients(g)
        if g_L(alpha).is_zero():
            factor_found = True
            M1 = M.extension(g)
            M1_to_L = M1.relative_hom(L, alpha, M_to_L)
            # there seems to be a problem with mixing bare morphisms
            # with Embeddings
            L0_to_M1 = M1.embedding().precompose(L0_to_M)
            L1_to_M1 = homomorphism_on_standard_field(
                L1, M1.standard_model(), M1.relative_generator(),
                L0_to_M1)
    assert factor_found, "something went wrong"
    return M1, L1_to_M1, M1_to_L


def finite_field_extension_from_polynomial(K, f, gen_name=None):
    r""" Return the finite field extension given by an irreducible polynomial.

    INPUT:

    - ``K`` -- a standard field
    - ``f`` -- an univariate polynomial, irreducible over `K`
    - ``gen_name`` -- an alphanumeric string (optional)

    OUTPUT:

    the finite field extension `L:=K[x]/(f)` over `K`. If ``gen_name`` is
    given, it is used for the name of the generator of `L/K`.


    EXAMPLES::

        sage: from mclf import *
        sage: R.<x> = QQ[]
        sage: K = standard_number_field(x^2-2, "a")
        sage: a = K.generator()
        sage: finite_field_extension_from_polynomial(K, x^2 - a, "b")
        Number Field in b with defining polynomial x^4 - 2, as finite
        extension of Number Field in a with defining polynomial x^2 - 2

    """
    from sage.categories.number_fields import NumberFields
    from mclf.fields.embeddings_of_standard_fields import (
        embedding_of_standard_fields)
    if not isinstance(K, StandardField):
        K = standard_field(K)
    f = K.change_coefficients(f)
    if gen_name is None:
        gen_name = f.variable_name()

    M = K.standard_model().extension(f, gen_name)
    if f.degree() == 1:
        L = K
        phi = K.inclusion(L)
        L_to_M = L.standard_model().hom(M)
        from mclf.fields.standard_fields import homomorphism_on_standard_field
        M_to_L = homomorphism_on_standard_field(M, L.standard_model(),
                                                -f[0]/f[1], phi)
        # M_to_L = M.hom([-f[0]/f[1]], phi)
    else:
        L = standard_field(M)
        phi = K.standard_model().hom(M).post_compose(L.from_original_model())
        phi = embedding_of_standard_fields(phi)
        L_to_M = L.to_original_model()
        M_to_L = L.from_original_model()

    if K.is_finite():
        return FiniteExtensionOfFiniteFields(phi, M, L_to_M, M_to_L)
    elif K.is_number_field():
        return FiniteExtensionOfNumberFields(phi, M, L_to_M, M_to_L)
    elif K.is_function_field():
        return FiniteExtensionOfFunctionFields(phi, M, L_to_M, M_to_L)
    else:
        raise NotImplementedError()


# becomes obsolete once we replace "extend_standard_extension"
def is_finite_extension(phi):
    r""" Return whether an extension of standard fields is finite.

    INPUT:

    - ``phi`` -- an embedding `K\to L` of a standard field into another

    OUTPUT:

    whether `L/K` is a finite extension.

    Since `L` and `K` are finite fields, it follows easily that `L/K` is finite
    unless `L` is a function field and `K` is not.

    """
    from sage.categories.function_fields import FunctionFields
    return (phi.domain() in FunctionFields
            or not phi.codomain() in FunctionFields)


class FiniteExtensionOfStandardFields(StandardField):
    r""" An object representing a finite extension of a standard field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    To create an instance of this class you should use the function
    :func:`finite_field_extension`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_field(GF(4))
        sage: x = K.polynomial_generator("x")
        sage: f = x^3 + x^2 + x + K.generator() + 1
        sage: L = finite_field_extension(K, f); L
        Finite Field in z6 of size 2^6, as finite extension of Finite Field
        in z2 of size 2^2

    We may view `L` has a standard field.::

        sage: L.standard_model()
        Finite Field in z6 of size 2^6

    Internally, the extension is represented by a "relative model"::

        sage: L.relative_model()
        Univariate Quotient Polynomial Ring in x over Finite Field in z2
        of size 2^2 with modulus x^3 + x^2 + x + z2 + 1

    Viewing `L` as a relative extension, it is defined by its *relative base
    field* (also identical to the *domain*), the *relative generator*, and the
    *relative polynomial* (which is the relative minimal polynomial of the
    relative generator).::

        sage: L.relative_base_field()
        the standard field with 4 elements
        sage: L.relative_generator()
        z6
        sage: L.relative_polynomial()
        x^3 + x^2 + x + z2 + 1


    """

    def __init__(self, phi, M, s, t):
        from mclf.fields.embeddings_of_standard_fields import (
            EmbeddingOfStandardFields)
        if not isinstance(phi, EmbeddingOfStandardFields):
            phi = embedding_of_standard_fields(phi)
        K = phi.Domain()
        L = phi.Codomain()
        self._relative_base_field = K
        self._extension_field = L
        self._embedding = phi

        # we initialize this extension as a standard field
        if K.is_finite():
            StandardFiniteField.__init__(self, L)
        elif K.is_number_field():
            StandardNumberField.__init__(self, L)
        elif K.is_function_field():
            StandardFunctionField.__init__(self, L)

        self._relative_generator = t(M.gen())
        if hasattr(M, "relative_polynomial"):
            self._relative_polynomial = M.relative_polynomial()
        elif hasattr(M, "polynomial"):
            self._relative_polynomial = M.polynomial()
        elif hasattr(M, "modulus"):
            self._relative_polynomial = M.modulus()
        else:
            raise TypeError("M is not of the correct type")
        self._relative_model = M
        self._to_relative_model = s
        self._from_relative_model = t

    def __repr__(self):
        return "{}, as finite extension of {}".format(self.codomain(),
                                                      self.domain())

    def relative_base_field(self):
        r""" Return the relative base field of this finite extension.

        Note that we return an instance of the class :class:`StandardField`.
        """
        return self._relative_base_field

    def domain(self):
        r""" Return the standard model of the relative base field; it is the
        domain of the embedding defining this standard extension.
        """
        return self.relative_base_field().standard_model()

    def extension_field(self):
        r""" Return the extension field of this finite extension.

        """
        return self._extension_field

    def codomain(self):
        r""" Return the standard model of the extension field; it is the
        codomain of the embedding defining this standard extension.
        """
        return self.standard_model()

    def embedding(self):
        r""" Return the embedding morphism from the base field
        to the extension field.
        """
        return self._embedding

    def relative_model(self):
        r""" Return the relative model of this finite field extension.

        """
        return self._relative_model

    def to_relative_model(self):
        r""" Return the isomorphism from the extension field
        to the relative model.

        """
        return self._to_relative_model

    def from_relative_model(self):
        r""" Return the isomorphism from the relative model to the
        standard model of the extension field.

        """
        return self._from_relative_model

    def relative_degree(self):
        r""" Return the degree of this field extension.

        This must be implemented by the subclass.
        """
        return self.relative_polynomial().degree()

    def relative_polynomial(self):
        r""" Return the polynomial corresponding to the standard model of this
        extension.

        """
        return self._relative_polynomial

    def relative_generator(self):
        r""" Return the generator of this finite extension.

        """
        return self._relative_generator

    def relative_minpoly(self, t, var_name="T"):
        r""" Return the minimal polynomial of this element over the base field
        of this finite extension.

        INPUT:

        - `t` -- an element of the extension field `L`
        - ``varname`` -- an alphanumeric string (default: "T")

        OUTPUT:

        The minimal polynomial of `t` over the relative base field `K`.

        If ``var_name`` is not given, we use the letter "T" as a default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F0 = standard_rational_function_field(k, "x")
            sage: x = F0.generator()
            sage: y = F0.polynomial_generator("y")
            sage: F = F0.extension(y^3 + x^4 + x + 1)
            sage: y = F.relative_generator()
            sage: F.relative_minpoly(y + x)
            T^3 + x*T^2 + x^2*T + x^4 + x^3 + x + 1

        """
        return self.to_relative_model()(t).minpoly().\
            change_variable_name(var_name)

    def relative_norm(self, a):
        r""" Return the norm of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the norm of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: K = standard_finite_field(4)
            sage: a = K.polynomial_generator("a")
            sage: L = K.extension(a^2 + a + K.generator())
            sage: a = L.relative_generator()
            sage: L.relative_norm(a)
            z2

        """
        return self.to_relative_model()(a).norm()

    def relative_trace(self, a):
        r""" Return the trace of an element under this finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension

        OUTPUT:

        the trace of `a` with respect to this finite field extension `L/K`; it
        is an element of the domain `K`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 + x + 1, "a")
            sage: b = K.polynomial_generator("b")
            sage: L = K.extension(b^3 + b^2 + K.generator() + 1)
            sage: L.relative_trace(L.generator())
            -2

        """
        return self.to_relative_model()(a).trace()

    def relative_charpoly(self, a, var_name="T"):
        r""" Return the characteristic polynomial of an element under this
        finite field extension.

        INPUT:

        - ``a`` -- an element of the codomain `L` of this
                   finite field extension
        - ``var_name`` -- an alphanumeric string (default: "T")

        OUTPUT:

        the characteristic polynomial of `a` with respect to this finite field
        extension `L/K`.

        If ``var_name`` is not given, we choose the letter "T" by default.

        EXAMPLES::

            sage: from mclf import *
            sage: k = standard_finite_field(2)
            sage: F = standard_rational_function_field(k, "x")
            sage: x = F.generator()
            sage: phi = F.hom(F, x^2 + 1)
            sage: FF = finite_field_extension(phi)
            sage: FF.relative_charpoly(x)

        """
        return self.to_relative_model()(a).charpoly().\
            change_variable_name(var_name)

    def relative_hom(self, M, beta, *phi0):
        r""" Return the homomorphism to another field extending a base
        homomorphism, given by the image of the relative generator.

        INPUT:

        - ``M`` -- a field
        - ``beta`` -- an element of M
        - ``phi0`` -- an embedding `\phi_0:K\to M` of the relative base field
                      of this extension `L/K` into M

        OUTPUT:

        the homomorphism `\phi:L\to M` extending `\phi_0` sending
        the relative generator `\alpha` of `L/K` to `\beta`.

        Such an embedding exists iff `\beta` is a root of the image of
        the minimal polynomial of `\alpha` under `\phi_0`. If this is not
        true, an error is raised.

        If `\phi_0` is omitted, `K` must be a subfield of `M` and then we
        let `\phi_0:K\to M` be the natural inclusion.

        The field `M` may be given as a Sage field, or as an instance of
        the mclf class
        :class:`EmbeddingOfStandardFields <mclf.fields.standard_fields.EmbeddingOfStandardFields>`.


        EXAMPLES::

            sage: from mclf import *
            sage: K = GF(2)
            sage: L = GF(4)
            sage: L_K = finite_field_extension(K.hom(L))
            sage: alpha = L_K.relative_generator()
            sage: L_K.relative_hom(L, alpha + L.one())
            the embedding of Finite Field in z2 of size 2^2 into Finite Field
            in z2 of size 2^2, sending z2 to z2 + 1

        """
        K = self.domain()
        f = self.relative_polynomial()
        # make sure beta lies in M
        beta = M(beta)
        # turn M into a bare field
        if isinstance(M, StandardField):
            M = M.standard_model()

        if len(phi0) == 0:
            # phi0 was omitted from the input
            if not K.is_subring(M):
                print("L_K = ", self)
                print("K = ", K)
                print("M = ", M)
            assert K.is_subring(M), "the base field must be a subfield of M"
            phi0 = K.hom(M)
        elif len(phi0) == 1:
            phi0 = phi0[0]
            assert K.is_subring(phi0.domain())
            assert phi0.codomain().is_subring(M)
        else:
            raise ValueError("Wrong number of parameters")

        # check existence
        f_M = f.map_coefficients(phi0, M)
        assert f_M(beta).is_zero(), "the homomorphism doesn't exist"

        from mclf.fields.standard_fields import (
            homomorphism_on_standard_field)
        phi1 = homomorphism_on_standard_field(self.relative_model(),
                                              M, [beta], phi0)
        phi = self.to_relative_model().post_compose(phi1)
        from mclf.fields.embeddings_of_standard_fields import (
            embedding_of_standard_fields)
        return embedding_of_standard_fields(phi)

    def composition_with_superextension(self, M_L):
        r""" Return the composition of this extension with a superextension.

        INPUT:

        - ``M_L`` -- a finite extension `M/L` of this extension `L/K`

        OUTPUT:

        A triple `(M_1/K, s, t)`, where `M_1/K` is a finite simple extension,
        `s:M\to M_2` is a `K`-linear isomorphism and `t` is the inverse of `s`.

        EXAMPLES::

            sage: from mclf import *
            sage: R.<x> = QQ[]
            sage: K = standard_number_field(x^2 - 2, "a")
            sage: a = K.generator()
            sage: L_K = K.extension(x^2 - a, "b")
            sage: b = L_K.relative_generator()
            sage: M_L = L_K.extension(x^2 - b, "c")

        """
        K = self.relative_base_field()
        L = self.codomain()        # note: L is just a bare field, unlike K, M
        M = M_L.extension_field()
        K_to_M = K.embedding().post_compose(M_L.embedding())

        # we first find an element gamma in M which generates M/K
        # for this we use the method `primitive_element` associated
        # to a Sage function field
        g = M_L.relative_polynomial()
        M1 = L.extension(g, g.variable_name()+"1")
        M1_to_M = M1.hom([M_L.relative_generator()], base_map=M_L.embedding())
        gamma = M1_to_M(M1.primitive_element())

        # we compute the minimal polynomial g of gamma over K
        f = M.minimal_polynomial(gamma)
        for g in K.prime_factors(f):
            g_M = g.map_coefficients(K_to_M, M.standard_model())
            if g_M(gamma).is_zero():
                M2_K = finite_field_extension_from_polynomial(K, g)
                M2 = M2_K.extension_field()
                M2_to_M = M2.relative_hom(M, [gamma], K_to_M)
                M_to_M2 = M2_to_M.inverse()
                return M2_K, M_to_M2, M2_to_M
        # if we get here, something went wrong
        raise AssertionError()

    def restriction_of_valuation(self, w):
        r""" Compute the restriction of a valuation from the codomain to the
        domain of this field extension.

        INPUT:

        - ``w`` -- a valuation on the codomain `L` of this extension

        OUTPUT:

        the restriction `v:=w|_K` to the domain `K` of this extension.

        This method must be implemented by the appropriate subclass.

        .. NOTE::

            It is not clear if this method is very useful. The algorithm for
            computing the restriction depends more on the type of the fields
            `K` and `L`, and on the nature of the valuation, and not so much
            on the type of the extension `L/K`. Therefore, these algorithms
            should rather be implemented by the appropriate subclasses of
            :class:`ValuedField`.

        """
        raise NotImplementedError()


class FiniteExtensionOfFiniteFields(
        FiniteExtensionOfStandardFields, StandardFiniteField):
    r""" An object representing a finite extension of a finite field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    """


class FiniteExtensionOfNumberFields(FiniteExtensionOfStandardFields,
                                    StandardNumberField):
    r""" An object representing a finite extension of a number field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

        EXAMPLES::

            sage: from mclf import *
            sage: K = standard_field(CyclotomicField(3, "theta"))
            sage: x = K.polynomial_generator("x")
            sage: f = x^3 - K.generator()
            sage: L = finite_field_extension(K, f); L
            Number Field in x with defining polynomial x^6 + x^3 + 1,
            as finite extension of Cyclotomic Field of order 3 and degree 2

        We may view `L` has a standard field.::

            sage: L.standard_model()
            Number Field in x with defining polynomial x^6 + x^3 + 1

            sage: L.original_model()
            Number Field in x with defining polynomial x^3 - theta
            over its base field

        Viewing `L` as a relative extension, it is defined by its
        *relative base field* (also identical to the *domain*), the
        *relative generator*, and the *relative polynomial* (which is the
        relative minimal polynomial of the relative generator).::

            sage: L.relative_base_field()
            Cyclotomic Field of order 3 and degree 2 as a standard field
            sage: L.relative_generator()
            x
            sage: L.relative_polynomial()
            x^3 - theta

    """


class FiniteExtensionOfFunctionFields(FiniteExtensionOfStandardFields,
                                      StandardFunctionField):
    r""" An object representing a finite extension of a function field.

    INPUT:

    - ``phi`` -- an embedding of standard fields `\phi:K\to L`,
                 such that `K` is a number field and `L/K` is finite
    - ``M`` -- a simple extension of `K`
    - ``s`` -- a `K`-linear isomorphism `s:L\to M`
    - ``t`` -- the inverse of `s`, `t:M\to L`

    OUTPUT:

    The finite simple extension `L/K`, with relative model `M`.

    """

# ----------------------------------------------------------------------------


def relative_model_of_finite_extension(phi):
    r""" Return the relative model of a finite field extension.

    INPUT:

    - ``phi`` -- an embedding of fields `\phi:K\to L` which makes `L` a finite
                 extension of `K`

    The embedding `\phi` must be an instance of the class
    :class:`EmbeddingOfStandardFields <mclf.fields.\
    embeddings_of_standard_fields.EmbeddingOfStandardFields>`.

    OUTPUT:

    a tripel `(M, s, t)`, where `M` is a finite simple field extension of `K`,
    `s:L\to M` is a `K`-linear isomorphism, and `t:M\to L` is the inverse
    of `s`.

    Note that `M` is a base Sage field, not an instance of
    :class:`StandardField <mclf.fields.standard_fields.StandardField`.
    So `L` above refers to the standard model of the standard field `L`.

    EXAMPLES::

        sage: from mclf import *
        sage: K = standard_finite_field(4)
        sage: L = standard_finite_field(16)
        sage: phi = K.hom(L)
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        Univariate Quotient Polynomial Ring in xbar over Finite Field
        of size 2 with modulus x^4 + x + 1

        sage: K = standard_field(CyclotomicField(3))
        sage: L = standard_field(CyclotomicField(9))
        sage: phi = K.hom(L)
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        Number Field in x with defining polynomial x^3 - zeta3
        over its base field

    """
    K = phi.Domain()       # K and L are in `StandardField` !
    L = phi.Codomain()

    if K.is_finite():
        assert L.is_finite(), "If the domain is finite,\
                the codomain must be, too"
        # Since L has one absolute generator, we can use it as a relative
        # generator, too. We just have to find the correct irreducible factor g
        # of its minimal polynomial f over K.
        # However, for finite fields any factor will do! This is because
        # f completely splits over L, and we can take any root of the factor g
        # as a relative generator.
        f = L.polynomial()
        g = K.prime_factors(f)[0]
        alpha = L.roots(g)[0]
        # now L is iso to  M:=K[alpha |g(alpha)=0]
        # we construct M and the isomorphisms

        # for some types of finite fields, the method "extension" is not
        # available; so we create directly the quotient of a polynomial ring
        # the problem is that M will not have the method "polynomial";
        # we have to use "modulus" instead
        M = f.parent().quotient_by_principal_ideal(f)
        M_to_L = M.hom([alpha], L.standard_model())
        L_to_M = L.standard_model().hom([M.gen()])
        return M, L_to_M, M_to_L

    elif K.is_number_field():
        assert L.is_number_field(), "If the domain is a number field,\
            the codomain must be, too"
        # Again we let f be the minimal pol of the fixed absolute generator
        alpha = L.generator()
        f = L.polynomial()
        factors_of_f = K.prime_factors(f)
        # we find the factor which has alpha as a root and use it construct
        # the relative model of L/K
        for g in factors_of_f:
            g_L = g.map_coefficients(phi, L.standard_model())
            if g_L(alpha).is_zero():
                M = K.standard_model().extension(g, f.variable_name())
                M_to_L = M.hom([alpha], L.standard_model())
                L_to_M = L.standard_model().hom([M.gen()])
                return M, L_to_M, M_to_L
        # if we get here, something went wrong
        raise AssertionError("Couldn't find the correct irreducible factor")

    elif K.is_function_field():
        assert L.is_function_field(), "If the domain is a function field,\
            the codomain must be, too"
        return relative_model_of_finite_extension_of_function_fields(phi)


def relative_model_of_finite_extension_of_function_fields(phi):
    r""" Return the relative model of a finite extension of function fields.

    INPUT:

    - ``phi`` -- an embedding of function fields `\phi:K\to L`

    The embedding `\phi` may be given as a Sage morphism between
    fields, or as an instance of the class
    :class:`EmbeddingOfFunctionFields <mclf.fields.\
    embeddings_of_standard_fields.EmbeddingOfFunctionField`.

    OUTPUT:

    a tripel `(M, s, t)`, where `M` is a finite simple field extension of `K`,
    `s:L\to M` is a `K`-linear isomorphism, and `t:M\to L` is the inverse
    of `s`.

    EXAMPLES::

        sage: from mclf import *
        sage: k0 = standard_field(QQ)
        sage: K = standard_rational_function_field(k0, "x")
        sage: k = standard_field(CyclotomicField(5))
        sage: zeta = k.generator()
        sage: L = standard_rational_function_field(k, "y")
        sage: y = L.generator()
        sage: phi = K.hom(L, [y^2+y + zeta])
        sage: M, s, t = relative_model_of_finite_extension(phi)
        sage: M
        (Function field in T defined by zeta1^8 + 4*zeta1^7 +
        (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x - 1)*zeta1^4
         + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 +
         (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3 + x^2 + x + 1,
         Function Field morphism:
           From: Rational function field in y over Cyclotomic Field of order 5 and degree 4
           To:   Function field in zeta1 defined by zeta1^8 + 4*zeta1^7 + (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x -
         1)*zeta1^4 + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 + (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3
         + x^2 + x + 1
            Defn: y |--> zeta1
               zeta |--> zeta1,
         Function Field morphism:
           From: Function field in zeta1 defined by zeta1^8 + 4*zeta1^7 + (-4*x + 5)*zeta1^6 + (-12*x + 1)*zeta1^5 + (6*x^2 - 9*x -
         1)*zeta1^4 + (12*x^2 + 2*x + 1)*zeta1^3 + (-4*x^3 + 3*x^2 + x)*zeta1^2 + (-4*x^3 - 3*x^2 - 2*x - 1)*zeta1 + x^4 + x^3
         + x^2 + x + 1
           To:   Rational function field in y over Cyclotomic Field of order 5 and degree 4
           Defn: zeta1 |--> y
                 zeta1 |--> zeta
                 x |--> y^2 + y + zeta)

    The following caused an error in a previous version. The fix is not very
    satisfying, though. The introduction of the new variable a1 is quite
    superfluous.::

        sage: R.<a> = QQ[]
        sage: K.<a> = NumberField(a^2-2)
        sage: F.<x> = FunctionField(K)
        sage: phi = F.hom([x])
        sage: relative_model_of_finite_extension(phi)
        (Function field in a1 defined by a1 - x,
         Function Field morphism:
           From: Rational function field in x over Number Field in a
                 with defining polynomial a^2 - 2
           To:   Function field in a1 defined by a1 - x
           Defn: x |--> x
                 a |--> a,
         Function Field morphism:
           From: Function field in a1 defined by a1 - x
           To:   Rational function field in x over Number Field in a
                 with defining polynomial a^2 - 2
           Defn: a1 |--> x
                 a1 |--> a
                  x |--> x)


    """
    K = phi.Domain()       # K and L are in `StandardFunctionField` !
    L = phi.Codomain()

    # what do I need precisely here?
    # k, k_to_K, k_to_L = phi.common_subfield()
    # k is a subfield of L!

    L0 = L.prime_field()
    M = K.standard_model()
    M_to_L = phi
    L0_to_M = L0.hom(M)
    for L1, _, _ in L.structure():
        M, iota, M_to_L, L1_to_M = extend_embedding(
            M_to_L, K, L0, L1, L0_to_M)
        L0 = L1
        L0_to_M = L1_to_M
    return M, L0_to_M, M_to_L


def first_subextension(K0, K):
    r""" Return the smallest nontrivial subextension of K/K_0.

    INPUT:

    - ``K0``, ``K`` -- fields, where `K/K_0` is a finitely generated, nontrivial
                       extension

    OUTPUT:

    a subfield `K_1` of `K`, where `K_1/K_0` the smallest nontrivial subextension
    of `K/K_0` in the internal representation.

    EXAMPLES::

        sage: from mclf import *
        sage: K.<x> = FunctionField(GF(2))
        sage: first_subextension(GF(2), K)
        Rational function field in x over Finite Field of size 2
        sage: R.<t> = QQ[]
        sage: K.<alpha> = NumberField(t^2+t+1)
        sage: L.<beta> = K.extension(t^3 + alpha)
        sage: first_subextension(QQ, L)
        Number Field in alpha with defining polynomial t^2 + t + 1

    """
    assert K0.is_subring(K)
    assert K is not K0
    if K.base_field() is K0:
        return K
    elif hasattr(K, "rational_function_field") and K.rational_function_field() is K:
        if K.constant_base_field() is K0:
            return K
        else:
            return first_subextension(K0, K.constant_base_field())
    else:
        return first_subextension(K0, K.base_field())


# should be replaced by a method of "EmbeddingOfStandardField"
def extend_embedding(phi, k, L0, L1, psi0):
    r""" Return an extension of the embedding `\phi` one step.

    INPUT:

    - ``phi`` -- a field embedding `phi:K\to L`
    - ``k`` -- a subfield of `K` such that `K/k` is a standard extension.
    - ``L_0``, ``L_1`` -- subfields of `L` such that `L_1/L_0` is a simple extension
    - ``psi0`` -- an embedding `\psi_0:L_0\to K` which is a right inverse of `\phi`

    OUTPUT:

    a tupel `(K_1, \iota, \phi_1, \psi_1)`, where

    - `K_1/k` is a standard extension
    - `\iota:K\to K_1` is a `k`-linear embedding
    - `\phi_1:K_1\to L` is an extension of `\phi`, i.e. `\phi_1\circ\iota=\phi`
    - \psi_1:L_1\to K_1` is an extension of `\psi_0`.

    Moreover, the extension `\psi_1` is a right inverse of `\phi_1`, i.e.
    `\phi_1\circ\psi_1` is the identity on `L_1`.


    EXAMPLES::

        sage: from mclf import *
        sage: k = GF(2)
        sage: K.<x> = FunctionField(k)
        sage: phi = K.hom([x^2+x], K)
        sage: K1, iota, phi1, psi1 = extend_embedding(phi, k, k, K, k.hom(K))
        sage: K1
        Function field in T defined by T^2 + T + x
        sage: phi1(x)
        x^2 + x
        sage: phi1(K1.gen())
        x

    """
    from mclf.fields.standard_fields import is_rational_function_field
    K = phi.domain()
    L = phi.codomain()

    if is_finite_simple_extension(L1, L0):
        alpha = L1.gen()
        f = L1.polynomial()
        assert f(alpha).is_zero()
        for g, _ in f.map_coefficients(psi0, K).factor():
            if g.map_coefficients(phi, L)(alpha).is_zero():
                # K1, iota, beta = extend_standard_extension(K, k, g)
                # K1/k is a standard extension, iota:K->K1 is an embedding,
                # beta in K1 is a zero of g generating K1/K

                # define K1, iota and phi1
                K2 = K.extension(g, L1.variable_name() + "1")
                phi2 = K2.hom([alpha], phi)
                k_to_K2 = k.hom(K2)
                K1, K2_to_K1, K1_to_K2 = standard_model_of_finite_extension(
                    k_to_K2)
                phi1 = K1_to_K2.post_compose(phi2)
                iota = K.hom(K2).post_compose(K2_to_K1)
                # we also need a root of g generating K1/K
                beta = K2_to_K1(K2.gen())

                # for defn of psi1 we have the problem that the method "hom"
                # requires different input, depending on the type of field.
                # Using try/except is a somewhat dirty but pragmatic solution
                try:
                    psi1 = L1.hom([beta], K1, psi0)
                except TypeError:
                    psi1 = L1.hom([beta], K1)
                return K1, iota, phi1, psi1
        # if we get here, something went wrong
        raise AssertionError()

    elif is_rational_function_field(L1, L0):
        # then K/k must also be a function field
        t = L1.gen()
        x = K.rational_function_field().gen()
        f = algebraic_relation(L, phi(x), t)
        r, s = f.parent().gens()
        # f is an irreducible bivariate polynomial over L0 such that
        # f(phi(x),t)=0
        assert f(phi(x), t).is_zero()
        # we substitute r:=x and consider f as an univariate polynomial
        # in s over K
        f = f.map_coefficients(psi0, K)
        _, s = f.parent().gens()
        f = f(x, s).polynomial(s).change_ring(K)
        try:
            factorization = f.factor()
        except NotImplementedError:
            from mclf.fields.factor_polynomial_over_function_field \
                import factor_polynomial_over_function_field
            factorization = factor_polynomial_over_function_field(K, f)
        for g, _ in factorization:
            if g.map_coefficients(phi, L)(t).is_zero():
                K1, iota, beta = extend_standard_extension(K, k, g)
                phi1 = K1.hom([t], phi)
                psi1 = L1.hom([beta], psi0)
                return K1, iota, phi1, psi1
        # if we get here, something went wrong
        raise AssertionError()

    else:
        raise NotImplementedError()


# should soon be obsolete; it is only used in "extend_standard_extension" which
# will probably replace by a method of "FiniteExtensionOfStandardFields"
def is_finite_simple_extension(L, K):
    r""" Return whether `L/K` is a finite simple extension of fields.

    """
    return L.base_field() is K and hasattr(L, "polynomial")


# should be replaced by a method (superextension?) of
# FiniteExtensionOfStandardFields
def extend_standard_extension(K, k, g):
    r""" Return a finite extension of a standard extension.

    INPUT:

    - ``K`` -- a field
    - ``k`` -- a subfield of `K` such that `K/k` is a standard extension
    - ``g`` -- an irreducible polynomial over `K`

    OUTPUT:

    a tupel `(K_1,\iota, \beta)`, where

    - `K_1/k` is a standard extension,
    - `\iota:K\to K_1` is an embedding,
    - `\beta\in K_1` is such that `K_1=\iota(K)[\beta]` and `g^\iota(\beta)=0`.


    EXAMPLES::

        sage: from mclf import *
        sage: R.<x> = QQ[]
        sage: K.<theta> = NumberField(x^3 + x + 1)
        sage: g = x^2 + theta*x + 1
        sage: g.factor()
        x^2 + theta*x + 1
        sage: extend_standard_extension(K, QQ, g)
        (Number Field in theta with defining polynomial
         T^6 + 4*T^4 - T^3 + 4*T^2 + 1,
         Ring morphism:
           From: Number Field in theta with defining polynomial x^3 + x + 1
           To:   Number Field in theta with defining polynomial
                 T^6 + 4*T^4 - T^3 + 4*T^2 + 1
           Defn: theta |--> theta^5 + 4*theta^3 - theta^2 + 3*theta,
         theta)

    """
    phi = k.hom(K)
    if is_finite_extension(phi):
        # K/k should be simple
        assert K.base_field() is k
        if K is k:
            L = k.extension(g, "T")
            return L, k.hom(L), L.gen()
        h = K.polynomial()
        beta = K.gen()
        assert h(beta).is_zero()
        K1 = K.extension(g, "T1")
        gamma = K1.primitive_element()
        f = minimal_polynomial(gamma, k)
        L = k.extension(f, K.variable_name())
        try:
            h_roots = [beta_L for beta_L, _ in h.roots(L)]
        except NotImplementedError:
            from mclf.fields.factor_polynomial_over_function_field \
                import roots_of_polynomial_over_function_field
            h_roots = roots_of_polynomial_over_function_field(L, h)
        for beta_L in h_roots:
            try:
                iota = K.hom([beta_L], k.hom(L))
            except:
                iota = K.hom([beta_L])
            g_L = g.map_coefficients(iota, L)
            try:
                roots = [a for a, _ in g_L.roots()]
            except NotImplementedError:
                roots = roots_of_polynomial_over_function_field(L, g_L)
            if len(roots) > 0:
                return L, iota, roots[0]
        # if we get here, something went wrong
        raise AssertionError()
    else:
        from mclf.fields.standard_fields import (
            is_standard_function_field)
        assert is_standard_function_field(K)
        # K/k is a function field, so K1 should be a finite simple extension
        # of the rational subfield K0 = k(x)
        K0 = K.rational_function_field()
        return extend_standard_extension(K, K0, g)


def algebraic_relation(K, x, y):
    r""" Return an algebraic relation between `x` and `y`.

    INPUT:

    - ``K`` -- a function field, with constant base field `k`
    - ``x,y`` -- elements of `K`

    OUTPUT:

    an irreducible bivariate polynomial `f` over `k` such that `f(x,y)=0`.

    EXAMPLES::

        sage: from mclf import *
        sage: K0.<x> = FunctionField(GF(2))
        sage: R.<y> = K0[]
        sage: K.<y> = K0.extension(y^2+x^3+1)
        sage: algebraic_relation(K, x, y)
        x^3 + y^2 + 1
        sage: S.<z> = K[]
        sage: L.<z> = K.extension(z^2+z+x+y)
        sage: algebraic_relation(L, z+1, y)
        x^6 + x^5 + x^4*y + x^4 + x^2*y^2 + x^3 + x^2*y + x*y^2 + y^3 + y^2 + 1

    """
    K0 = K.rational_function_field()
    k = K0.constant_base_field()
    f = minimal_polynomial(x, K0)
    g = minimal_polynomial(y, K0)
    A = PolynomialRing(k, "X, Y, T")
    X, Y, T = A.gens()
    F = bivariate_equation(f)(T, X)
    G = bivariate_equation(g)(T, Y)
    B = PolynomialRing(k, "x, y")
    X, Y = B.gens()
    h = F.resultant(G, T)(X, Y, 0).radical()
    assert len(h.factor()) == 1, "h should be irreducible!?"
    assert h(x, y).is_zero()
    return h


def bivariate_equation(f):
    r"""

    INPUT:

    - ``f`` -- an univariate polynomial over a rational function field `K=k(t)`

    OUTPUT:

    The bivariate polynomial `F\in k[t, x]` obtained from `f` by clearing the
    denominators of the coefficients of `f`.


    EXAMPLES::

        sage: from mclf import *
        sage: K.<t> = FunctionField(QQ)
        sage: R.<x> = K[]
        sage: bivariate_equation(x^3/t + (t+1)*x + t*(t-2))
        t^3 + t^2*x + x^3 - 2*t^2 + t*x

    """
    R = f.parent()
    K = R.base_ring()
    k = K.constant_base_field()
    A = PolynomialRing(k, [K.variable_name(), R.variable_name()])
    t, x = A.gens()
    d = lcm([f[i].denominator() for i in range(f.degree() + 1)])
    f = d * f
    F = sum(f[i].numerator()(t) * x**i for i in range(f.degree() + 1))
    return F


# --------------------------------------------------------------------------

# this should be outdated, or not?

def minimal_polynomial(alpha, K):
    r""" Return the minimal polynomial of `\alpha` over the field `K`.

    INPUT:

    - ``alpha`` -- an elemenent of a field `L`
    - ``K`` -- a subfield of `L` over which `\alpha` is algebraic

    OUTPUT: the minimal polynomial of `\alpha` over `K`.

    """
    L = alpha.parent()
    assert K.is_subring(L), "K must be a subfield of L"
    if K == L:
        from sage.rings.polynomial.polynomial_ring_constructor import (
            PolynomialRing)
        A = PolynomialRing(K, 'T')
        return A.gen() - alpha
    elif L.base_ring() == K:
        return alpha.minpoly('T')
    else:
        A = matrix_of_extension_element(alpha, K)
        f = A.minimal_polynomial('T')
        assert f(alpha) == 0, "Error!"
        return f


def matrix_of_extension_element(alpha, K):
    r""" Return the matrix corresponding to this element
    of the field extension.

    """
    L = alpha.parent()
    M = L.base_ring()
    if M == K:
        return alpha.matrix()
    assert K.is_subring(M), "K must be a subring of M"
    A = alpha.matrix()
    n = A.nrows()
    D = {}
    for i in range(n):
        for j in range(n):
            D[(i, j)] = matrix_of_extension_element(A[i, j], K)
    m = D[(0, 0)].nrows()
    N = n * m
    from sage.matrix.constructor import matrix
    B = matrix(K, N, N)
    for i in range(n):
        for j in range(n):
            for k in range(m):
                for ell in range(m):
                    B[i*m+k, j*m+ell] = D[(i, j)][k, ell]
    return B
