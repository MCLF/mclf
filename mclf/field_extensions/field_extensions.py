# -*- coding: utf-8 -*-
r"""
Field extensions
================



"""

from sage.all import SageObject, lcm
from sage.rings.function_field.constructor import FunctionField
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing


class FieldExtension(SageObject):
    r""" Return the field extension determined by the input.

    INPUT:

    - ``field_extension`` -- data determining a field extension

    OUTPUT: a Sage object representing a field extension.

    The input may be

    - an injective field morphism `\phi:L\to K`,
    - a pair `(L, K)`, where `L` is a field and `K` a subfield of `L`,
    - a triple `(L, K, [t_1,\ldots,t_r])`, where `L` is a field, `K` a subfield
      of `L`, and `t_1,\ldots,t_r` is a list of elements of `L`.

    In the latter case, the field extension `L/K(t_1,\ldots,t_r)` is returned.

    """

    def __init__(self, field_extension):

        if hasattr(field_extension, "is_injective"):
            phi = field_extension
            assert phi.is_injective(), "phi must be injective"
            assert phi.domain().is_field(), "the domain of phi must be a field"
            assert phi.codomain().is_field(), "the codomain of phi must be a field"
            self._domain = phi.domain()
            self._codomain = phi.codomain()
            self._inclusion = phi

        elif isinstance(field_extension, tuple) and len(field_extension) == 2:
            L, K = field_extension
            assert L.is_field(), "L must be a field"
            assert K.is_field(), "K must be a field"
            assert K.is_subring(L), "K must be a subfield of L"
            self._domain = K
            self._codomain = L
            self._inclusion = K.hom(L)

        elif isinstance(field_extension, tuple) and len(field_extension) == 3:
            L, K, generators = field_extension
            assert L.is_field(), "L must be a field"
            assert K.is_field(), "K must be a field"
            assert K.is_subring(L), "K must be a subfield of L"
            self._domain = K
            self._codomain = L
            self._inclusion = K.hom(L)
            generators = [L(t) for t in generators]
            _, ext = self.subextension(generators)
            self.__init__(ext.inclusion())

        else:
            raise NotImplementedError()

    def _repr_(self):
        return "{}, as extension of {}".format(self.codomain(), self.domain())

    def domain(self):
        r""" Return the domain of this field extension, i.e. the base field.
        """
        return self._domain

    def codomain(self):
        r""" Return the codomain of this field extension, i.e. the extension field.
        """
        return self._codomain

    def inclusion(self):
        r""" Return the inclusion morphism from the base field to the extension field.
        """
        return self._inclusion

    def subextension(self, generators, var_name="t"):
        r""" Return the subextension generated by ``generators``.

        Let `L/K` be this field extension.

        INPUT:

        - ``generators`` -- a list of elements of `L`
        - ``var_name`` -- string (default: "t")

        OUTPUT:

        the pair of field extensions `(M/K, L/M)`, where `M:=K(t_1,\ldots,t_r)`
        is the subfield generated over `K` by the elements `t_1,\ldots,t_r`

        """
        K = self.domain()
        L = self.codomain()
        M = K
        phi = self.inclusion()
        if len(generators) > 1:
            raise NotImplementedError("subfield with multiple generators not yet implemented")
        for i, t in enumerate(generators):
            t = L(t)
            if _is_algebraic(t, M):
                M = M.extension(_minimal_polynomial(t, M), var_name+str(i+1))
            else:
                from sage.rings.function_field.constructor import FunctionField
                M = FunctionField(M, var_name+str(i+1))
            phi = M.hom(t, phi)
        return FieldExtension((M, K)), FieldExtension(phi)

    def is_finitely_generated(self):
        r""" Return whether this field extension is finitely generated.

        """
        pass

    def is_finite(self):
        r""" Return whether this field extension is finite.

        """
        pass

    def generators(self):
        r""" Return a list of generators of this field extension.

        """
        pass

    def transcendence_degree(self):
        r""" Return the transcendence degree of this field extension.

        """
        pass

    def degree(self):
        r""" Return the degree of this field extension.

        """
        pass

    def is_transcendential(self, t):
        r""" Return whether this element if transcendental over the base field.

        """
        pass

    def is_algebraic(self, t):
        r""" Return whether this element is algebraic over the base field.

        """
        pass

    def minimal_polynomial(self, t):
        r""" Return the minimal polynomial of this element over the base field.

        """
        pass


def _make_subfield(L, K, generators, var_name="t"):
    r""" Return the subfield of L generated over K by ``generators``.

    INPUT:

    - ``L`` -- a field
    - ``K`` -- a subfield of `L`
    - ``generators`` -- a list of elements of `L`
    - ``var_name`` -- a string (default: "t")

    OUTPUT: an injective field homorphisms, mapping its domain `M` onto the
    subfield `K(t_1,\ldots,t_r)` of `L`, generated over `K` by the elements
    `t_1,\ldots,t_r`.

    """
    M = K
    phi = K.hom(L)
    for i, t in enumerate(generators):
        t = L(t)
        if _is_algebraic(t, M):
            M = M.extension(_minimal_polynomial(t, M), var_name+str(i+1))
        else:
            from sage.rings.function_field.constructor import FunctionField
            M = FunctionField(M, var_name+str(i+1))
        phi = M.hom(t, phi)
    return phi


class FiniteFieldExtension(FieldExtension):

    def norm(self, a):
        pass


# ----------------------------------------------------------------------------

#                       helper functions

def _is_finite_extension_field(L):
    r""" Return whether `L` is a finite extension of its base field.

    """
    return hasattr(L, "polynomial")


def _is_subfield(L, K):
    r""" Return whether `K` is a subfield of `L`.

    Test recursively if `L=K` or if `K` is a subfield of the base field of `L`.

    """
    if L == K:
        return True
    elif hasattr(L, "base_field"):
        M = L.base_field()
        if M == L:
            # L should be a rational function field
            return _is_subfield(L.constant_base_field(), K)
        else:
            # L should be a finite extension of its base_field
            return _is_subfield(M, K)
    else:
        raise NotImplementedError()


def _is_algebraic(alpha, K):
    r""" Return whether alpha is algebraic over K.

    INPUT:

    - ``alpha`` -- an elemenent of a field `L`,
    - ``K`` -- a subfield of `L`.

    OUTPUT: ``True`` if `alpha` is algebraic over `K`, ``False`` otherwise.

    Let `L` be the parent of `\alpha`. We assume that the subfield `K` can be
    reached by recursively applying the methods ``base_field`` or ``constant_base_field`
    to `L`.

    """
    L = alpha.parent()
    assert _is_subfield(L, K), "K must be a subfield of L"
    if L == K:
        return True
    elif _is_finite_extension_field(L):
        # L is a finite simple extension over its base field
        beta = L.base_field()(alpha.norm())
        return _is_algebraic(beta, K)
    else:
        # L is a rational function field over its base field
        return alpha in L.constant_base_field()


def _minimal_polynomial(alpha, K):
    r""" Return the minimal polynomial of `\alpha` over the field `K`.

    INPUT:

    - ``alpha`` -- an elemenent of a field `L`
    - ``K`` -- a subfield of `L` over which `alpha` is algebraic

    OUTPUT: the minimal polynomial of `\alpha` over `K`.

    """
    L = alpha.parent()
    assert K.is_subring(L), "K must be a subfield of L"
    if K == L:
        from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
        A = PolynomialRing(K, 'T')
        return A.gen() - alpha
    elif L.base_ring() == K:
        return alpha.minpoly()
    else:
        A = _matrix_of_extension_element(alpha, K)
        f = A.minimal_polynomial()
        assert f(alpha) == 0, "Error!"
        return f


def _matrix_of_extension_element(alpha, K):
    r""" Return the matrix corresponding to this element of the field extension.

    """
    L = alpha.parent()
    M = L.base_ring()
    if M == K:
        return alpha.matrix()
    assert K.is_subring(M), "K must be a subring of M"
    A = alpha.matrix()
    n = A.nrows()
    D = {}
    for i in range(n):
        for j in range(n):
            D[(i, j)] = _matrix_of_extension_element(A[i, j], K)
    m = D[(0, 0)].nrows()
    N = n*m
    from sage.matrix.constructor import matrix
    B = matrix(K, N, N)
    for i in range(n):
        for j in range(n):
            for k in range(m):
                for ell in range(m):
                    B[i*m+k, j*m+ell] = D[(i, j)][k, ell]
    return B


def _subfield_of_function_field(F, t):
    r""" Return a new presentation of the function field F as finite extension
    of given subfield.

    INPUT:

    - ``F`` -- a function field
    - ``t`` -- a transcendential element of `F`

    Let `K` denote the constant base field of `F`.

    OUTPUT: a pair `(\phi,\psi)` of inverse isomorphisms of function fields

    .. MATH::

        \phi: F_1\to F, \quad \psi=\phi^{-1}:F\to F_1,

    where `F_1=K(t,z)` is a function field with base field the rational function
    field `K(t)` and the isomorphism `\phi` sends `t\in F_1` to the given element
    `t\in F`.

    """
    from sage.rings.function_field.constructor import FunctionField
    from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
    K = F.constant_base_field()
    F0 = F.base_field()
    if F == F0:
        # F is a rational function field
        F0 = FunctionField(K, "t")
        t1 = F0.gen()
        R = PolynomialRing(F0, ["z"])
        g = R(t.numerator())
        h = R(t.denominator())
        f = g - t1*h
        F1 = F0.extension(f)
        z1 = F1.gen()
        phi0 = F0.hom(t)
        phi = F1.hom(F.gen(), phi0)
        psi = F.hom(z1)
        return phi, psi
    else:
        # F is a finite simple extension of the rational function field F0
        A = PolynomialRing(K, ["X", "Y", "T", "Z"])
        X, Y, T, Z = A.gens()

        # construction equation between generators of F
        x = F0.gen()
        y = F.gen()
        f = F.polynomial()
        assert f(y) == 0
        from sage.arith.functions import lcm
        h = lcm([c.denominator() for c in f])
        f = h*f
        g1 = sum([f[i].numerator()(X)*Y**i for i in range(f.degree()+1)])
        assert g1(x, y, T, Z) == 0

        # construct relation between x, y and t
        t_coeffs = t.list()
        h = lcm([c.denominator() for c in t_coeffs])
        t_coeffs = [(h*c).numerator() for c in t_coeffs]
        g2 = h(X)*T - sum(t_coeffs[i](X)*Y**i for i in range(len(t_coeffs)))
        assert g2(x, y, t, Z) == 0

        # construct relation between x, y and z:=x+y
        z = x + y
        g3 = Z - X - Y
        assert g3(x, y, T, z) == 0

        # find the relation between t and z
        J = A.ideal(g1, g2, g3)
        G = J.elimination_ideal([X, Y]).gens()[0]
        for g, _ in G.factor():
            if g(X, Y, t, z) == 0:
                break
        else:
            raise ValueError("We did not find a good factor of G")
        assert len(g.factor()) == 1

        # construct the function field F1
        F0 = FunctionField(K, "t")
        t1 = F0.gen()
        R = PolynomialRing(F0, "z")
        z1 = R.gen()
        g = g(0, 0, t1, Z).univariate_polynomial()(z1).monic()
        F1 = F0.extension(g)
        z1 = F1.gen()

        # wrote x,y as functions of t,z
        R = PolynomialRing(F1, ["X"])
        X = R.gen()
        G1 = g1(X, z1 - X, t1, z1)
        G2 = g2(X, z1 - X, t1, z1)
        G3 = G1.gcd(G2)
        assert G3.degree() == 1
        x1 = - G3[0]
        y1 = z1 - x1
        assert g1(x1, y1, T, Z) == 0

        # construct the morphism phi:F1-->F
        phi0 = F0.hom(t)
        phi = F1.hom(z, phi0)

        # construct the inverse morphism psi:F-->F1
        psi0 = F.base_field().hom(x1)
        psi = F.hom(y1, psi0)

        assert phi(psi(x)) == x
        assert phi(psi(y)) == y
        assert psi(phi(t1)) == t1
        assert psi(phi(z1)) == z1

        return phi, psi


def _new_presentation_of_function_field(F, K, t, generators=None):
    r""" Return a new presentation of the function field F with given base field.

    INPUT:

    - ``F`` -- a function field, with constant base field `L`
    - ``K`` -- a subfield of `L`
    - ``t`` -- a transcendential element of `F`


    OUTPUT:

    A tripel `(F_1,\phi,\psi)`, where `F_1` is a function field with constant
    base field `K`, and

    .. MATH::

        \phi: F_1\to F, \quad \psi=\phi^{-1}:F\to F_1,

    are mutually inverse `K`-isomorphism such that `\phi` sends the generators
    of the base field of `F_1` (a rational function field over `K`) to `t`.

    """
    L = F.constant_base_field()
    assert K.is_subring(L), "K must be a subfield of the constant base field of F"
    F0 = F.base_field()

    if F == F0 and K == L:
        # F is a rational function field over K; this case is much simpler
        F0 = FunctionField(K, "t")
        t1 = F0.gen()
        R = PolynomialRing(F0, ["z"])
        g = R(t.numerator())
        h = R(t.denominator())
        f = g - t1*h
        F1 = F0.extension(f)
        z1 = F1.gen()
        phi0 = F0.hom(t)
        phi = F1.hom(F.gen(), phi0)
        psi = F.hom(z1)
        return (F1, phi, psi)
    elif K == L:
        return _new_presentation_of_function_field_same_base_field(F, t)
    else:
        # the general case;
        # we reduce to the case where K=L
        F1, phi1, psi1 = _make_constant_base_field_smaller(F, K)
        # now F1 is a function field over K, with two generators,
        # phi1:F1 -- > F is a K-isomorphism and psi1 its inverse
        t1 = psi1(t)
        F2, phi2, psi2 = _new_presentation_of_function_field_same_base_field(F1, t1)
        return F2, phi1.pre_compose(phi2), psi2.pre_compose(psi1)


def _new_presentation_of_function_field_same_base_field(F, t):

    # F is a finite simple extension of the rational function field F0 over K
    K = F.constant_base_field()
    F0 = F.base_field()
    assert not F0 == F

    A = PolynomialRing(K, ["X", "Y", "T", "Z"])
    X, Y, T, Z = A.gens()

    # construction equation between generators of F
    x = F0.gen()
    y = F.gen()
    f = F.polynomial()
    assert f(y) == 0
    h = lcm([c.denominator() for c in f])
    f = h*f
    g1 = sum([f[i].numerator()(X)*Y**i for i in range(f.degree()+1)])
    assert g1(x, y, T, Z) == 0

    # construct relation between x, y and t
    t_coeffs = t.list()
    h = lcm([c.denominator() for c in t_coeffs])
    t_coeffs = [(h*c).numerator() for c in t_coeffs]
    g2 = h(X)*T - sum(t_coeffs[i](X)*Y**i for i in range(len(t_coeffs)))
    assert g2(x, y, t, Z) == 0

    # construct relation between x, y and z:=x+y
    z = x + y
    g3 = Z - X - Y
    assert g3(x, y, T, z) == 0

    # find the relation between t and z
    J = A.ideal(g1, g2, g3)
    G = J.elimination_ideal([X, Y]).gens()[0]
    for g, _ in G.factor():
        if g(X, Y, t, z) == 0:
            break
    else:
        raise ValueError("We did not find a good factor of G")
    assert len(g.factor()) == 1

    # construct the function field F1
    F0 = FunctionField(K, "t")
    t1 = F0.gen()
    R = PolynomialRing(F0, "z")
    z1 = R.gen()
    g = g(0, 0, t1, Z).univariate_polynomial()(z1).monic()
    F1 = F0.extension(g)
    z1 = F1.gen()

    # wrote x,y as functions of t,z
    R = PolynomialRing(F1, ["X"])
    X = R.gen()
    G1 = g1(X, z1 - X, t1, z1)
    G2 = g2(X, z1 - X, t1, z1)
    G3 = G1.gcd(G2)
    assert G3.degree() == 1
    x1 = - G3[0]
    y1 = z1 - x1
    assert g1(x1, y1, T, Z) == 0

    # construct the morphism phi:F1-->F
    phi0 = F0.hom(t)
    phi = F1.hom(z, phi0)

    # construct the inverse morphism psi:F-->F1
    psi0 = F.base_field().hom(x1)
    psi = F.hom(y1, psi0)

    assert phi(psi(x)) == x
    assert phi(psi(y)) == y
    assert psi(phi(t1)) == t1
    assert psi(phi(z1)) == z1

    return phi, psi


def _make_constant_base_field_smaller(F, K):
    r""" Return an isomorphic function field with smaller constant base field.

    INPUT:

    - ``F`` -- a function field
    - ``K`` -- a subfield of the constant base field `L` of `F`

    We assume that `L/K` is a finite simple extension.

    OUTPUT:

    A triple `(F_1, \phi, \psi)`, where `F_1` is a function field with constant
    base field `K`, `\phi:F_1\to F` is a `K`-isomorphism and `\psi` is the inverse
    of `\phi`.

    """
    F0 = F.base_field()
    assert not F0 == F, "F must be a proper extension of its base field."
    L = F0.constant_base_field()
    assert F0.base_field() == F0, "F must be a *simple* extension of its base field"
    assert K.is_subring(L), "K must be a subfield of the constant base field of F"
    f = L.polynomial()
    alpha = L.gen()
    assert f(alpha) == 0
    x = F0.gen()
    y = F.gen()
    g = F.polynomial()
    assert g(y) == 0

    A = PolynomialRing(K, ["U", "X", "Y", "Z"])
    U, X, Y, Z = A.gens()
    G1 = f(U)
    assert G1(alpha, X, Y, Z) == 0

    # a helper function
    def make_polynomial_in_UX(h):
        # h is a poynomial in L[x]; we turn it into a polynomial in U and X
        return h.map_coefficients(lambda c: c.polynomial()(U), A)(X)

    h = lcm(c.denominator() for c in g)
    g = h*g
    G2 = sum(make_polynomial_in_UX(g[i].numerator())*Y**i for i in range(g.degree()+1))
    assert G2(alpha, x, y, Z) == 0

    z = y + alpha
    G3 = Z - Y - U
    assert G3(alpha, X, y, z) == 0

    J = A.ideal(G1, G2, G3)
    G = J.elimination_ideal([U, Y]).gens()[0]
    for g, _ in G.factor():
        if g(U, x, Y, z) == 0:
            break
    else:
        raise ValueError("We did not find a good factor of G")
    assert len(g.factor()) == 1

    # construct the function field F1
    F0 = FunctionField(K, "x")
    x1 = F0.gen()
    R = PolynomialRing(F0, "z")
    z1 = R.gen()
    g = g(0, x1, 0, Z).univariate_polynomial()(z1).monic()
    F1 = F0.extension(g)
    z1 = F1.gen()

    # write alpha, y as functions of x, z
    R = PolynomialRing(F1, ["Y"])
    Y = R.gen()
    g1 = G1(z1-Y, x1, Y, z1)
    g2 = G2(z1-Y, x1, Y, z1)
    g3 = g1.gcd(g2)
    assert g3.degree() == 1
    y1 = - g3[0]
    alpha1 = z1 - y1
    assert f(alpha1) == 0

    # construct the morphism phi:F1-->F
    phi0 = F0.hom(x)
    phi = F1.hom(z, phi0)

    # construct the inverse morphism psi:F-->F1
    psi0 = L.hom([alpha1], F1)
    psi1 = F.base_field().hom(F1(x1), base_morphism=psi0)
    psi = F.hom(y1, psi1)

    assert phi(psi(x)) == x
    assert phi(psi(y)) == y
    assert psi(F(phi(alpha1))) == alpha1
    assert psi(F(phi(z1))) == z1

    return phi, psi
