r"""
Fake p-adic completions:
========================

`p`-adic fields as completions of absolute number fields
--------------------------------------------------------

This module realizes a class ``FakepAdicCompletion`` which represents a `p`-adic
number field `K`. Internally, the `p`-adic number field is represented by
a number field `K_0` together with a discrete valuation `v_K` on `K_0` which
extends the `p`-adic valuation `v_p` on `\mathbb{Q}`, such that `K` is the
completion of `K_0` at `v_K`.

Our main goal is to be able to compute *weak `p`-adic Galois extensions* of
`p`-adic number fields of large degree. We want to:

- compute efficiently with general extensions of `\mathbb{Q}_p` of high
  ramification index (up to several hundreds)
- obtain provably correct results.

Both objectives seem difficult to reach with the existing functionality of
``Sage``. Therefore, we decided to represent a `p`-adic number field `K`
by a pair `(K_0, v_K)`, where `K_0` is an *absolute* number field and `v_K` is a discrete
valuation on `K_0` extending the`p`-adic valuation `v_p` on `mathbb{Q}`, for some
prime `p`. A more systematic realization of this idea, Julian Rueth's Sage package
``completion``,  should soon be part of Sage.

The first advantage of our approach (which adresses the first point above) is
that arithmetic in absolute number fields is reasonably fast in ``Sage``.
Moreover, since there are many pairs `(K_0, v_K)` which have the same completion,
we can choose `K_0` in such a way that certain operations we use heavily (like
evaluation of `v_K`) can be done very efficiently. At the moment, we choose
`(K_0,v_K)` such that

- `v_K` is the unique extension of `v_p` to `K_0`,
- `K_0/\mathbb{Q}` is generated by a uniformizer `\pi_K` of `v_K`.

For instance, these assumptions allow us to easily write down a `p`-integral
basis for `K_0/\QQ` which is also an integral basis for `K/\mathbb{Q}_p`.
We can also choose `K_0` such that the defining polynomial has small coefficients.

The second advantage is that, since for most of our needs we do not really need
the `p`-adic number field `K` explicitly, we can instead work with the
*henselization* `K^h` of `(K_0,v_K)` which is an *exact* field: an element of `K^h`
is uniquely determined by a finite amount of data, namely its minimal polynomial
over `\mathbb{Q}` and a sufficiently precise approximation by an element of `K_0`.
Moreover, `K^h` only depends on the `p`-adic number field `K` but not
on our particular choice of `K_0`.

The main drawback of our approach is that morphisms between two `p`-adic number
fields `K` and `L` are somewhat difficult to realize: the problem is
that for our particular choice of the underlying number fields `K_0` and `L_0`,
there may not exist a nonzero morphism `K_0\to L_0` even if `K` is a subfield of
`L`.



AUTHORS:

- Stefan Wewers (2017-08-24): initial version


EXAMPLES:



TO DO:



"""

#*****************************************************************************
#       Copyright (C) 2017 Stefan Wewers <stefan.wewers@uni-ulm.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************


from sage.structure.sage_object import SageObject
from sage.rings.integer_ring import IntegerRing
from sage.rings.rational_field import RationalField
from sage.rings.number_field.number_field import NumberField
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.polynomial.polynomial_element import Polynomial
from sage.rings.integer import Integer
from sage.matrix.constructor import matrix
from sage.matrix.special import zero_matrix, identity_matrix
from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
from sage.rings.finite_rings.integer_mod import mod
from sage.rings.infinity import Infinity
from sage.functions.generalized import sgn
from sage.functions.other import ceil, floor
from sage.geometry.newton_polygon import NewtonPolygon
from sage.misc.misc_c import prod
from sage.arith.misc import lcm
from sage.modules.free_module_element import vector
from mac_lane import *

ZZ = IntegerRing()
QQ = RationalField()



class FakepAdicCompletion(SageObject):
    r"""
    Return the completion of a number field at a `p`-adic valuation.

    INPUT:

    - ``K0`` -- an absolute number field,
    - ``vK`` -- a `p`-adic valuation on ``K0``.

    We assume that `v_K` is the unique extension of the `p`-adic extension `v_p`
    on `\mathbb{Q}` to `K_0`, and that the standard generator `\pi_K` of
    `K_0/\mathbb{Q}` is a uniformizer for `v_K`. If this is not the case, an
    error is raised.

    """
    def __init__(self, K0, vK):
        assert K0.is_absolute(), "K0 must be an absolute number field"
        assert vK.domain() == K0, "K0 must be the domain of vK"
        p = vK.p()
        # we want vK to be normalized such that vK(p)=1
        vK = vK/vK(p)
        assert vK(p) == 1
        R = PolynomialRing(K0, 'x')
        x = R.gen()
        n = K0.degree()
        if n > 1:
            piK = K0.gen()
            e = ZZ(1/vK(vK.uniformizer()))
            f = vK.residue_field().degree()
            assert e*f == n, "vK is not the unique extension of v_p to K"
            assert vK(piK) == 1/e, "the generator of K must be a uniformizer for vK"
            P = K0.polynomial()
            G = P(x+piK).shift(-1)
            S = matrix(QQ, n)
            for i in range(n):
                S[i,i] = p**(i/e).floor()
                # the matrix S has the property that S^(-1)*a.matrix()*S is p-integral,
                # for an element a in O_K; this follows from the fact that
                # pi^i/p^(i/e).floor(), i=0,..,n-1, is a p-integral basis
            is_Qp = False
        else:
            K0 = QQ
            piK = K0(1)
            e = ZZ(1)
            f = ZZ(1)
            P = x-1
            G = R(1)
            S = matrix(K0, 1, [1])
            is_Qp = True
        assert n == e*f
        assert n == P.degree()
        self._number_field = K0
        self._v_p = pAdicValuation(QQ, p)
        self._valuation = vK
        self._p = p
        self._uniformizer = piK
        self._degree = n
        self._ramification_degree = e
        self._inertia_degree = f
        self._polynomial = P
        self._G = G
        self._S = S
        self._is_Qp = is_Qp

    def __repr__(self):
        return "%s-adic completion of %s"%(self.p(), self.number_field())


    def number_field(self):
        r"""
        Return the number field representing this p-adic extension.
        """
        return self._number_field


    def base_valuation(self):
        r"""
        Return the `p`-adic valuation.
        """
        return self._v_p


    def valuation(self):
        r"""
        Return the valuation on the underlying number field of this p-adic extension.
        """
        return self._valuation


    def normalized_valuation(self):
        r"""
        Return the normalized valuation on this p-adic field.

        Here *normalized* means that the valuation takes the value `1 on a
        uniformizer.

        """
        v = self.valuation().scale(self.absolute_ramification_degree())
        assert v(v.uniformizer()) == 1
        return v


    def p(self):
        r"""
        Return the prime `p`.
        """
        return self._p


    def uniformizer(self):
        r"""
        Return the standard unifomizer of this p-adic extension.
        """
        return self._uniformizer


    def generator(self):
        r"""
        Return the standard generator of this p-adic extension.
        """
        return self._generator


    def absolute_degree(self):
        r"""
        Return the degree of this p-adic field as an extension of `\mathbb{Q}_p`.
        """
        return self._degree


    def degree(self):
        r"""
        Return the degree of this p-adic field as an extension of `\mathbb{Q}_p`.
        """
        return self._degree


    def ramification_degree(self):
        r"""
        Return the absolute ramification degree of this p-adic extension.
        """
        return self._ramification_degree


    def absolute_ramification_degree(self):
        r"""
        Return the absolute ramification degree of this p-adic extension.
        """
        return self._ramification_degree


    def absolute_inertia_degree(self):
        r"""
        Return the absolute inertia degree of this p-adic extension.
        """
        return self._inertia_degree


    def inertia_degree(self):
        r"""
        Return the absolute inertia degree of this p-adic extension.
        """
        return self._inertia_degree


    def polynomial(self):
        r"""
        Return the minimal polynomial of the standard generator of `K`.
        """
        return self._polynomial


    def is_Qp(self):
        r"""
        Return ``True`` if this is the padic-completion of the field of rational numbers.

        """
        return self._is_Qp


    def extension(self, f, embedding=False):
        r"""
        Return a `p`-adic extension such that ``f`` has a root in an unramified
        extension of it.

        INPUT:

        - ``f`` -- a monic univariate polynomial over the number field `K0`
          underlying this p-adic extension `K`, which is irreducible over `K`.
        - ``embedding`` -- a boolean (default: ``False``)

        OUTPUT:

        A `p`-adic extension `L` of `K` such that ``f`` has a root
        in an unramified extension of `L`, or (if ``embedding`` is ``True``)
        the pair `(L,\phi)`, where `\phi` is the canonical embedding of
        `K` into `L`.

        If `K_0` is the underlying number field, then `f\in K_0[x]` is irreducible
        over the completion `K`; the resulting finite extension `L/K`
        is a subextension of the extension of `K`

        .. MATH::

                K[x]/(f).

        However, the number field `L_0` underlying `L` is in general not
        equal to `K_0[x]/(f)`, and there may not exist any embedding of `K_0`
        into `L_0`.

        """
        K0 = self.number_field()
        assert K0.has_coerce_map_from(f.parent().base_ring())
        f = f.change_ring(K0)
        R = f.parent()
        x = R.gen()

        vK = self.valuation()
        if embedding:
            raise NotImplementedError

        V = vK.mac_lane_approximants(f)
        assert len(V) == 1, "f is not irreducible"
        v = LimitValuation(V[0], f)
        pix = v.uniformizer()
        r = v(pix)
        for m in range(2,10):
            pix1 = pix.map_coefficients(lambda c:self.reduce(c, m))
            if v(pix1) == r:
                break
        # now pix1 is a polynomial over `K_0` which maps to a uniformizer for the
        # unique extension of vK to the relative extension L=K[x]/(f)/K
        g = self.characteristic_polynomial(f, pix1)
        # now g is the relative characteristic polynomial of the image pi of pix1 in L
        # we need the minimal polynomial, so we do a square free factorization
        g = g.squarefree_decomposition()[0][0]
        # now we compute the absolute characteristic polynomial of a root
        # of g
        Pmod = self.characteristic_polynomial_mod(g, m + 5)
        # m+5 is a purely heuristic choice; there should be a test whether
        # the result is correct, or the choice should be made correctly and
        # optimal from the start

        # first we simply lift the coefficients of Pmod to ZZ, then we try to
        # reduce them as much as possible
        P = Pmod.map_coefficients(lambda c:c.lift(), QQ)
        N = vK(P[0]).ceil() + 1
        n = P.degree()

        L0 = NumberField(P, 'pi%s'%P.degree(), maximize_at_primes=[])
        vL = pAdicValuation(QQ, self.p()).extension(L0)
        return FakepAdicCompletion(L0, vL)


    def ramified_extension(self, n, embedding=False):
        r"""
        Return a purely ramified extension with given ramification degree.

        INPUT:

        - ``n`` -- a positive integer
        - ``embedding`` -- a boolean (default: ``False``)

        OUTPUT:

        A finite extension `L` of this p-adic field `K ` such that `L/K` is
        purely ramified, of degree ``n``. If ``embedding`` is ``True`` then the
        pair `(L,\phi)` is returned, where `\phi:K\to L` is the canonical embedding.

        """
        K0 = self.number_field()
        P = self.polynomial()
        x = P.parent().gen()
        P = P(x**n)
        L0 = NumberField(P, 'pi'+str(P.degree()), maximize_at_primes=[])
        vL = self.base_valuation().extension(L0)
        return FakepAdicCompletion(L0, vL)


    def weak_splitting_field(self, F):
        r"""
        Return the weak splitting field of a list of polynomials.

        INPUT:

        - ``F`` -- a polynomial over the underlying number field `K_0`,
          or a list of polynomials

        OUTPUT:

        A weak splitting field `L/K` of ``F``.

        This means that `F` splits over an unramified extension of `L`.

        Note:

        This function works at the moment only for the base field `\mathbb{Q}_p`.

        """
        if not isinstance(F, Polynomial):
            F = prod(F)
        K = self
        assert F.parent().base_ring() == QQ, "For the time being, F has to be defined over QQ"
        p = K.p()
        while True:
            factor_list = K.approximate_factorization(F, only_ramified_factors=True)
            # here the base field of F needs to coerce into the number
            # field K0 underlying K. When we replace K by an extension, we can
            # guaranteee that this holds only if the base field of F is QQ
            if all([e == 1 for g, e in factor_list]):
                # all factors split over an unramified extension, hence we are done
                return K
            wild_factors = [(g,e) for g, e in factor_list if p.divides(e)]
            totally_wild_factors = [(g, e) for g,e in wild_factors if e.is_prime_power()]
            if totally_wild_factors != []:
                # it is preferable to choose the factors which yield a totally wild extension
                g = totally_wild_factors[0][0]
                K = K.extension(g)
                print "new extension: ", K
            elif wild_factors != []:
                g = wild_factors[0][0]
                K = K.extension(g)
                print "new extension: ", K
            else:
                # we only need a tame extension and then we are done
                n = lcm([e for g, e in factor_list])
                return K.ramified_extension(n)


    def maximal_unramified_subextension(self):
        r"""
        Return the maximal unramified subextension of this `p`-adic number field.

        OUTPUT:

        An unramified extension of `\mathbb{Q}_p` of degree `n`, where
        `n` is the absolute inertia degree of this `p`-adic number field.

        """
        return FakeUnramifiedExtension(self.p(), self.inertia_degree())


#-----------------------------------------------------------------------------

#                   auxiliary functions

    def reduce(self, a, N):
        r"""
        Return an approximation of ``a`` which is reduced modulo `p^N`.

        INPUT:

        - ``a`` -- an element of the underlying number field `K`
        - ``N`` -- a positive Integer

        OUTPUT: an element `\tilde{a}` of `K` which is congruent to `a` modulo `p^N`,
        and whose representation in terms of the canonical integral basis of
        `K` has coefficents of the form `c/p^m`, with `0\leq  c < p^N`
        and `m\geq 0`.

        """
        v_p = self.base_valuation()
        p = self.p()

        if self.is_Qp():
            # a should be a rational number
            m = max(-v_p(a), 0)
            b = a*p**m
            q = p**(N+m)
            return QQ(mod(b, q).lift()*p**(-m))

        v = self.vector(a)
        vt = []
        for i in range(len(v)):
            a = v[i]
            m = max(-v_p(a), 0)
            b = a*p**m
            q = p**(N+m)
            at = mod(b, q).lift()*p**(-m)
            vt.append(at)
        return self.element_from_vector(vector(vt))


    def reduce_rational_number(self, a, N):
        r"""
        Return an approximation of ``a`` which is reduced modulo `p^N`.

        INPUT:

        - ``a`` -- a rational number
        - ``N`` -- a positive Integer

        OUTPUT: an element `\tilde{a}` of `\mathbb{Q}` which is congruent to
        `a` modulo `p^N`, of the form `c/p^m`, with `0\leq  c < p^N`
        and `m\geq 0`.

        """
        v_p = self.base_valuation()
        p = self.p()
        assert a in QQ
        # a should be a rational number
        m = max(-v_p(a), 0)
        b = a*p**m
        q = p**(N+m)
        return QQ(mod(b, q).lift()*p**(-m))


    def matrix(self, a):
        r"""
        Return the matrix representing the element ``a``.

        INPUT:

        - ``a`` -- an element of the underlying number field of this p-adic extension

        OUTPUT:

        The matrix representing the element `a` of the underlying number field
        `K`, with respect to the canonical `p`-integral basis.

        """
        assert a in self.number_field(), "a must be an element of the underlying number field"
        if self.is_Qp():
            return matrix([QQ(a)])
        else:
            S = self._S
            a = self.number_field()(a)
            return S**(-1)*a.matrix()*S


    def vector(self, a):
        r"""
        Return the vector corresponding to an element of `K`.

        INPUT:

        - ``a`` -- an element of the underlying number field `K`

        OUTPUT:

        the vector of coefficients corresponding to the representation
        of `a` as a linear combination of the canonical integral basis of `K`.

        """
        if self.is_Qp():
            return vector([QQ(a)])
        else:
            a = self.number_field()(a)
            return self._S*a.vector()


    def element_from_vector(self, v):
        r"""
        Return the element corresponding to a given vector.

        INPUT:

        - ``v`` -- a vector of rational numbers with length equal to the degree of `K`

        OUTPUT:

        the linear combination of the canonical integral basis of `K`
        corresponding to `v`.

        """
        return self.number_field()(list(self._S**(-1)*v))


    def simplify_irreducible_polynomial(self, f):
        r"""
        Return a simpler polynomial generating the same extension.

        INPUT:

        - ``f`` -- an univariate polynomial over the underlying number field `K`
          which is integral and irreducible over `\hat{K}`

        OUTPUT:

        A polynomial `g` over `K` which is irreducible over `\hat{K}`,
        and which generates the same extension of `\hat{K}` as `f`.

        """
        R = f.parent()
        x = R.gen()
        p = self.p()
        assert R.base_ring() == self.number_field(), "f must be defined over K"
        # first we see if we can normalize f such that the unique slope of the
        # Newton polygon is >-1 and <=0.
        vK = self.valuation()
        NP = NewtonPolygon([(i, vK(f[i])) for i in range(f.degree()+1)])
        slopes = NP.slopes(repetition=False)
        assert len(slopes) == 1, "f is not irreducible over the completion!"
        s = slopes[0]
        assert s <= 0, "f is not integral"
        if s <= -1:
            m = (-s).floor()
            pi = self.uniformizer()
            f = f(pi**m*x).monic()
        # Now we simplify the coefficients of f
        N = vK(f[0]).ceil() + 1
        n = f.degree()
        while True:
            g = R([self.reduce(f[i], N) for i in range(n+1)])
            if self.is_approximate_irreducible_factor(g, f):
                return g
            else:
                N = N + 1


    def is_approximate_irreducible_factor(self, g, f, v=None):
        r"""
        Check whether ``g`` is an approximate irreducible factor of ``f``.

        INPUT:

        - ``g``: univariate polynomial over the underlying number field `K_0`
        - ``f``: univariate polynomial over `K_0`
        - ``v``: a MacLane valuation on `K_0[x]` approximating ``g``, or ``None``;
          here *approximating* means that ``LimitValuation(v, g)`` is well-defined.

        Output: True if ``g`` is an approximate irreducible factor of f, i.e.
        if g is irreducible over `K` and Krasner's condition is satified,
        If true, the stem field of ``g`` over `K` is a subfield of the
        splitting field of ``f`` over `K`.

        Her we say that *Krasner's Condition* holds if for some root `\alpha`
        of `g` there exists a root `\beta` of `f` such that `\alpha` is `p`-adically
        closer to `\beta` than to any other root of `g`.

        Note that if `\deg(g)=1` then the condition is nontrivial, even though
        the conclusion from Krasner's Lemma is trivial.

        """
        K = self.number_field()
        vK = self.valuation()
        assert K.has_coerce_map_from(f.parent().base_ring())
        f = f.change_ring(K)
        R = f.parent()
        assert K.has_coerce_map_from(g.parent().base_ring())
        g = R(g)
        assert g.is_monic(), 'g has to be monic'
        f = f.monic()
        if g == f:
            return True
        x = R.gen()

        if g.degree() == 1:             # the case deg(g)=1 is different
            alpha = -g[0]               # the unique root of g
            F = f(x+alpha)
            if F[0] == 0:               # alpha is an exact root of f
                return True
            np_f = NewtonPolygon([(i, vK(F[i])) for i in range(F.degree()+1)])
            # the slopes correspond to vK(alpha-beta), beta the roots of f
            return ( len(np_f.vertices())>1 and np_f.vertices()[1][0]==1 and
                    np_f.slopes()[0]<0 )

        # now deg(g)>1
        if v == None:
            V = vK.mac_lane_approximants(g)
            if len(V) != 1:
                return False   # g is not irreducible
            v = V[0]
        v = LimitValuation(v, g)
        if v(f) == Infinity:
            return True
        # the valuation v has the property
        #        v(h)=vK(h(alpha))
        # for all h in K[x], where alpha is a root of g

        S = PolynomialRing(R, 'T')
        G = g(x + S.gen()).shift(-1)
        np_g = NewtonPolygon([(i, v(G[i])) for i in range(G.degree()+1)])
        # the slopes of np_g correspond to the valuations of
        # alpha-alpha_i, where alpha_i runs over all roots of
        # g distinct from alpha

        F = f(x + S.gen())
        np_f = NewtonPolygon([(i, v(F[i])) for i in range(F.degree()+1)])
        # the slopes of np_f correspond to the valuations of
        # alpha-beta, where beta runs over all roots of f

        result = min(np_g.slopes()) > min(np_f.slopes())
        # this is true if there is a root beta of f
        # such that vK(alpha-beta)>vK(alpha-alpha_i) for all i
        return result


    def approximate_factorization(self, f, only_ramified_factors=False):
        r"""
        Return a list of approximate irreducible factors of ``f``.

        INPUT:

        - ``f`` -- a squarefree univariate polynomial over `K_0`, the number field
          underlying this p-adic field `K`
        - ``only_ramified_factors`` -- boolean (default: ``False``)

        OUTPUT: a list of pairs `(g,e)`, where `g` is an approximate irreducible
        factor of `f` over `K` and `e>=1`.
        The pairs `(g,e)` are in bijection with the irreducible factors of `f` over
        `K`. If `(g,e)` corresponds to the irreducible factor `f_i' then `g`
        and `f_i` generate the same extension of `K`. In particular, `f_i` and
        `g` have the same degree. Moreover `e` is the ramification degree of the
        extension of `K` generated by `g` (or `f_i`).

        If ``only_ramified_factors`` is ``True`` then all pairs `(g,e)` with
        `e=1` are omitted.

        At the moment we have to assume that `f` is monic and integral
        with respect to `v_K` (and hence all roots have nonnegative valuation).

        """
        assert not f.is_constant(), 'f must not be constant'
        K = self.number_field()
        assert K.has_coerce_map_from(f.parent().base_ring())
        f = f.change_ring(K)
        n = f.degree()
        vK = self.valuation()
        V = vK.mac_lane_approximants(f, assume_squarefree=True, require_maximal_degree=True)
        if only_ramified_factors:
            V = [v for v in V if v.E() > 1]
        V = [LimitValuation(v, f) for v in V]
        factor_list = []
        for v in V:
            while True:
                g = v._approximation.phi()
                if self.is_approximate_irreducible_factor(g, f, v._approximation):
                    break
                else:
                    v._improve_approximation()
            g = self.simplify_irreducible_polynomial(g)
            e = v._approximation.E()
            print "g = ", g
            print "e = ", e
            factor_list.append((g, e))
        return factor_list


    def approximate_irreducible_factor(self, f):
        r"""
        Return one approximate irreducible factor of a given polynomial.

        INPUT:

        - ``f`` -- a squarefree and integral polynomial over the number field
          ``K_0`` underlying this `p`-adic number field `K`.

        Output:

        A monic poynomial `g` over `K_0` which is an approximate irreducible
        factor of `f`. This means that `g` is irreducible over `K` and that
        the extension of `K` generated by adjoining a root of `g` is contained
        in the splitting field of `f`.

        """
        assert not f.is_constant(), 'f must not be constant'
        K = self.number_field()
        assert K.has_coerce_map_from(f.parent().base_ring())
        f = f.change_ring(K)
        n = f.degree()
        vK = self.valuation()
        V = vK.mac_lane_approximants(f, assume_squarefree=True, require_maximal_degree=True)
        v = LimitValuation(V[0], f)
        for i in range(3):
            v._improve_approximation()
            # we do this because the test for being an irreucible factor
            # is quite expensive for large examples
            # the number of iterations is chosen heuristically and so factor
            # a bit arbitrary
        while True:
            g = v._approximation.phi()
            if self.is_approximate_irreducible_factor(g, f, v._approximation):
                return g
            else:
                v._improve_approximation()


    def characteristic_polynomial(self, f, g):
        r"""
        Return the characteristic polynomial of an element of a simple extension
        of `K`.

        INPUT:

        - ``f``, ``g`` -- univariate monic polynomials over `K`

        OUTPUT:

        the characteristic polynomial of the element `\beta=g(\alpha)` with
        respect to the relative extension `L=K[\alpha]/K`, where `\alpha` is
        a formal root of `f`. Of course, `L` is a field only if `f` i irreducible,
        but this is not checked, and no error would occur within this function if
        `f` is reducible.

        """

        # construct the matrix representing alpha as endo of L/K
        K = self.number_field()
        m = f.degree()
        A = matrix(K, m)
        for i in range(m-1):
            A[i+1, i] = K(1)
        for i in range(m):
            A[i, m-1] = -f[i]
        B = g(A)
        # now B represents beta
        return B.charpoly()


    def characteristic_polynomial_mod(self, f, N):
        r"""
        Return the absolute characteristic polynomial of the root of a given
        polynomial, modulo `p^N`.

        INPUT:

        - ``f`` -- a monic `p`-integral and irreducible polynomial over the
          underyling number field `K`
        - ``N`` -- a positive integer

        OUTPUT:

        the absolute characteristic polynomial of a root of `f`, modulo `p^N`.

        """
        # construct the rational representation of a(formal) root alpha of f
        m = f.degree()
        K = self.number_field()
        B = matrix(K, m)
        for i in range(m-1):
            B[i+1, i] = K(1)
        for i in range(m):
            B[i, m-1] = -f[i]
        # construct BB as the matrix representing alpha as endo of L/QQ, modulo p^N
        # note the the function self.matrix gives the representation with respect
        # to a p-integral basis of L/QQ, hence BB should be p-integral
        n = K.absolute_degree()
        R = IntegerModRing(self.p()**N)
        BB = matrix(R, n*m)
        for i in range(m):
            for j in range(m):
                B_ij = self.matrix(B[i,j])
                for k in range(n):
                    for l in range(n):
                        BB[i*n+k, j*n+l] = R(B_ij[k,l])
        return BB.charpoly()


    def minpoly_over_unramified_subextension(self):
        r"""
        Return the minimal polynomial of the standard unifomizer over the
        maximal unramified subextension.

        """
        if not hasattr(self, "_minpoly_over_unramified_subextension"):
            P = self.polynomial()
            Knr = self.maximal_unramified_subextension()
            P = P.change_ring(Knr.number_field())
            P1 = Knr.approximate_irreducible_factor(P)
            v = Knr.valuation().mac_lane_approximants(P1)[0]
            v = LimitValuation(v, P1).scale(P1.degree())
            self._minpoly_over_unramified_subextension = P1
            self._minpoly_over_unramified_subextension_as_valuation = v
        return self._minpoly_over_unramified_subextension


    def minpoly_over_unramified_subextension_as_valuation(self):
        if not hasattr(self, "_minpoly_over_unramified_subextension_as_valuation"):
            self.minpoly_over_unramified_subextension()
        return self._minpoly_over_unramified_subextension_as_valuation

#------------------------------------------------------------------------------



class FakeUnramifiedExtension(FakepAdicCompletion):
    r"""
    Return the unramified extension of the `p`-adics if a given degree.

    INPUT:

    - ``p`` -- a prime number
    - ``n`` -- a positive integer

    OUTPUT:

    the (unique) unramified extension of the field of `p`-adic numbers
    of degree `n`

    """
    def __init__(self, p, n):
        assert p.is_prime(), "p must be a prime number"
        assert n.is_integer(), "n must be an integer"
        v_p = pAdicValuation(QQ, p)
        from sage.rings.finite_rings.finite_field_constructor import GF

        if n > 1:
            g = GF(p**n, 'zeta').polynomial().change_ring(ZZ)
            K0 = NumberField(g, 'zeta'+str(n))
            vK = v_p.extension(K0)
        else:
            K0 = QQ
            vK = v_p
            R = PolynomialRing(QQ, 'x')
            g = R.gen() - R.one()

        self._number_field = K0
        self._v_p = v_p
        self._valuation = vK
        self._p = p
        self._uniformizer = K0(p)
        self._generator = K0.gen()
        self._degree = n
        self._inertia_degree = n
        self._ramification_degree = ZZ(1)
        self._polynomial = g
        self._is_Qp = (n == 1)

    def __repr__(self):
        return "unramified extension of Q_%s of degree %s"%(self.p(), self.degree())


    def vector(self, a):
        r"""
        Return the vector corresponding to an element of `K`.

        INPUT:

        - ``a`` -- an element of the underlying number field `K`

        OUTPUT:

        the vector of coefficients corresponding to the representation
        of `a` as a linear combination of the canonical integral basis of `K`.

        """
        if self.is_Qp():
            return vector([QQ(a)])
        else:
            a = self.number_field()(a)
            return a.vector()


    def element_from_vector(self, v):
        r"""
        Return the element corresponding to a given vector.

        INPUT:

        - ``v`` -- a vector of rational numbers with length equal to the degree of `K`

        OUTPUT:

        the linear combination of the canonical integral basis of `K`
        corresponding to `v`.

        """
        return self.number_field()(list(v))
