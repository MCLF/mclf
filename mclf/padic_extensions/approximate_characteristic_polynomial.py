r"""
Compute the approximate characteristic polynomial with respect to a relative extension
======================================================================================

Let `K` be a number field, `L/K` a finite extension, `\beta\in L` and `p^N` the
power of a prime number. We wish to compute the absolute characteristic
polynomial of `\beta`, modulo `p^N`. If the degree of `K/\mathbb{QQ}` is large,
the naive way of doing this in ``Sage`` is too slow at the moment. In this module
we realize a function ``approximate_characteristic_polynomial`` which hopefully
does this reasonably fast.

The idea is to directly set up the matrix representing the element `\beta`
as a linear map

.. MATH::

    \mathcal{O}_L \to \mathcal{O}_L, x\mapsto \beta x,

but with entries in `\mathbb{Z}/p^N`, and then compute the characteristic
polynomial of this matrix.

For the moment this works only under strong assumptions, which are nevertheless
satisfied when we want to apply this method. We assume:

- the `p`-adic valuation `v_p` has a unique extension `v_K` to `K`
- the generator `\pi` of `K` (as an extension of `\amthbb{Q}`) is a uniformizer
  for `v_K`


"""

from sage.structure.sage_object import SageObject
from sage.matrix.constructor import matrix
from sage.matrix.special import zero_matrix, identity_matrix
from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
from sage.rings.rational_field import RationalField
from sage.rings.number_field.number_field import NumberField
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.integer_ring import IntegerRing
from sage.rings.padics.factory import Qp
from mac_lane import *

ZZ = IntegerRing()

def approximate_characteristic_polynomial(K, f, g, p, N):
    r"""
    Return the characteristic polynomial of an element of a relative number field,
    modulo `p^N`.

    INPUT:

    - ``K`` -- an (absolute) number field
    - ``f``, ``g`` -- univariate monic polynomials over `K`
    - ``p`` -- a prime number
    - ``N`` -- a positive integer

    OUTPUT: a polynomial `P` over the ring ``\mathbb{Z}/p^N``; it is
    the reduction modulo ``\mathbb{Z}/p^N`` of the absolute characteristic
    polynomial of the integral element `\beta:=g(\alpha)\in\mathcal{O}_L`,
    where `L=K[alpha]=K[x]/(f)` is the extension of `K` generated by a root
    `\alpha` of `f`.

    We need to assume a lot of things for this to work:

    - the `p`-adic valuation `v_p` has a unique extension `v_K` to `K`
    - the generator `\pi` of `K` (as an extension of `\amthbb{Q}`) is a uniformizer
      for `v_K`
    - `f` is irreducible over the completion of `K` at `v_K`; this implies that
      `v_K` has a unique extension `v_L` to `L=K[\alpha]`
    - the element `\beta=g(\alpha)` is integral with respect to `v_L`

    We note that the two latter conditions ar enot checked; the last one may
    cause an error if it is not satisfied. Typically, `\beta` will be a
    uniformizer for `v_L` by construction, and then the condition holds.

    """

    # print
    # print "calling approximate_characteristic_polynomial with "
    # print "K = ", K
    # print "f = ", f
    # print "g = ", g
    # print "p^N ", p**N
    # print

    # construct the matrix representing alpha as endo of L/K
    n = K.absolute_degree()
    v_p = pAdicValuation(RationalField(), p)
    if n == 1:
        # we have to force K=QQ to be a number field
        x = PolynomialRing(RationalField(), 'x').gen()
        K = NumberField(x-1, 'z0')
        S = identity_matrix(K, 1)
        vK = v_p
    else:
        V = v_p.extensions(K)
        assert(len(V)) == 1, "the extension of v_p to K must be unique"
        vK = V[0]
        assert vK(vK.uniformizer()) == vK(K.gen()), "the generator of K must be a uniformizer for vK"
        P = K.polynomial()
        e = ZZ(n/v_p(P[0]))  # this is the absolute ramification index of K
        S = matrix(K, n)
        for i in range(n):
            S[i,i] = p**(i/e).floor()
            # the matrix S has the property that S^(-1)*a.matrix()*S is p-integral,
            # for an element a in O_K; this follows from the fact that
            # pi^i/p^(i/e).floor(), i=0,..,n-1, is a p-integral basis

    m = f.degree()
    A = matrix(K, m)
    for i in range(m-1):
        A[i+1, i] = K(1)
    for i in range(m):
        A[i, m-1] = -f[i]
    B = g(A)
    # now B represents beta
    h = B.charpoly()
    assert all(vK(h[i]) >= 0 for i in range(m)), "h is not p-integral"
    # construct another matrix B representing beta, with p-integral coefficients
    B = matrix(K, m)
    for i in range(m-1):
        B[i+1, i] = K(1)
    for i in range(m):
        B[i, m-1] = -h[i]
    # construct BB as the matrix representing beta as endo of L/QQ, modulo p
    #
    R = IntegerModRing(p**N)
    BB = matrix(R, n*m)
    for i in range(m):
        for j in range(m):
            B_ij = S**(-1)*B[i,j].matrix()*S
            for k in range(n):
                for l in range(n):
                    BB[i*n+k, j*n+l] = R(B_ij[k,l])
    P = BB.charpoly()
    return P.map_coefficients(lambda c:IntegerRing()(c), RationalField())
