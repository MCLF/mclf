r"""
Compute the approximate characteristic polynomial with respect to a relative extension
======================================================================================

Let `K` be a number field, `L/K` a finite extension, `\beta\in L` and `p^N` the
power of a prime number. We wish to compute the absolute characteristic
polynomial of `\beta`, modulo `p^N`. If the degree of `K/\mathbb{QQ}` is large,
the naive way of doing this in ``Sage`` is too slow at the moment. In this module
we realize a function ``approximate_characteristic_polynomial`` which hopefully
does this reasonably fast.

The idea is the directly set up the matrix representing the element `\beta`
as a linear map

.. MATH::

    \mathcal{O}_L \to \mathcal{O}_L, x\mapsto \beta x,

but with entries in `\mathbb{Z}/p^N`, and then compute the characteristic
polynomial of this matrix.

"""

from sage.structure.sage_object import SageObject
from sage.matrix.constructor import matrix
from sage.matrix.special import zero_matrix, identity_matrix
from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
from sage.rings.rational_field import RationalField
from sage.rings.number_field.number_field import NumberField
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.integer_ring import IntegerRing
from sage.rings.padics.factory import Qp



def approximate_characteristic_polynomial(K, f, g, p, N):
    r"""
    Return the characteristic polynomial of an element of a relative number field,
    modulo `p^N`.

    INPUT:

    - ``K`` -- an (absolute) number field
    - ``f``, ``g`` -- univariate polynomials over `K`; ``f`` is assumed to be
      monic and both ``f`` and ``g`` must be `p`-integral.
    - ``p`` -- a prime number
    - ``N`` -- a positive integer

    OUTPUT: a polynomial `P` over the ring ``\mathbb{Z}/p^N``; it is
    the reduction modulo ``\mathbb{Z}/p^N`` of the absolute characteristic
    polynomial of the integral element `\beta:=g(\alpha)\in\mathcal{O}_L`,
    where `L=K[alpha]=K[x]/(f)` is the extension of `K` generated by a root
    `\alpha` of `f`.

    So the polynomial `f` is assumed to be irreducible over `K`, but this is not
    checked. If `f` is reducible, no error will occur, but the result may not
    be meaningful.

    """

    print "calling approximate_characteristic_polynomial"
    print "K = ", K
    print "f = ", f
    print "g = ", g
    print "N = ", N
    n = f.degree()
    R = Qp(p, N+1)
    A = SuperMatrix(R, K, n)
    for i in range(n-1):
        A.set_entry(i, i+1, K(1))
    for i in range(n):
        A.set_entry(n-1, i, -f[i])
    B = A.eval_poly(g)
    print "B = ", B
    P = B.charpoly()
    return P.map_coefficients(lambda c: IntegerRing()(c), RationalField())



#-----------------------------------------------------------------------------


class SuperMatrix(SageObject):

    def __init__(self, R, K, n):
        self.R = R
        if K == RationalField():
            x = PolynomialRing(K, 'x').gen()
            K = NumberField(x-1, 'theta')
        self.K = K
        self.n = n
        self.m = K.absolute_degree()
        self.B = matrix(R, self.n*self.m)

    def set_entry(self, i, j, a):
        R = self.R
        B = self.B
        K = self.K
        m = self.m
        A = K(a).matrix()
        for k in range(m):
            for l in range(m):
                B[i*m+k, j*m+l] = R(A[k,l])
                # it is assumed that the entries of A can be coerced into R

    def eval_poly(self, g):
        R = self.R
        n = self.n
        m = self.m
        B = self.B
        C = zero_matrix(R, n*m)
        B_to_i = identity_matrix(R, n*m)
        for i in range(g.degree()+1):
            C = C + B_to_i*self.matrix_of_constant(g[i])
            B_to_i = B_to_i*B
        return C

    def matrix_of_constant(self, a):
        R = self.R
        n = self.n
        m = self.m
        AA = zero_matrix(R, n*m)
        A = self.K(a).matrix()
        for i in range(n):
            for k in range(m):
                for l in range(m):
                    AA[i*m+k, i*m+l] = R(A[k,l])
        return AA
