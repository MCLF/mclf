# -*- coding: utf-8 -*-
r"""
Simple extensions of p-adic number fields
=========================================



AUTHORS:

- Stefan Wewers (2022-2-22): initial version



"""


# *****************************************************************************
#       Copyright (C) 2021 Stefan Wewers <stefan.wewers@uni-ulm.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# *****************************************************************************


from sage.all import (SageObject, QQ, NumberField, IntegerModRing, prod,
                      vector, matrix, Infinity, GaussValuation)


class SimpleExtensionOfpAdicNumberField_new(SageObject):
    r""" A constructor class for a finite simple extension of a p-adic number field.

    INPUT:

    - ``K`` -- a p-adic number field
    - ``f`` -- a monic, integral and irreducible polynomial over `K`, or a
               Krasner class of such polynomials
    - ``name`` -- an alphanumeric string, or ``None`` (default: ``None``)

    OUTPUT: a constructor for the finite extension `L:=K[x]/(f)`.

    The main function of this object is to create an (absolute) p-adic number
    field `L` together with an embedding `K\hookrightarrow L` such that
    `L/K` is generated by an element with minimal polynomial `f`.

    .. NOTE::

    At some point, this class should be made a subclass of  a class
    :class:`pAdicExtension`. Maybe it should be a subclass of both
    ::class:`ExactpAdicExtension` and :class:`ApproximatepAdicExtension`.

    """

    def __init__(self, K, f, name=None):
        from mclf.padic_extensions.approximate_factorizations import ApproximatePrimeFactor
        K_0 = K.number_field()
        if isinstance(f, ApproximatePrimeFactor):
            f = f.approximate_polynomial()
        f = f.change_ring(K_0)
        self._base_field = K
        self._polynomial = f
        # this is a preliminary and ad hoc  choice; in an improved version, the precision
        # should be chosen automatically to be 'just enough'
        self._precision = 5
        if name is None:
            self.name = "alpha{}".format(self.absolute_degree())
        else:
            self.name = name

    def __repr__(self):
        return "constructor for a finite extension of {} with equation {}".format(self.base_field(), self.polynomial())

    def base_field(self):
        return self._base_field

    def polynomial(self):
        r""" Return the polynomial defining this extension.

        OUTPUT: the polynomial `f\in K_0[x]` defining this extension `L=K[x]/(f)`.

        """
        return self._polynomial

    def degree(self):
        r""" Return the degree of this extension `L/K`.
        """
        return self.polynomial().degree()

    def absolute_degree(self):
        r""" Return the degree of the extension field as an absolute p-adic number field.
        """
        return self.degree()*self.base_field().absolute_degree()

    # -----------------------------------------------------------------------
    #            methods for computing the exact extension

    def relative_number_field(self):
        r""" Return the relative number field corresponding to this extension.

        """
        if not hasattr(self, "_relative_number_field"):
            self._relative_number_field = self.base_field().number_field().extension(
                self.polynomial(), "theta")
        return self._relative_number_field

    def valuation_on_relative_number_field(self):
        r""" Return the valuation on the relative number field.

        """
        if not hasattr(self, "_valuation_on_relative_number_field"):
            v_K = self.base_field().valuation()
            L_rel = self.relative_number_field()
            self._valuation_on_relative_number_field = v_K.extension(L_rel)
        return self._valuation_on_relative_number_field

    def integral_generator(self):
        r""" Return the integral generator of this extension.

        """
        if not hasattr(self, "_integral_generator"):
            v = self.valuation_on_relative_number_field()
            if v.residue_field().is_prime_field():
                theta = v.uniformizer()
            else:
                pi = v.uniformizer()
                k = v.residue_field()
                thetab = k.gen()
                theta = v.lift(thetab)
                if hasattr(k, "base_field"):
                    # this probably means that k is not a true finite field
                    from mclf.curves.smooth_projective_curves import make_finite_field
                    _, phi, _ = make_finite_field(k)
                    thetab = phi(thetab)
                h = thetab.minpoly().change_ring(QQ)
                if v(h(theta)) != v(pi):
                    theta = theta + pi
            self._integral_generator = theta
        return self._integral_generator

    def exact_extension_field(self):
        r""" Return the exact extension field.

        """
        if not hasattr(self, "_exact_extension_field"):
            beta = self.integral_generator()
            F = beta.absolute_minpoly()
            L = NumberField(F, self.name)
            self._exact_extension_field = L
        return self._exact_extension_field

    def relative_base_change_matrix(self):
        r""" Return the relative base change matrix.

        We return the inverse of the matrix `T` whose columns are the coordinate
        vectors of the powers `1,\beta,\ldots,\beta^{m-1}`, with respect to the
        standard basis of this relative extension `L/K`.

        """
        if not hasattr(self, "_relative_base_change_matrix"):
            m = self.degree()
            K = self.base_field()
            L = self.relative_number_field()
            beta = self.integral_generator()
            intbasis = []
            b = L.one()
            for i in range(m):
                intbasis.append(b)
                if i < m-1:
                    b = b*beta
            # we create a matrix whose columns correspond to the
            # elements of the integral basis; this is the inverse of S
            T = matrix(K.number_field(), m)
            for i in range(m):
                for j in range(m):
                    T[i, j] = intbasis[j][i]
            self._inverse_relative_base_change_matrix = T
            self._relative_base_change_matrix = T.inverse()
        return self._relative_base_change_matrix

    def inverse_relative_base_change_matrix(self):
        r""" Return the relative inverse base change matrix.

        """
        if not hasattr(self, "_inverse_relative_base_change_matrix"):
            self.relative_base_change_matrix()
        return self._inverse_relative_base_change_matrix

    def coordinate_vector(self, a):
        r""" Return the coordinate vector corresponding to an eleent of this
        extension.

        INPUT:

        - ``a`` -- an element of the relative nuber field representing this extension

        OUTPUT:

        The coordinate vector of `a` with respect to the first integral basis
        (see definition below).

        Let `L/K` be this extension, `\alpha` the canonical integral generator
        of `K` and `\beta` be the new integral generator of `L`.
        Let `n=[K:\mathbb{Q}_p]` and `m=[L_K]`.

        The *first integral basis* consists of the elements

        .. MATH::

            `\alpha^i\beta^j`,

        where `i=0,\ldots,n-1` and `j=0,\ldots,m-1.

        """
        from sage.all import vector
        K = self.base_field()
        n = K.degree()
        L = self.relative_number_field()
        a = L(a)
        rel_vector = self.relative_base_change_matrix()*a.vector()
        m = L.relative_degree()
        v = []
        for j in range(m):
            for i in range(n):
                v.append(rel_vector[j][i])
        return vector(v)

    def exact_transition_matrix(self):
        r""" Return the exact transition matrix.

        Let `L/K` be this extension, `\alpha` the canonical integral generator
        of `K` and `\beta` be the new integral generator of `L`.
        Let `n=[K:\mathbb{Q}_p]` and `m=[L_K]`.

        Then we have two integral bases for `L`:

        - the basis with elements `\alpha^i\beta^j`, where `i=0,\ldots,n-1`
          and `j=0,\ldots,m-1`, and
        - the basis with elements `\beta^k`, where `k=0,\ldots,nm-1`.

        The *transition matrix* is the matrix of the base change from the first
        to the second basis. This means that the columns consist of the elements
        of the second basis, written as coordinate vectors wrt the first basis.

        """
        from sage.all import GF
        if not hasattr(self, "_exact_transition_matrix"):
            N = self.absolute_degree()
            rows = []
            beta = self.integral_generator()
            gamma = self.relative_number_field().one()
            for k in range(N):
                rows.append(self.coordinate_vector(gamma))
                gamma = gamma*beta
            A = matrix(QQ, N, rows).transpose()
            # we test whether A is unimodular
            p = self.base_field().p()
            Ab = A.change_ring(GF(p))
            assert Ab.is_invertible(), "something is wrong: A is not unimodular"
            self._exact_transition_matrix = A
        return self._exact_transition_matrix

    def exact_extension(self):
        r""" Return the exact extensions represented by this constructor.

        OUTPUT: an object of the class :class:`ExactpAdicExtension`, representing
        this simple extension `L/K`.

        This means that the number field `L_0` underlying `L` is a (simple)
        extension of `K_0`, the number field underlying `K`.

        .. NOTE::

            At the moment, there is an error in this construction: the absolute
            number field `L_0` constructed below may not satisfy the condition
            that its generator generates the ring of integers of its p-adic
            completion.

        """
        if hasattr(self, "_exact_extension"):
            return self._exact_extension
        from mclf.padic_extensions.padic_number_fields import pAdicNumberField
        from mclf.padic_extensions.padic_embeddings import ExactpAdicEmbedding
        from mclf.padic_extensions.padic_extensions import ExactpAdicExtension

        K = self.base_field()
        K_0 = K.number_field()
        L_0 = self.exact_extension_field()
        v_p = self.base_field().base_valuation()
        v_L = v_p.extension(L_0)
        L = pAdicNumberField(L_0, v_L)

        # we find the embedding of K_0 into L_0
        alpha = K.generator()
        v = self.coordinate_vector(alpha)
        A = self.exact_transition_matrix()
        v = A.solve_right(self.coordinate_vector(alpha))
        N = L.absolute_degree()
        beta = L.generator()
        beta_k = L_0.one()
        alpha_0 = L_0.zero()
        for k in range(N):
            alpha_0 += v[k]*beta_k
            beta_k = beta_k*beta
        phi = K_0.hom(alpha_0, L_0)
        L = ExactpAdicExtension(ExactpAdicEmbedding(K, L, phi))
        self._exact_extension = L
        return L

    # ------------------------------------------------------------------------
    #           methods for computing the approximate extension

    def approximate_extension(self):
        r""" Return the approximate extensions represented by this constructor.

        OUTPUT: an object of the class :class:`ExactpAdicExtension`, representing
        this simple extension `L/K`.

        This means that the number field `K_0` underlying `K` will probably not
        be a subfield of `L_0`, the number field underlying `L`. Therefore,
        we don not have an exact embedding of `K` into `L`, but only an
        *approximate* embedding.

        """
        if hasattr(self, "_approximate_extension"):
            return self._approximate_extension
        from mclf.padic_extensions.padic_extensions import ApproximatepAdicExtension
        phi = ApproximatepAdicExtension(self.approximate_embedding())
        self._approximate_extension = phi
        return phi

    def extension_field(self):
        r""" Return the extension field as an absolute `p`-adic number field.

        """
        from mclf.padic_extensions.padic_number_fields import pAdicNumberField
        if not hasattr(self, "_extension_field"):
            p = self.base_field().p()
            g = self.integral_generator()
            f, A = self.approximate_equation_for_generator(g)
            L_0 = NumberField(f, self.name)
            v_L = QQ.valuation(p).extension(L_0)
            self._extension_field = pAdicNumberField(L_0, v_L)
            self._approximate_matrix_for_generator = A
        return self._extension_field

    def approximate_embedding(self):
        r""" Return the embedding of the base field into the extension field.

        OUTPUT: the canonical embedding `\phi:K\hookrightarrow L` of absolute
        `p`-adic number fields, where `K` is the base field and `L` the extension
        field.

        ALGORITHM: By the construction of `L\cong K[\alpha]:=K[x]/(f)` as an
        absolute p-adic number field `L=\mathbb{Q}_p(\beta)`, we know an
        approximation of the matrix `B` representing the endomorphism of
        `K[\alpha]` corresponding to multiplication by `\beta`, with respect to
        the absolute integral basis of `K[\alpha]`. From this information it is
        easy to find the matrix `A'` representing the isomorphism `L\cong K[\alpha]`
        with respect to the basis `(1,\beta,\ldots,\beta^{n-1})` of `L` and the
        absolute integral basis of `K[\alpha]`. Thus, the matrix representing this
        isomorphism with respect to the integral basis of `L` is

        .. MATH::

            A := A'*S,

        where `S` is the base change matrix for the absolute `p`-adic number
        field `L`. Inverting `A` gives us the isomorphism `K[\alpha]\cong L`,
        which we may restrict to the subfield `K`.

        """
        from mclf.padic_extensions.padic_embeddings import pAdicEmbedding
        from mclf.padic_extensions.elements_of_padic_number_fields import (
            ElementOfpAdicNumberField_algebraic)
        if hasattr(self, "_approximate_embedding"):
            return self._approximate_embedding
        K = self.base_field()
        m = K.degree()
        v = K.vector(K.generator())
        L = self.extension_field()
        n = L.degree()
        int_basis_L = L.integral_basis()
        B = self._approximate_matrix_for_generator
        R = B.base_ring()
        u = vector(R, n)
        u[0] = R.one()
        columns = [u]
        for i in range(n-1):
            u = B*u
            columns.append(u.change_ring(QQ))
        A = matrix(QQ, columns).transpose()
        A_i = self.approximate_inverse_of_matrix(A)
        alpha = L.number_field().zero()
        for j in range(m):
            alpha += v[j]*sum(A_i[i, j]*int_basis_L[i] for i in range(n))
        # it is not at all transparent to which precision the matrix A_i
        # has been computed; the required precision depends, it seems, only on
        # the polynomial defining K, and could be computed in advance

        alpha = ElementOfpAdicNumberField_algebraic(L, alpha, K.polynomial())
        phi = pAdicEmbedding(K, L, alpha)
        self._approximate_embedding = phi
        # this computation can get ridiculously large; it would be better to do
        # over ZZ/p^N and only lift to QQ at the very end
        return phi

    def pseudovaluation(self):
        r""" Return the pseudovaluation corresponding to the equation defining this extension.

        OUTPUT: the infinite pseudovaluation `v_f` on `K_0[x]` extending `v_K`
        such that `v_f(f)=\infty`.

        Here `K_0` is the number field underlying the base field `K` and `f` is
        the equation defining this extension `L=K[x]/(f)`.

        """
        if not hasattr(self, "_pseudovaluation"):
            K = self.base_field()
            v_K = K.valuation()
            f = self.polynomial()
            v = GaussValuation(f.parent(), v_K)
            while v(f) < Infinity:
                V = v.mac_lane_step(f)
                assert len(V) == 1, "f is not irreducible"
                v = V[0]
            self._pseudovaluation = v
        return self._pseudovaluation

    def relative_integral_basis(self):
        r""" Return a relative integral basis for this extension.

        OUTPUT: a list of polynomials with coefficients in the number field
        underlying the base field, whose images in `L=K[x]/(f)` form an integral
        basis of `L`, with respect to the unique extension of `v_K` to `L`.

        ALGORITHM: we use MacLane's theory of inductive valuations. Let

        .. MATH::

            v_f = [v_0, v_1(\phi_1)=t_1,\ldots,v_n(\phi_n)=\infty]

        be the representation of the infinite pseudovaluation `v_f` corresponding
        to `f` as an inductive valuation. (Note that `\phi_n=f`).
        We may assume that

        .. MATH::

            \deg(\phi_1) < \ldots < \deg(\phi_n).

        Then an integral basis of `L` is given by the polynomials

        .. MATH::

            \frac{\phi_1^{m_1}\cdots\phi_{n-1}^{m_{n-1}}{\pi_K^{a_m}},

        where `m=(m_1,\ldots,m_{n-1})` runs over tupels of nonnegative integers
        such that

        .. MATH::

            m_1\deg(\phi_1) + \ldots + m_i\deg(\phi_i) < \deg(\phi_{i+1})

        for `i=1, \ldots , n-1` and

        .. MATH::

            a_m = \frac{ m_1t_1 + \ldots + m_{n-1}t_{n-1} }{ v_K(\pi_K) }.

        """
        if hasattr(self, "_relative_integral_basis"):
            return self._relative_integral_basis

        K = self.base_field()
        pi_K = K.uniformizer()
        e = K.absolute_ramification_degree()
        assert K.valuation()(pi_K)*e == 1
        v_f = self.pseudovaluation()
        aug_chain = v_f.augmentation_chain()
        phi = [aug_chain[i].phi() for i in range(len(aug_chain)-2, -1, -1)]
        if len(phi) == 0:
            phi = [v_f.domain().gen()]
        elif phi[0].degree() > 1:
            phi = [v_f.domain().gen()] + phi
        d = [phi[i].degree() for i in range(len(phi))]
        t = [v_f(phi[i]) for i in range(len(phi))]
        assert all(d[i] < d[i+1] for i in range(len(d)-1)), "the augmented valuation v_f = {} is not in reduced form!".format(v_f)
        integral_basis = []
        # we have to loop over all m=(m_1,..,m_r) such that m_1d_1+..+m_rd_r <= n
        for m in exponents_of_phi(d):
            g = prod(phi[i]**m[i] for i in range(len(m)))
            s = (e*sum(t[i]*m[i] for i in range(len(m)))).floor()
            integral_basis.append(g*pi_K**(-s))
        assert len(integral_basis) == self.degree()
        self._relative_integral_basis = integral_basis
        return integral_basis

    def base_change_matrix(self):
        r""" Return the base change matrix from the canonical to the relative integral basis.

        OUTPUT: a square matrix `S` over `K_0`, the number field underlying the
        base field of this extension. The matrix `S` is characterized by the
        following property:

        Let `\beta=g(\alpha)` be an element of this extension `L=K[\alpha]`,
        with `g=g_0+g_1x+\ldots+g_{n-1}x^{n-1}\in K_0[x]`.
        Let `u = (g_0,\ldots,g_{n-1})\in K_0^n` be the vector corresponding to
        `g` with respect to the canonical basis. Let `(\alpha_1,\ldots,\alpha_n)`
        be the (relative integral basis of `K[\alpha]/K`. Then

        .. MATH::

            \beta = b_1\alpha_1+\ldots+b_n\alpha_n,

        where

        .. MATH::

            S\cdot u = (b_1,\ldots,b_n).

        """
        if not hasattr(self, "_base_change_matrix"):
            n = self.degree()
            int_basis = self.relative_integral_basis()
            # we create a matrix whose columns correspond to the
            # elements of the integral basis; this is the inverse of S
            T = matrix(self.base_field().number_field(), n)
            for i in range(n):
                for j in range(n):
                    T[i, j] = int_basis[j][i]
            self._inverse_base_change_matrix = T
            self._base_change_matrix = T.inverse()
        return self._base_change_matrix

    def inverse_base_change_matrix(self):
        r""" Return the inverse base change matrix, from the relative integral to the canonical basis.

        """
        if not hasattr(self, "_inverse_base_change_matrix"):
            self._inverse_base_change_matrix = self.base_change_matrix().inverse()
        return self._inverse_base_change_matrix

    def integral_generator_old(self):
        r""" Return an equation for a integral generator.

        OUTPUT:

        a polynomial `g\in K_0[x]` such that `\beta:=g(\alpha)` is an
        absolute integral generator for this simple extension `L=K[\alpha]`
        (here integral means that its powers yield an integral basis)


        ALGORITHM:

        We use the trick from the proof of Lemma II.10.4 from Neukirch's book.

        """
        v = self.pseudovaluation()
        if v.residue_field().is_prime_field():
            return v.uniformizer()
        else:
            pi = v.uniformizer()
            k = v.residue_field()
            thetab = v.residue_field().gen()
            theta = v.lift(thetab)
            if hasattr(k, "base_field"):
                # this probably means that k is not a true finite field
                from mclf.curves.smooth_projective_curves import make_finite_field
                _, phi, _ = make_finite_field(k)
                thetab = phi(thetab)
            h = thetab.minpoly().change_ring(QQ)
            if v(h(theta)) == v(pi):
                return theta
            else:
                return theta + pi

    def relative_matrix_of_generator(self):
        r""" Return the matrix representing the canonical generator of this extension.

        OUTPUT: a square matrix `A` over the number field `K_0` underlying the base
        field `K` of this extension. The matrix `A` represents the endomorphism
        of this extension `L/K` corresponding to the canonical generator. The
        matrix representation is with respect to the relative integral basis of `L/K`.

        """
        if hasattr(self, "_matrix_of_generator"):
            return self._matrix_of_generator
        K = self.base_field()
        K_0 = K.number_field()
        f = self.polynomial()
        m = f.degree()
        A = matrix(K_0, m)
        S = self.base_change_matrix()
        S_i = self.inverse_base_change_matrix()
        for i in range(m-1):
            A[i+1, i] = K_0(1)
        for i in range(m):
            A[i, m-1] = -f[i]
        return S*A*S_i

    def relative_matrix(self, g):
        r""" Return the matrix representing an approximation of an element of this extension.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a square matrix over `K_0`, representing the element `g(\alpha)`
        as an endomorphism of this extension `L=K[\alpha]/K`, with respect to the
        relative integral basis.

        """
        K = self.base_field()
        K_0 = K.number_field()
        g = g.change_ring(K_0)
        return g(self.relative_matrix_of_generator())

    def relative_vector(self, g):
        r""" Return the vector corresponding to an element of this extension,
        with respect to the relative integral basis.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a vector `v=(a_1,\ldots,a_n)` over `K_0` such that

        .. MATH::

            g = a_1g_1 + \ldots + a_ng_n,

        and where `(g_1,\ldots,g_n)` is the fixed relative integral basis of
        this extension.

        """
        n = self.degree()
        f = self.polynomial()
        _, g = f.quo_rem(g)
        v = vector([g[i] for i in range(n)])
        return self.inverse_base_change_matrix()*v

    def element_from_relative_vector(self, v):
        r""" Return the element of this extension corresponding to a vector,
        with respect to the relative integral basis.

        INPUT:

        - ``v`` -- a vector over the number field `K_0` underlying the base field,
                   of length the degree of this extension

        OUTPUT: the element of this extension corresponding to the polynomial

        ..MATH::

            g = a_1g_1 + \ldots + a_ng_n,

        where `v=(a_1,\ldots,a_n)` and `(g_1,\ldots,g_n)` is the fixed relative
        integral basis.

        """
        return v*vector(self.relative_integral_basis())

    def absolute_integral_basis(self):
        r""" Return an absolute integral basis for this extension.

        OUTPUT: a list of polynomials with coefficients in the number field
        underlying the base field, whose images in `L=K[x]/(f)` form an integral
        basis over `\mathbb{Z}_p} of `L`, with respect to the unique extension
        of `v_K` to `L`.

        """
        K = self.base_field()
        base_int_basis = K.integral_basis()
        rel_int_basis = self.relative_integral_basis()
        abs_int_basis = []
        for g in rel_int_basis:
            for theta in base_int_basis:
                abs_int_basis.append(theta*g)
        return abs_int_basis

    def absolute_matrix(self, g):
        r""" Return a matrix representing an element of this extension.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a square matrix `B` over `\mathbb{Q}`, representing the element
        `\beta=g(\alpha)` as an endomorphism of this extension `L=K[\alpha]`, as a
        vector space over `\mathbb{Q}`, with respect to the absolute integral basis.

        If `\beta` is integral then the entries of `B` should be `p`-integers.

        """
        m = self.degree()
        K = self.base_field()
        A = self.relative_matrix(g)
        # construct B as the matrix representing alpha as endo of L/QQ.
        n = K.absolute_degree()
        B = matrix(QQ, n*m)
        for i in range(m):
            for j in range(m):
                B_ij = K.matrix(A[i, j])
                for k in range(n):
                    for r in range(n):
                        B[i*n+k, j*n+r] = B_ij[k, r]
        return B

    def element_from_absolute_vector(self, v):
        int_basis = self.absolute_integral_basis()
        return sum(v[i]*int_basis[i] for i in range(len(int_basis)))

    def precision(self):
        return self._precision

    def raise_precision(self):
        self._precision = self._precision + 2
        if self._precision > 20:
            raise AssertionError("Maximal precision reached; probably something is wrong!")

    def approximate_inverse_of_matrix(self, A):
        r""" Return an approximate inverse of this matrix.

        INPUT:

        - `A` -- a square matrix over the rationals

        It is assumed that the entries of `A` are `p`-integral, and that `A` is
        invertible over the ring `\mathbb{Z}_{(p)}`.

        OUTPUT: a matrix `B` over `\mathbb{Q}` which is an approximate inverse
        of `A`; more precisely, the coefficients of `B` are integers, and

        .. MATH::

            A\cdot B \equiv B\cdot A \equiv 1 \pmod{p^N},

        where `N` is the *precision* used for computing the extension field.

        """
        p = self.base_field().p()
        N = self.precision()
        R = IntegerModRing(p**N)
        Ab = A.change_ring(R)
        Ab_i = Ab.inverse()
        return Ab_i.change_ring(QQ)

    def approximate_equation_for_generator(self, g, matrix=True):
        r""" Return an approximate absolute equation for a given generator.

        INPUT:

        - ``g`` -- a polynomial over the number field underlying the base field
        - ``matrix`` -- a boolean

        We assume that `\beta=g(\alpha)` is an absolute generator of the p-adic
        number field `L=K[\alpha]` defined by this extension.

        OUTPUT: a polynomial `f` over `\mathbb{Q}`, which is a Krasner
        approximation of the absolute minimal polynomial of `\beta`.

        If ``matrix`` is ``True`` then the pair `(f, A)` is returned, where
        `A` is the matrix representing the the endomorphism of `L/\mathbb{Q}`
        corresponding to `\beta`, with respect to the integral basis.

        """
        A = self.absolute_matrix(g)
        p = self.base_field().p()
        e = self.pseudovaluation().E()*self.base_field().ramification_degree()
        while True:
            R = IntegerModRing(p**self.precision())
            Ab = A.change_ring(R)
            fb = Ab.charpoly()
            f = fb.change_ring(QQ)
            if f.is_squarefree():
                v = GaussValuation(f.parent(), QQ.valuation(p))
                while v(f) < Infinity:
                    V = v.mac_lane_step(f)
                    if len(V) > 1:
                        break
                    else:
                        v = V[0]
                if v(f) == Infinity and v.E() == e:
                    if matrix:
                        return (f, Ab)
                    else:
                        return f
            self.raise_precision()
            # if the precison is greater then a certain threshold, an error
            # is raised. The reason is that probably the chosen element g
            # does not correspond to a generator.


# ---------------------------------------------------------------------------


class SimpleExtensionOfpAdicNumberField(SageObject):
    r""" A constructor class for a finite simple extension of a p-adic number field.

    INPUT:

    - ``K`` -- a p-adic number field
    - ``f`` -- a monic, integral and irreducible polynomial over `K`, or a
               Krasner class of such polynomials
    - ``name`` -- an alphanumeric string, or ``None`` (default: ``None``)

    OUTPUT: a constructor for the finite extension `L:=K[x]/(f)`.

    The main function of this object is to create an (absolute) p-adic number
    field `L` together with an embedding `K\hookrightarrow L` such that
    `L/K` is generated by an element with minimal polynomial `f`.

    .. NOTE::

    At some point, this class should be made a subclass of  a class
    :class:`pAdicExtension`. Maybe it should be a subclass of both
    ::class:`ExactpAdicExtension` and :class:`ApproximatepAdicExtension`.

    """

    def __init__(self, K, f, name=None):
        from mclf.padic_extensions.approximate_factorizations import ApproximatePrimeFactor
        K_0 = K.number_field()
        if isinstance(f, ApproximatePrimeFactor):
            f = f.approximate_polynomial()
        f = f.change_ring(K_0)
        self._base_field = K
        self._polynomial = f
        # this is a preliminary and ad hoc  choice; in an improved version, the precision
        # should be chosen automatically to be 'just enough'
        self._precision = 5
        if name is None:
            self.name = "alpha{}".format(self.absolute_degree())
        else:
            self.name = name

    def __repr__(self):
        return "constructor for a finite extension of {} with equation {}".format(self.base_field(), self.polynomial())

    def exact_extension(self):
        r""" Return the exact extensions represented by this constructor.

        OUTPUT: an object of the class :class:`ExactpAdicExtension`, representing
        this simple extension `L/K`.

        This means that the number field `L_0` underlying `L` is a (simple)
        extension of `K_0`, the number field underlying `K`.

        """
        if hasattr(self, "_exact_extension"):
            return self._exact_extension
        from mclf.padic_extensions.padic_number_fields import pAdicNumberField
        from mclf.padic_extensions.padic_embeddings import ExactpAdicEmbedding
        from mclf.padic_extensions.padic_extensions import ExactpAdicExtension
        K = self.base_field()
        K0 = K.number_field()
        L0_rel = K0.extension(self.polynomial(), self.name)
        L0 = L0_rel.absolute_field(self.name + "_a")
        _, psi = L0.structure()  # psi is the isomorphism from L0_rel to L0
        L = pAdicNumberField(L0, K.base_valuation())
        phi = K0.hom(L0_rel).post_compose(psi)
        L_exact = ExactpAdicExtension(ExactpAdicEmbedding(K, L, phi))
        self._exact_extension = L_exact
        return L_exact

    def approximate_extension(self):
        r""" Return the approximate extensions represented by this constructor.

        OUTPUT: an object of the class :class:`ExactpAdicExtension`, representing
        this simple extension `L/K`.

        This means that the number field `K_0` underlying `K` will probably not
        be a subfield of `L_0`, the number field underlying `L`. Therefore,
        we don not have an exact embedding of `K` into `L`, but only an
        *approximate* embedding.

        """
        if hasattr(self, "_approximate_extension"):
            return self._approximate_extension
        from mclf.padic_extensions.padic_extensions import ApproximatepAdicExtension
        phi = ApproximatepAdicExtension(self.approximate_embedding())
        self._approximate_extension = phi
        return phi

    # ----------------------------------------------------------------------

    def base_field(self):
        return self._base_field

    def extension_field(self):
        r""" Return the extension field as an absolute `p`-adic number field.

        """
        from mclf.padic_extensions.padic_number_fields import pAdicNumberField
        if not hasattr(self, "_extension_field"):
            p = self.base_field().p()
            g = self.integral_generator()
            f, A = self.approximate_equation_for_generator(g)
            L_0 = NumberField(f, self.name)
            v_L = QQ.valuation(p).extension(L_0)
            self._extension_field = pAdicNumberField(L_0, v_L)
            self._approximate_matrix_for_generator = A
        return self._extension_field

    def approximate_embedding(self):
        r""" Return the embedding of the base field into the extension field.

        OUTPUT: the canonical embedding `\phi:K\hookrightarrow L` of absolute
        `p`-adic number fields, where `K` is the base field and `L` the extension
        field.

        ALGORITHM: By the construction of `L\cong K[\alpha]:=K[x]/(f)` as an
        absolute p-adic number field `L=\mathbb{Q}_p(\beta)`, we know an
        approximation of the matrix `B` representing the endomorphism of
        `K[\alpha]` corresponding to multiplication by `\beta`, with respect to
        the absolute integral basis of `K[\alpha]`. From this information it is
        easy to find the matrix `A'` representing the isomorphism `L\cong K[\alpha]`
        with respect to the basis `(1,\beta,\ldots,\beta^{n-1})` of `L` and the
        absolute integral basis of `K[\alpha]`. Thus, the matrix representing this
        isomorphism with respect to the integral basis of `L` is

        .. MATH::

            A := A'*S,

        where `S` is the base change matrix for the absolute `p`-adic number
        field `L`. Inverting `A` gives us the isomorphism `K[\alpha]\cong L`,
        which we may restrict to the subfield `K`.

        """
        from mclf.padic_extensions.padic_embeddings import pAdicEmbedding
        from mclf.padic_extensions.elements_of_padic_number_fields import (
            ElementOfpAdicNumberField_algebraic)
        if hasattr(self, "_approximate_embedding"):
            return self._approximate_embedding
        K = self.base_field()
        m = K.degree()
        v = K.vector(K.generator())
        L = self.extension_field()
        n = L.degree()
        int_basis_L = L.integral_basis()
        B = self._approximate_matrix_for_generator
        R = B.base_ring()
        u = vector(R, n)
        u[0] = R.one()
        columns = [u]
        for i in range(n-1):
            u = B*u
            columns.append(u.change_ring(QQ))
        A = matrix(QQ, columns).transpose()
        A_i = self.approximate_inverse_of_matrix(A)
        alpha = L.number_field().zero()
        for j in range(m):
            alpha += v[j]*sum(A_i[i, j]*int_basis_L[i] for i in range(n))
        # it is not at all transparent to which precision the matrix A_i
        # has been computed; the required precision depends, it seems, only on
        # the polynomial defining K, and could be computed in advance

        alpha = ElementOfpAdicNumberField_algebraic(L, alpha, K.polynomial())
        phi = pAdicEmbedding(K, L, alpha)
        self._approximate_embedding = phi
        # this computation can get ridiculously large; it would be better to do
        # over ZZ/p^N and only lift to QQ at the very end
        return phi

    def polynomial(self):
        r""" Return the polynomial defining this extension.

        OUTPUT: the polynomial `f\in K_0[x]` defining this extension `L=K[x]/(f)`.

        """
        return self._polynomial

    def degree(self):
        r""" Return the degree of this extension `L/K`.
        """
        return self.polynomial().degree()

    def absolute_degree(self):
        r""" Return the degree of the extension field as an absolute p-adic number field.
        """
        return self.degree()*self.base_field().absolute_degree()

    def pseudovaluation(self):
        r""" Return the pseudovaluation corresponding to the equation defining this extension.

        OUTPUT: the infinite pseudovaluation `v_f` on `K_0[x]` extending `v_K`
        such that `v_f(f)=\infty`.

        Here `K_0` is the number field underlying the base field `K` and `f` is
        the equation defining this extension `L=K[x]/(f)`.

        """
        if not hasattr(self, "_pseudovaluation"):
            K = self.base_field()
            v_K = K.valuation()
            f = self.polynomial()
            v = GaussValuation(f.parent(), v_K)
            while v(f) < Infinity:
                V = v.mac_lane_step(f)
                assert len(V) == 1, "f is not irreducible"
                v = V[0]
            self._pseudovaluation = v
        return self._pseudovaluation

    def relative_integral_basis(self):
        r""" Return a relative integral basis for this extension.

        OUTPUT: a list of polynomials with coefficients in the number field
        underlying the base field, whose images in `L=K[x]/(f)` form an integral
        basis of `L`, with respect to the unique extension of `v_K` to `L`.

        ALGORITHM: we use MacLane's theory of inductive valuations. Let

        .. MATH::

            v_f = [v_0, v_1(\phi_1)=t_1,\ldots,v_n(\phi_n)=\infty]

        be the representation of the infinite pseudovaluation `v_f` corresponding
        to `f` as an inductive valuation. (Note that `\phi_n=f`).
        We may assume that

        .. MATH::

            \deg(\phi_1) < \ldots < \deg(\phi_n).

        Then an integral basis of `L` is given by the polynomials

        .. MATH::

            \frac{\phi_1^{m_1}\cdots\phi_{n-1}^{m_{n-1}}{\pi_K^{a_m}},

        where `m=(m_1,\ldots,m_{n-1})` runs over tupels of nonnegative integers
        such that

        .. MATH::

            m_1\deg(\phi_1) + \ldots + m_i\deg(\phi_i) < \deg(\phi_{i+1})

        for `i=1, \ldots , n-1` and

        .. MATH::

            a_m = \frac{ m_1t_1 + \ldots + m_{n-1}t_{n-1} }{ v_K(\pi_K) }.

        """
        if hasattr(self, "_relative_integral_basis"):
            return self._relative_integral_basis

        K = self.base_field()
        pi_K = K.uniformizer()
        e = K.absolute_ramification_degree()
        assert K.valuation()(pi_K)*e == 1
        v_f = self.pseudovaluation()
        aug_chain = v_f.augmentation_chain()
        phi = [aug_chain[i].phi() for i in range(len(aug_chain)-2, -1, -1)]
        if len(phi) == 0:
            phi = [v_f.domain().gen()]
        elif phi[0].degree() > 1:
            phi = [v_f.domain().gen()] + phi
        d = [phi[i].degree() for i in range(len(phi))]
        t = [v_f(phi[i]) for i in range(len(phi))]
        assert all(d[i] < d[i+1] for i in range(len(d)-1)), "the augmented valuation v_f = {} is not in reduced form!".format(v_f)
        integral_basis = []
        # we have to loop over all m=(m_1,..,m_r) such that m_1d_1+..+m_rd_r <= n
        for m in exponents_of_phi(d):
            g = prod(phi[i]**m[i] for i in range(len(m)))
            s = (e*sum(t[i]*m[i] for i in range(len(m)))).floor()
            integral_basis.append(g*pi_K**(-s))
        assert len(integral_basis) == self.degree()
        self._relative_integral_basis = integral_basis
        return integral_basis

    def base_change_matrix(self):
        r""" Return the base change matrix from the canonical to the relative integral basis.

        OUTPUT: a square matrix `S` over `K_0`, the number field underlying the
        base field of this extension. The matrix `S` is characterized by the
        following property:

        Let `\beta=g(\alpha)` be an element of this extension `L=K[\alpha]`,
        with `g=g_0+g_1x+\ldots+g_{n-1}x^{n-1}\in K_0[x]`.
        Let `u = (g_0,\ldots,g_{n-1})\in K_0^n` be the vector corresponding to
        `g` with respect to the canonical basis. Let `(\alpha_1,\ldots,\alpha_n)`
        be the (relative integral basis of `K[\alpha]/K`. Then

        .. MATH::

            \beta = b_1\alpha_1+\ldots+b_n\alpha_n,

        where

        .. MATH::

            S\cdot u = (b_1,\ldots,b_n).

        """
        if not hasattr(self, "_base_change_matrix"):
            n = self.degree()
            int_basis = self.relative_integral_basis()
            # we create a matrix whose columns correspond to the
            # elements of the integral basis; this is the inverse of S
            T = matrix(self.base_field().number_field(), n)
            for i in range(n):
                for j in range(n):
                    T[i, j] = int_basis[j][i]
            self._inverse_base_change_matrix = T
            self._base_change_matrix = T.inverse()
        return self._base_change_matrix

    def inverse_base_change_matrix(self):
        r""" Return the inverse base change matrix, from the relative integral to the canonical basis.

        """
        if not hasattr(self, "_inverse_base_change_matrix"):
            self._inverse_base_change_matrix = self.base_change_matrix().inverse()
        return self._inverse_base_change_matrix

    def integral_generator(self):
        r""" Return an equation for a integral generator.

        OUTPUT:

        a polynomial `g\in K_0[x]` such that `\beta:=g(\alpha)` is an
        absolute integral generator for this simple extension `L=K[\alpha]`
        (here integral means that its powers yield an integral basis)


        ALGORITHM:

        We use the trick from the proof of Lemma II.10.4 from Neukirch's book.

        """
        v = self.pseudovaluation()
        if v.residue_field().is_prime_field():
            return v.uniformizer()
        else:
            pi = v.uniformizer()
            k = v.residue_field()
            thetab = v.residue_field().gen()
            theta = v.lift(thetab)
            if hasattr(k, "base_field"):
                # this probably means that k is not a true finite field
                from mclf.curves.smooth_projective_curves import make_finite_field
                _, phi, _ = make_finite_field(k)
                thetab = phi(thetab)
            h = thetab.minpoly().change_ring(QQ)
            if v(h(theta)) == v(pi):
                return theta
            else:
                return theta + pi

    def relative_matrix_of_generator(self):
        r""" Return the matrix representing the canonical generator of this extension.

        OUTPUT: a square matrix `A` over the number field `K_0` underlying the base
        field `K` of this extension. The matrix `A` represents the endomorphism
        of this extension `L/K` corresponding to the canonical generator. The
        matrix representation is with respect to the relative integral basis of `L/K`.

        """
        if hasattr(self, "_matrix_of_generator"):
            return self._matrix_of_generator
        K = self.base_field()
        K_0 = K.number_field()
        f = self.polynomial()
        m = f.degree()
        A = matrix(K_0, m)
        S = self.base_change_matrix()
        S_i = self.inverse_base_change_matrix()
        for i in range(m-1):
            A[i+1, i] = K_0(1)
        for i in range(m):
            A[i, m-1] = -f[i]
        return S*A*S_i

    def relative_matrix(self, g):
        r""" Return the matrix representing an approximation of an element of this extension.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a square matrix over `K_0`, representing the element `g(\alpha)`
        as an endomorphism of this extension `L=K[\alpha]/K`, with respect to the
        relative integral basis.

        """
        K = self.base_field()
        K_0 = K.number_field()
        g = g.change_ring(K_0)
        return g(self.relative_matrix_of_generator())

    def relative_vector(self, g):
        r""" Return the vector corresponding to an element of this extension,
        with respect to the relative integral basis.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a vector `v=(a_1,\ldots,a_n)` over `K_0` such that

        .. MATH::

            g = a_1g_1 + \ldots + a_ng_n,

        and where `(g_1,\ldots,g_n)` is the fixed relative integral basis of
        this extension.

        """
        n = self.degree()
        f = self.polynomial()
        _, g = f.quo_rem(g)
        v = vector([g[i] for i in range(n)])
        return self.inverse_base_change_matrix()*v

    def element_from_relative_vector(self, v):
        r""" Return the element of this extension corresponding to a vector,
        with respect to the relative integral basis.

        INPUT:

        - ``v`` -- a vector over the number field `K_0` underlying the base field,
                   of length the degree of this extension

        OUTPUT: the element of this extension corresponding to the polynomial

        ..MATH::

            g = a_1g_1 + \ldots + a_ng_n,

        where `v=(a_1,\ldots,a_n)` and `(g_1,\ldots,g_n)` is the fixed relative
        integral basis.

        """
        return v*vector(self.relative_integral_basis())

    def absolute_integral_basis(self):
        r""" Return an absolute integral basis for this extension.

        OUTPUT: a list of polynomials with coefficients in the number field
        underlying the base field, whose images in `L=K[x]/(f)` form an integral
        basis over `\mathbb{Z}_p} of `L`, with respect to the unique extension
        of `v_K` to `L`.

        """
        K = self.base_field()
        base_int_basis = K.integral_basis()
        rel_int_basis = self.relative_integral_basis()
        abs_int_basis = []
        for g in rel_int_basis:
            for theta in base_int_basis:
                abs_int_basis.append(theta*g)
        return abs_int_basis

    def absolute_matrix(self, g):
        r""" Return a matrix representing an element of this extension.

        INPUT:

        - ``g`` -- a polynomial over the number field `K_0` underlying the base field

        OUTPUT: a square matrix `B` over `\mathbb{Q}`, representing the element
        `\beta=g(\alpha)` as an endomorphism of this extension `L=K[\alpha]`, as a
        vector space over `\mathbb{Q}`, with respect to the absolute integral basis.

        If `\beta` is integral then the entries of `B` should be `p`-integers.

        """
        m = self.degree()
        K = self.base_field()
        A = self.relative_matrix(g)
        # construct B as the matrix representing alpha as endo of L/QQ.
        n = K.absolute_degree()
        B = matrix(QQ, n*m)
        for i in range(m):
            for j in range(m):
                B_ij = K.matrix(A[i, j])
                for k in range(n):
                    for r in range(n):
                        B[i*n+k, j*n+r] = B_ij[k, r]
        return B

    def element_from_absolute_vector(self, v):
        int_basis = self.absolute_integral_basis()
        return sum(v[i]*int_basis[i] for i in range(len(int_basis)))

    def precision(self):
        return self._precision

    def raise_precision(self):
        self._precision = self._precision + 2
        if self._precision > 20:
            raise AssertionError("Maximal precision reached; probably something is wrong!")

    def approximate_inverse_of_matrix(self, A):
        r""" Return an approximate inverse of this matrix.

        INPUT:

        - `A` -- a square matrix over the rationals

        It is assumed that the entries of `A` are `p`-integral, and that `A` is
        invertible over the ring `\mathbb{Z}_{(p)}`.

        OUTPUT: a matrix `B` over `\mathbb{Q}` which is an approximate inverse
        of `A`; more precisely, the coefficients of `B` are integers, and

        .. MATH::

            A\cdot B \equiv B\cdot A \equiv 1 \pmod{p^N},

        where `N` is the *precision* used for computing the extension field.

        """
        p = self.base_field().p()
        N = self.precision()
        R = IntegerModRing(p**N)
        Ab = A.change_ring(R)
        Ab_i = Ab.inverse()
        return Ab_i.change_ring(QQ)

    def approximate_equation_for_generator(self, g, matrix=True):
        r""" Return an approximate absolute equation for a given generator.

        INPUT:

        - ``g`` -- a polynomial over the number field underlying the base field
        - ``matrix`` -- a boolean

        We assume that `\beta=g(\alpha)` is an absolute generator of the p-adic
        number field `L=K[\alpha]` defined by this extension.

        OUTPUT: a polynomial `f` over `\mathbb{Q}`, which is a Krasner
        approximation of the absolute minimal polynomial of `\beta`.

        If ``matrix`` is ``True`` then the pair `(f, A)` is returned, where
        `A` is the matrix representing the the endomorphism of `L/\mathbb{Q}`
        corresponding to `\beta`, with respect to the integral basis.

        """
        A = self.absolute_matrix(g)
        p = self.base_field().p()
        e = self.pseudovaluation().E()*self.base_field().ramification_degree()
        while True:
            R = IntegerModRing(p**self.precision())
            Ab = A.change_ring(R)
            fb = Ab.charpoly()
            f = fb.change_ring(QQ)
            if f.is_squarefree():
                v = GaussValuation(f.parent(), QQ.valuation(p))
                while v(f) < Infinity:
                    V = v.mac_lane_step(f)
                    if len(V) > 1:
                        break
                    else:
                        v = V[0]
                if v(f) == Infinity and v.E() == e:
                    if matrix:
                        return (f, Ab)
                    else:
                        return f
            self.raise_precision()
            # if the precison is greater then a certain threshold, an error
            # is raised. The reason is that probably the chosen element g
            # does not correspond to a generator.

# ------------------------------------------------------------------------------


def exponents_of_phi(d):
    r = len(d)-1
    if r == 0:
        return [[]]
    else:
        E = exponents_of_phi(d[:r])
        ret = []
        for m in E:
            s = sum(m[i]*d[i] for i in range(r-1))
            j = 0
            while s + j*d[r-1] < d[r]:
                ret.append(m + [j])
                j += 1
        return ret
