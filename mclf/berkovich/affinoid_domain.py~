r""" Affinoid domains on the Berkovich projective line.

Let `K` be a field and `v_K` a discrete valuation on `K`. Let `X=\mathbb{P}^1_K`
be the projective line over `K`. Let `X^{an}` denote the
`(K,v_K)`-analytic space associated to `X`. We call `X^{an}` the *Berkovich
line* over `K`.

In this file we realize a Sage class which allows us to create and work with
strictly affinoid subdomains of `X^{an}`.

Let `T` be a Berkovich tree in `X^{an}` and let `r:T-->X^{an}` denote the
canonical retraction map. Let `S` be a nonempty proper subset of `V(T)`.
We define `\bar{S}` as the union of `S` and of all edges connecting two points
of `S`. Then the inverse image `U:=r^{-1}(\bar{S})` is an affinoid subdomain of
`X^{an}`. We use the notation `U=U(T,S)`.

We say that a Berkovich tree `T` *supports* an affinoid domain `U` if there
exists a nonempty proper subset `S` of `V(T)` with `U=U(T,S)`. If this is the
case then `S` consists exactly of the vertices of `T` which lie in `U`.

Given any affinoid domain `U`, there exists a unique minimal tree `T` which
supports `U`. Moreover, every tree `T'` which contracts to `T'` supports `U`
as well.


"""

from sage.structure.sage_object import SageObject
from mclf import *
from mclf.berkovich.berkovich_line import BerkovichLine, TypeIPointOnBerkovichLine, TypeIIPointOnBerkovichLine
from mclf.berkovich.type_V_points import TypeVPointOnBerkovichLine
from mclf.berkovich.berkovich_trees import BerkovichTree
# from mclf.berkovich.valuative_function import ValuativeFunction


class AffinoidTree(BerkovichTree):
    r""" A marked Berkovich tree representing an affinoid subdomain of the Berkovich line.

    An AffinoidTree is a Berkovich tree `T` in which every vertex has an additional
    flag `is_in_affinoid` with value ``True`` or ``False``. It represents an affinoid subdomain
    `U` in the way explained above.

    INPUT:

    - ``X`` -- a Berkovich line
    - ``root`` -- a point on ``X``or None (default = None)
    - ``children`` -- a list of affinoid trees or None (default = None)
    - ``parent`` -- an affinoid tree or none (default = None)
    - ``is_in_affinoid`` -- a boolean or None (default = None)

    OUTPUT:

    An affinoid tree on ``X``. It either empty (if only ``X`` is given) or
    it has root, parent, children and the flag ``_is_in_affinoid`` as given
    by the extra parameters.

    EXAMPLES:
    ::

    sage: K = QQ
    sage: vK = pAdicValuation(K, 2)
    sage: F.<x> = FunctionField(K)
    sage: X = BerkovichLine(F, vK)
    sage: xi0 = X.gauss_point()
    sage: xi1 = X.point_from_discoid(x^2+2, 3/2)
    sage: xi2 = X.point_from_discoid(x^4+2, 3/2)
    sage: xi3 = X.point_from_discoid(x^2+x+1, 1)
    sage: xi4 = X.point_from_discoid(x^2+2, 2, False)

    sage: U1 = AffinoidTree(X)
    sage: U1 = U1.add_points([xi0], [xi1, xi3])
    sage: U2 = AffinoidTree(X)
    sage: U2 = U2.add_points([xi2], [xi4])

    sage: U = U1.union(U2)
    sage: U
    Affinoid tree with 6 vertices
    """

    def __init__(self, X, root=None, children=None, parent=None, is_in_affinoid=False):

        self._X = X
        if root == None:
            self._root = None
            self._children = []
            self._parent = None
            self._is_in_affinoid = False
            # Now we have an empty affinoid tree
        else:
            self._root = root
            self._parent = parent
            self._children = children
            self._is_in_affinoid = is_in_affinoid


    def __repr__(self):

        return "Affinoid tree with %s vertices"%len(self.vertices())

    def copy(self):
        """ Return a copy of self."""

        children = [T1.copy() for T1 in self.children()]
        return AffinoidTree(self._X, self.root(), children, self.parent(), self._is_in_affinoid)

    def add_point(self, xi, is_in_affinoid):
        r"""
        Return the affinoid tree spanned by self and the point xi.

        INPUT:

        - xi -- A point on X
        - is_in_affinoid -- a boolean

        OUTPUT:

        T1, T2, where

        - T1 is the tree obtained from T0=self after inserting xi as a vertex.
        - T2 is the subtree of T1 with root xi

        If T0 has a parent, then the root of T0 must be less than xi.
        Therefore, the parent of T1 will be the original parent of T0.

        Note that this command may change the tree T0!  For instance, xi may
        become the root of T1 and then T0 has T1 as new parent.

        Also, the new vertex (the root of T1) is marked with the flag
        ``is_in_affinoid``.
        """

        T0 = self
        if T0.parent() != None:
            assert T0.root().is_leq(xi), "The root of self must be less than xi, because self has a parent."
        if T0._root == None:
            T0._root = xi
            T0._is_in_affinoid = is_in_affinoid
            return T0, T0       # T0 is the leaf with root xi

        xi0 = T0._root
        if xi0.is_equal(xi):
            # assert T0._is_in_affinoid == is_in_affinoid
            T0._is_in_affinoid = is_in_affinoid
            return T0, T0   # T0 has xi as root

        if xi0.is_leq(xi):
            # now xi0 < xi
            for i in range(len(T0._children)):
                # we run through all immediate children T1 of T0
                T1 = T0._children[i]
                xi1 = T1._root
                if xi1.is_leq(xi):
                    # now xi0 < xi1 <= xi and xi can be added to T1
                    T_new, T_xi = T1.add_point(xi, is_in_affinoid)
                    # note that this does not change the parent of T1, which is still T0
                    # IS THIS TRUE ?? Let's check:
                    assert T_new.parent() == T0
                    T0._children[i] = T_new
                    return T0, T_xi
                elif xi.is_leq(xi1):
                    # now xi0 < xi < xi1; we have to insert x between T0 and T1
                    T1_new = AffinoidTree(T0._X, xi, [T1], T0, is_in_affinoid)
                    T1.make_parent(T1_new)
                    T0._children[i] = T1_new
                    return T0, T1_new
                else:
                    xi2 = xi1.infimum(xi)
                    # note that xi0 <= xi2
                    if not xi0.is_equal(xi2):
                        # now xi0 < xi2; we have to replace T1 (as a subtree of T0)
                        # by a new tree T_new with children T1 and a leaf T_xi
                        T_xi = AffinoidTree(T0._X, xi, [], None, is_in_affinoid) # the new leaf
                        T_new = AffinoidTree(T0._X, xi2, [T1, T_xi], T0, T0._is_in_affinoid)
                        # the new subtree has parent T0
                        # and its root lies in U iff the root of T0 does
                        T1.make_parent(T_new)
                        T_xi.make_parent(T_new)
                        T0._children[i] = T_new
                        return T0, T_xi
            # if we get here, we have to add xi as a new leaf with parent xi0
            T_xi = AffinoidTree(T0._X, xi, [], T0, is_in_affinoid)
            T0._children.append(T_xi)
            return T0, T_xi
        else:
            # now xi0 and xi are uncomparable
            # hence we need a new root
            assert T0.parent() == None, "T0 must not have a parent"
            new_root = xi0.infimum(xi)
            T_xi = AffinoidTree(T0._X, xi, [], None, is_in_affinoid)
            T_new = AffinoidTree(T0._X, new_root, [T0, T_xi], None, is_in_affinoid and T0._is_in_affinoid)
            T0.make_parent(T_new)
            T_xi.make_parent(T_new)
            return T_new, T_xi


    def add_points(self, in_list, out_list):

        T = self
        for xi in in_list:
            T, subtree = T.add_point(xi, True)
        for xi in out_list:
            T, subtree = T.add_point(xi, False)
        return T


    def is_in_affinoid(self, xi):
        r""" Return True if xi lies in the affinoid  U represented by self.

        To test this, we compute the image of xi under the retraction map
        onto the total space of T=self and check wheter it lies on a vertex
        in U or on an edge connecting two vertices in U.
        """

        xi1, T1, T2, is_vertex = self.position(xi)
        # xi1 is the image of xi under the retraction map onto the total
        # space of T=self. If is_vertex==True then xi1 is the root of T1.
        # Otherwise, xi1 lies on the edge connecting the roots of T1 and T2.
        if is_vertex:
            return T1._is_in_affinoid
        else:
            return T1._is_in_affinoid and T2._is_in_affinoid



    def union(self, T1):
        r""" Construct the tree representing the union of the affinoids of two trees.

        INPUT:

        - ``T1`` -- an affinoid tree

        OUTPUT:

        An affinoid tree which represents the union of the affinoids represented
        by T0 = ``self`` and T1.
        """

        T0 = self
        T = T0.copy()
        for xi in T1.vertices():
            T, T1 = T.add_point(xi, False)
        for subtree in T.subtrees():
            xi = subtree.root()
            subtree._is_in_affinoid = (T0.is_in_affinoid(xi) or T1.is_in_affinoid(xi))
        return T

    def show(self):
        r""" Display a graphical representation of self.
        """

        G, vertex_dict = self.graph()
        in_list = []
        out_list = []
        for i, xi in vertex_dict.items():
            if self.is_in_affinoid(xi):
                in_list.append(i)
            else:
                out_list.append(i)
            print i, ": ", xi
        # print vertex_dict
        G.show(partition=[in_list, out_list])

    def compute_connected_components(self, comp_list, new_comp):
        r""" Compute the connected components of the affinoid.

        INPUT:

        - ``comp_list`` -- a list (of lists of lists)
        - ``new_comp`` -- a list (of lists)

        OUTPUT:

        - all connected components whose root is a vertex of T=``self`` are
          added to the list ``comp_list``.
        - all boundary_lists which belong to T and to the connected component
          which contains the root of T  are added to ``new_comp`` (in particular,
          if the root of T does not lie in the affinoid then the list is unchanged).

        Here a *boundary list* is a list of type-V-points which represent holes
        of the affinoid with a common boundary point. A *connected component*
        is a list of boundary lists.

        EXAMPLES:
        ::

        sage: K = QQ
        sage: vK = pAdicValuation(K, 2)
        sage: F.<x> = FunctionField(K)
        sage: X = BerkovichLine(F, vK)
        sage: xi0 = X.gauss_point()
        sage: xi1 = X.point_from_discoid(x+1, 1)
        sage: xi2 = X.point_from_discoid(x+1, 2)
        sage: xi3 = X.point_from_discoid(2+x, 1, in_unit_disk=False)

        sage: U = AffinoidTree(X)
        sage: U = U.add_points([xi0, xi2], [xi1, xi3])
        sage: U
        Affinoid tree with 4 vertices

        sage: component_list = []
        sage: U.compute_connected_components(component_list, [])
        sage: component_list
        [[[Point of type V given by residue class v(1/(x + 1)) > -2]],
        [[Point of type V given by residue class v(x + 1) > 0,
        Point of type V given by residue class v(1/x) > 0]]]
        """

        T = self
        if T._is_in_affinoid:
            if T.parent() == None or T.parent()._is_in_affinoid:
                holes = []
            else:
                holes = [TypeVPointOnBerkovichLine(T.root(), T.parent().root())]
            for T1 in T.children():
                if T1._is_in_affinoid:
                    T1.compute_connected_components(comp_list, new_comp)
                else:
                    holes.append(TypeVPointOnBerkovichLine(T.root(), T1.root()))
                    T1.compute_connected_components(comp_list, [])
            if holes != []:
                new_comp.append(holes)
            # if new_comp == []:
                # print "new_comp is empty!"
                # print "T is %s with root %s and parent %s"%(T, T.root(), T.parent())
                # print "The root of T lies in the affinoid."

            # assert new_comp != []
            if T.parent() == None or not T.parent()._is_in_affinoid:
                # T.root() is the root of a component
                comp_list.append(new_comp)
        else:
            # the root of T does not lie in U
            for T1 in T.children():
                T1.compute_connected_components(comp_list, [])


class AffinoidDomainOnBerkovichLine(SageObject):
    r""" Return the affinoid domain corresponding to the affinoid tree ``T``.

    INPUT:

    - T -- an affinoid tree

    OUTPUT:

    the affinoid corresponding to ``T``
    """

    def __init__(self, T):

        self._X = T._X
        self._T = T

    def __repr__(self):

        return "Affinoid on %s with %s components"%(self._X, self.number_of_components())

    def union(self, V):
        r""" Return the affinoid which is the union of ``self`` with ``V``.
        """
        pass

    def intersection(self, V):
        r""" Return the affinoid which is the intersection of ``self`` with ``V``.
        """
        pass


class RationalDomainOnBerkovichLine(SageObject):

    def __init__(self, X, f):
        r"""
        Return the rational domain on ``X`` defined by ``f``.

        INPUT:

        - ``X`` -- a Berkovich line
        - ``f`` -- a nonconstant rational function on `X`

        OUTPUT:

        the affinoid domain on `X` defined by the inequality

        .. MATH::

               v(f) >= 0.


        EXAMPLES:

        ::
            sage: K = QQ
            sage: vK = pAdicValuation(K, 2)
            sage: F.<x> = FunctionField(K)
            sage: X = BerkovichLine(F, vK)
            sage: U = RationalDomainOnBerkovichLine(X, (x^2+2)/(x+1))

            """
        U = AffinoidTree(X)





#-----------------------------------------------------------------------------

# Obsolete code:
# ==============

def find_boundary_point_on_path(gamma, h_list):
    r""" Find the next boundary point of a given affinoid on the given path.

    INPUT:

    - ``gamma`` -- a directed path on the Berkovich line `X`
    - ``h_list`` -- a list of  valuative functions on `X`; it is assumed that
                    all functions in ``h_list`` are affine on ``gamma``.

    OUTPUT:

    A rational number `s\geq 0` such that `\gamma(s)` is the first boundary
    point on ``gamma`` of the affinoid `U` defined by ``h_list``, or the
    endpoint of ``gamma``.
    """

    xi0 = gamma.point(0)
    eta0 = gamma.direction(0)
    r = gamma.length()
    n = len(h_list)

    a = [h_list[i].eval(xi0) for i in range(n)]
    b = [h_list[i].derivative(eta0) for i in range(n)]
    # now h_i(s) = a_i + b_i*s
    if all([a[i] < 0 for i in range(n)]):
        # xi0 is not in U
        # we are looking for the smallest s in (0,r] such that
        # h_i(s) = a_i+b_i*s >= 0 for some i
        s_list = [-a[i]/b[i] for i in range(n) if b[i] > 0]
        return min(s_list.append(r))
    else:
        # xi0 is in U; we are looking for the smallest s in [0,r] such that
        # a_i+b_i*t < 0 for all t>s and for all i
        s_list = [-a[i]/b[i] for i in range(n) if b[i] < 0]
        return min([r, max(s_list.append(Infinity))])



def create_affinoid_tree(h_list):
    r""" Return a marked tree underlying the affinoid defined by inequalities.

    INPUT:

    - ``h_list`` -- a list of valuative functions on `X`

    OUTPUT:

    An affinoid_tree on `X`. It represents the affinoid U defined by ``h_list``.

    """

    X = h_list[0].X()
    xi0 = X.gauss_point()
    # create a tree with root xi0 and compatible with h_list
    T0 = AffinoidTree(X, xi0)
    for h in h_list():
        T0 = h.make_compatible(T0)
    # invoke recursive function to add boundayr points and set flags right
    return adapt_affinoid_tree_recursively(h_list, T0)


def adapt_affinoid_tree_recursively(h_list, T):
    r""" Adapt T recursively to h_list.

    INPUT:

    - ``h_list`` -- a list of valuative functions on `X`
    - ``T`` -- an affinoid tree on `X`, compatible with h_list

    OUTPUT:

    A refinement of ``T`` as follow: the root
    is the same, all boundary points of U which
    are successors of the root are now vertices of the new tree, and
    every vertex has the is_in-flag set correctly.
    """

    xi0 = T.root()
    # set the is_in-flag for xi0:
    if all([h.eval(xi0) < 0 for h in h_list]):
        # the point xi0 does not lie in U
        T._is_in = False
    else:
        # the point xi0 does lie in U
        T._is_in = True
    # we make sure that T contains all boundary points of U
    # which a direct successors of xi0:
    new_vertices = []
    for T1 in T.subtrees():
        xi1 = T1.root()
        gamma = BerkovichPath(xi0, xi1)
        s = find_boundary_point_on_path(gamma, h_list)
        if s> 0 and s < gamma.length():
            new_vertices.append(gamma(s))
    for xi in new_vertices:
        T = T.add_point(xi)
    # apply the function recursively to subtrees
    for T1 in T.subtrees():
        adapt_affinoid_tree_recursively(h_list, T1)
    return T
